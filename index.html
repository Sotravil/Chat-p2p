<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,viewport-fit=cover,user-scalable=yes"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <meta name="theme-color" content="#0b0f17"/>
  <title>Chat-p2p V3 ‚Äî Sotravil</title>
  <style>
    :root{
      --bg:#0a0e14;
      --panel:#0f1419;
      --panel2:#151d2b;
      --panel-border:#1e2d3d;
      --txt:#e8eaed;
      --txt-secondary:#9aa0a6;
      --muted:#5f6368;
      --ok:#34a853;
      --warn:#fbbc04;
      --bad:#ea4335;
      --border:rgba(255,255,255,.08);
      --border-hover:rgba(255,255,255,.15);
      --shadow:0 8px 24px rgba(0,0,0,.4);
      --shadow-sm:0 2px 8px rgba(0,0,0,.2);
      --radius:16px;
      --radius-sm:10px;
      --radius-xs:6px;
      --pad:14px;
      --mono:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      --sans:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
      --accent-primary:#4285f4;
      --accent-secondary:#a142f4;
      --accent-gradient:linear-gradient(135deg, #4285f4, #a142f4);
      --glass:rgba(255,255,255,.04);
      --glass-border:rgba(255,255,255,.1);
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;
      /* Hide body scrollbar */
      scrollbar-width: none;
      -ms-overflow-style: none;
      /* Mobile-first: prevent text size adjustment */
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    html::-webkit-scrollbar, body::-webkit-scrollbar {
      display: none;
    }
    body{
      margin:0;
      /* Safe area insets for notched devices */
      padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      /* Simplified mobile background */
      background:radial-gradient(800px 400px at 50% 0%, rgba(56,189,248,.12), transparent 70%),
                 var(--bg);
      color:var(--txt);
      font-family:var(--sans);
      font-size:16px; /* Mobile-first base size */
      line-height:1.5;
      -webkit-font-smoothing:antialiased;
      /* Prevent pull-to-refresh bounce */
      overscroll-behavior-y: contain;
      -webkit-tap-highlight-color:transparent; /* Remove tap highlight on mobile */
      touch-action:manipulation; /* Prevent double-tap zoom */
      overflow:hidden;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 16px;
      background:rgba(15,20,25,.92);
      backdrop-filter:blur(16px);
      -webkit-backdrop-filter:blur(16px);
      border-bottom:1px solid var(--panel-border);
      gap:12px;
      min-height:56px;
    }
    header .left{
      display:flex;
      align-items:center;
      gap:12px;
      flex-shrink:0;
    }
    header h1{
      font-size:15px;
      font-weight:700;
      margin:0;
      letter-spacing:-0.3px;
      background:var(--accent-gradient);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
    }
    header .status{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:11px;
      font-weight:500;
      color:var(--txt-secondary);
      padding:6px 12px;
      background:var(--glass);
      border:1px solid var(--glass-border);
      border-radius:20px;
    }
    .dot{
      width:8px;
      height:8px;
      border-radius:50%;
      background:var(--warn);
      box-shadow:0 0 6px var(--warn);
      flex-shrink:0;
    }
    .dot.ok{background:var(--ok);box-shadow:0 0 6px var(--ok)}
    .dot.bad{background:var(--bad);box-shadow:0 0 6px var(--bad)}

    header .right{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    
    /* ========================================
       BUTTONS - Cleaner, More Touch-Friendly
       ======================================== */
    button{
      border:1px solid var(--border);
      background:var(--glass);
      color:var(--txt);
      padding:10px 16px;
      border-radius:var(--radius-sm);
      font-size:13px;
      font-weight:600;
      cursor:pointer;
      transition:all .15s ease;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      white-space:nowrap;
      min-height:40px;
      -webkit-tap-highlight-color:transparent;
    }
    button:hover:not(:disabled){
      background:rgba(255,255,255,.08);
      border-color:var(--border-hover);
    }
    button:active:not(:disabled){
      transform:scale(0.98);
    }
    button:disabled{
      opacity:.4;
      cursor:not-allowed;
    }
    button.primary{
      background:var(--accent-gradient);
      border:none;
      color:#fff;
      box-shadow:0 2px 8px rgba(66,133,244,.3);
    }
    button.primary:hover:not(:disabled){
      box-shadow:0 4px 16px rgba(66,133,244,.4);
    }
    button.danger{
      background:rgba(234,67,53,.12);
      border-color:rgba(234,67,53,.3);
      color:#f28b82;
    }
    button.danger:hover:not(:disabled){
      background:rgba(234,67,53,.2);
      border-color:rgba(234,67,53,.5);
    }
    
    /* Pill badge in header */
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:6px 12px;
      border-radius:20px;
      background:var(--glass);
      border:1px solid var(--glass-border);
      font-size:12px;
      font-weight:600;
      color:var(--txt-secondary);
    }

    /* ========================================
       CELL INDICATOR - Much Better Readability
       ======================================== */
    .cell-indicator{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:5px 10px;
      background:rgba(66,133,244,.1);
      border:1px solid rgba(66,133,244,.25);
      border-radius:8px;
      font-size:11px;
      font-weight:700;
      font-family:var(--mono);
      color:#8ab4f8;
      letter-spacing:.3px;
    }
    .cell-indicator::before{
      content:'üì¶';
      font-size:12px;
    }
    .cell-indicator.synced{
      background:rgba(52,168,83,.1);
      border-color:rgba(52,168,83,.3);
      color:#81c995;
    }
    .cell-indicator.synced::before{
      content:'‚úì';
      font-weight:bold;
    }
    .cell-indicator.behind{
      background:rgba(251,188,4,.1);
      border-color:rgba(251,188,4,.3);
      color:#fdd663;
      animation:pulse-cell 2s ease-in-out infinite;
    }
    .cell-indicator.behind::before{
      content:'‚ö†';
    }
    @keyframes pulse-cell{
      0%,100%{opacity:1}
      50%{opacity:.6}
    }

    /* ========================================
       INPUT FIELDS - Polished Design
       ======================================== */
    input,textarea{
      width:100%;
      padding:12px 14px;
      border-radius:var(--radius-sm);
      border:1px solid var(--border);
      background:rgba(0,0,0,.35);
      color:var(--txt);
      font-size:14px;
      font-family:var(--sans);
      outline:none;
      transition:all .2s ease;
    }
    input::placeholder,textarea::placeholder{
      color:var(--muted);
    }
    input:focus,textarea:focus{
      border-color:var(--accent-primary);
      background:rgba(0,0,0,.45);
      box-shadow:0 0 0 3px rgba(66,133,244,.15);
    }
    
    /* ========================================
       RESOURCE MONITOR - Fixed Positioning
       ======================================== */
    .resource-monitor{
      position:fixed;
      z-index:40;
      background:rgba(15,20,25,.95);
      border:1px solid var(--panel-border);
      border-radius:var(--radius-sm);
      padding:10px 14px;
      box-shadow:var(--shadow);
      font-size:11px;
      color:var(--txt);
      backdrop-filter:blur(12px);
      -webkit-backdrop-filter:blur(12px);
      transition:all .2s ease;
      opacity:.85;
      /* Desktop: bottom right */
      bottom:16px;
      right:16px;
      min-width:200px;
      max-width:260px;
    }
    .resource-monitor:hover{
      opacity:1;
    }
    
    /* Mobile: Compact bottom bar that doesn't overlap content */
    @media(max-width:640px){
      .resource-monitor{
        bottom:8px;
        left:8px;
        right:8px;
        max-width:none;
        padding:8px 12px;
        display:flex;
        flex-wrap:wrap;
        align-items:center;
        justify-content:space-between;
        gap:8px;
      }
      .resource-monitor .resource-header{
        display:none;
      }
      .resource-monitor .resource-row{
        flex:1;
        min-width:70px;
        border:none;
        padding:0;
      }
      .resource-monitor .resource-label{
        display:none;
      }
      .resource-monitor .resource-value::before{
        font-size:10px;
        margin-right:4px;
      }
      #resourceDownloaded::before{content:'‚Üì'}
      #resourceUploaded::before{content:'‚Üë'}
      #resourceTotal::before{content:'Œ£'}
    }
    
    .resource-header{
      display:flex;
      align-items:center;
      gap:6px;
      margin-bottom:8px;
      font-weight:600;
      font-size:12px;
      color:var(--accent-primary);
    }
    .resource-row{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:4px 0;
    }
    .resource-row + .resource-row{
      border-top:1px solid var(--border);
    }
    .resource-label{
      color:var(--muted);
      font-size:10px;
    }
    .resource-value{
      font-weight:600;
      font-family:var(--mono);
      color:var(--txt);
      font-size:11px;
    }
    .resource-value.uploading{
      color:var(--accent-secondary);
      animation:blink 1s ease infinite;
    }
    @keyframes blink{0%,100%{opacity:1}50%{opacity:.5}}
    
    /* ========================================
       MESSAGE BUBBLES - Cleaner Design
       ======================================== */
    .msg{
      max-width:85%;
      padding:12px 16px;
      border-radius:18px;
      background:var(--panel2);
      border:1px solid var(--border);
      margin:10px 0;
      word-wrap:break-word;
      transition:all .15s ease;
      box-shadow:var(--shadow-sm);
    }
    .msg:hover{
      border-color:var(--border-hover);
    }
    .msg.me{
      margin-left:auto;
      background:linear-gradient(135deg, rgba(66,133,244,.15), rgba(161,66,244,.1));
      border-color:rgba(66,133,244,.25);
    }
    .msg .text{
      font-size:14px;
      line-height:1.5;
      color:var(--txt);
    }
    .msg .meta{
      font-size:11px;
      color:var(--muted);
      margin-top:8px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    
    /* ========================================
       CHAT HEADER - Better Layout
       ======================================== */
    .chatHeader{
      padding:12px 16px;
      border-bottom:1px solid var(--panel-border);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      background:rgba(0,0,0,.15);
      position:relative;
    }
    .chatHeader .meta{
      display:flex;
      flex-direction:column;
      gap:4px;
      min-width:0;
      flex:1;
    }
    .chatHeader .meta .room{
      font-size:16px;
      font-weight:700;
      color:var(--txt);
      display:flex;
      align-items:center;
      gap:8px;
    }
    .chatHeader .meta .sub{
      font-size:12px;
      color:var(--muted);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .chatHeader .people{
      display:flex;
      align-items:center;
      gap:8px;
      font-size:12px;
      color:var(--muted);
    }
    
    /* Fullscreen toggle button */
    .fullscreen-toggle{
      position:absolute;
      right:12px;
      top:50%;
      transform:translateY(-50%);
      width:36px;
      height:36px;
      min-height:36px;
      padding:0;
      border-radius:8px;
      font-size:16px;
      background:var(--glass);
      border:1px solid var(--border);
    }
    
    /* ========================================
       COMPOSER - Better Spacing
       ======================================== */
    .composer{
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:12px 16px;
      border-top:1px solid var(--panel-border);
      background:rgba(0,0,0,.1);
    }
    .composer-main{
      display:flex;
      gap:10px;
      align-items:flex-end;
    }
    .composer textarea{
      flex:1;
      min-height:44px;
      max-height:120px;
      resize:none;
      scrollbar-width:none;
    }
    .composer textarea::-webkit-scrollbar{display:none}
    
    /* Audio record button */
    .audio-record-btn{
      width:44px;
      height:44px;
      min-width:44px;
      padding:0;
      border-radius:50%;
      background:var(--glass);
      border:1px solid var(--border);
      font-size:20px;
      transition:all .2s ease;
    }
    .audio-record-btn:hover{
      background:rgba(66,133,244,.15);
      border-color:rgba(66,133,244,.3);
    }
    .audio-record-btn.recording{
      background:rgba(234,67,53,.15);
      border-color:rgba(234,67,53,.4);
      animation:pulse-record 1.5s ease-in-out infinite;
    }
    @keyframes pulse-record{
      0%,100%{box-shadow:0 0 0 0 rgba(234,67,53,.5)}
      50%{box-shadow:0 0 0 10px rgba(234,67,53,0)}
    }
    
    /* ========================================
       LOG PANEL - Subtle Design
       ======================================== */
    .log{
      padding:8px 12px;
      font-family:var(--mono);
      font-size:10px;
      color:var(--muted);
      max-height:80px;
      overflow:auto;
      border-top:1px solid var(--panel-border);
      background:rgba(0,0,0,.15);
      scrollbar-width:none;
    }
    .log::-webkit-scrollbar{display:none}
    .log div{padding:1px 0}
    
    /* ========================================
       MODAL OVERLAYS - Better Backdrop
       ======================================== */
    .modalBackdrop,.modal-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:16px;
      background:rgba(0,0,0,.75);
      backdrop-filter:blur(8px);
      -webkit-backdrop-filter:blur(8px);
      z-index:100;
    }
    .modal{
      width:min(420px,100%);
      background:var(--panel);
      border:1px solid var(--panel-border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    
    /* ========================================
       TOAST NOTIFICATIONS - Cleaner
       ======================================== */
    .toast-container{
      position:fixed;
      top:16px;
      right:16px;
      z-index:200;
      display:flex;
      flex-direction:column;
      gap:8px;
      pointer-events:none;
    }
    .toast{
      min-width:260px;
      max-width:360px;
      padding:12px 16px;
      background:var(--panel);
      border:1px solid var(--panel-border);
      border-radius:var(--radius-sm);
      box-shadow:var(--shadow);
      color:var(--txt);
      font-size:13px;
      pointer-events:auto;
      animation:toast-in .25s ease;
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    @media(max-width:640px){
      .toast-container{
        top:10px;
        left:10px;
        right:10px;
      }
      .toast{
        min-width:auto;
        width:100%;
      }
    }
    
    /* ========================================
       MOBILE RESPONSIVE FIXES
       ======================================== */
    @media(max-width:640px){
      header{
        padding:10px 12px;
        flex-wrap:wrap;
        gap:8px;
      }
      header h1{font-size:14px}
      header .status{
        font-size:10px;
        padding:4px 8px;
      }
      header .right{
        width:100%;
        justify-content:flex-end;
        gap:6px;
      }
      
      button{
        padding:8px 12px;
        font-size:12px;
        min-height:36px;
      }
      
      main{
        padding:8px;
        gap:8px;
        height:calc(100dvh - 52px);
      }
      
      .join{padding:12px}
      .row{flex-direction:column;gap:10px}
      .field{min-width:100%}
      
      input,textarea{
        font-size:16px;
        padding:12px;
      }
      
      .chatHeader{
        padding:10px 12px;
        flex-wrap:wrap;
      }
      .chatHeader .meta .room{font-size:14px}
      .chatHeader .meta .sub{font-size:11px}
      .chatHeader .people{
        width:100%;
        margin-top:6px;
      }
      
      .msg{
        max-width:88%;
        padding:10px 14px;
      }
      .msgs{padding:10px}
      
      .composer{padding:10px 12px}
      
      .panel{border-radius:12px}
      
      .log{max-height:60px;font-size:9px}
    }
    
    /* ...existing code... */
</style>
</head>
<body>
<!-- Pull to Refresh Indicator -->
<div class="pull-refresh-indicator" id="pullRefreshIndicator">
  <span class="icon">üîÑ</span>
  <span id="pullRefreshText">Pull to refresh</span>
</div>

<header>
  <div class="left">
    <h1>Chat‚Äëp2p V3</h1>
    <span class="status"><span id="netDot" class="dot"></span><span id="netText">booting‚Ä¶</span></span>
  </div>
  <div class="right">
    <span class="pill" id="authPill">Guest</span>
    <button id="browseRoomsBtn" class="browse-btn" style="display:none">üìÅ Browse Rooms</button>
    <button id="loginBtn">Login</button>
    <button id="registerBtn" class="primary">Register</button>
    <button id="logoutBtn" class="danger" style="display:none">Logout</button>
  </div>
</header>

<main>
  <section class="panel join">
    <div class="row">
      <div class="field">
        <label>Room</label>
        <input id="roomInput" placeholder="e.g. general" autocomplete="off"/>
      </div>
      <div class="field">
        <label>Display name</label>
        <input id="nameInput" placeholder="e.g. Sotravil" autocomplete="off"/>
      </div>
      <div class="field" style="max-width:170px">
        <label>Poll ms (on interaction)</label>
        <input id="pollInput" type="number" value="2000" min="500" step="100"/>
      </div>
    </div>
    <div class="row" style="align-items:center; justify-content:space-between">
      <div class="hint">
        No backend: <b>Writes</b> via GitHub Contents API, <b>Reads</b> via raw + ETag cache with API fallback.
        Idle = zero network. Active = fast sync.
      </div>
      <div style="display:flex; gap:10px">
        <button id="joinBtn" class="primary">Join</button>
        <button id="leaveBtn">Leave</button>
        <button id="syncBtn" style="display:none">üîÑ Check Messages</button>
      </div>
    </div>
  </section>

  <section class="panel chat" id="chatPanel" style="display:none">
    <div class="chatHeader">
      <div class="meta">
        <div class="room" id="roomTitle">‚Äî</div>
        <div class="sub" id="roomSub">
          <span id="roomSubText">‚Äî</span>
          <span class="cell-indicator" id="cellIndicator" title="Current viewing cell">
            <span id="cellViewingNum">‚Äî</span>/<span id="cellTotalNum">‚Äî</span>
          </span>
        </div>
      </div>
      <div class="people" id="presenceSummary">
        <span id="presenceText">presence: ‚Äî</span>
        <span class="badge" id="unreadBadge"></span>
        <span class="badge mention-badge" id="mentionBadge"></span>
      </div>
      <button id="fullscreenBtn" class="fullscreen-toggle" title="Fullscreen chat">‚õ∂</button>
    </div>

    <div class="msgs" id="messages"></div>

    <div class="composer">
      <div class="reply-preview" id="replyPreview">
        <div class="reply-preview-header">
          <span>Replying to <span id="replyToUser"></span></span>
          <button class="reply-preview-close" id="cancelReply" title="Cancel reply">‚úï</button>
        </div>
        <div class="reply-preview-text" id="replyToText"></div>
      </div>
      <div class="composer-main">
        <button id="audioRecordBtn" class="audio-record-btn" title="Record audio message">üé§</button>
        <textarea id="msgInput" placeholder="Type‚Ä¶ (Enter to send ‚Äî Shift+Enter for newline)"></textarea>
        <button id="sendBtn" class="primary">Send</button>
        <button id="clearBtn">Clear view</button>
      </div>
    </div>

    <!-- Audio Recording Modal -->
    <div class="audio-modal" id="audioModal">
      <div class="audio-modal-content">
        <div class="audio-modal-header">
          <span class="audio-modal-title">üé§ Recording Audio</span>
          <button class="audio-close-btn" id="audioCloseBtn">‚úï</button>
        </div>
        <div class="audio-visualizer" id="audioVisualizer">
          <!-- Waveform bars will be generated here -->
        </div>
        <div class="audio-timer" id="audioTimer">0:00</div>
        <div class="audio-controls">
          <button class="audio-control-btn record" id="audioStopBtn">‚èπÔ∏è Stop</button>
          <button class="audio-control-btn pause" id="audioPauseBtn">‚è∏Ô∏è Pause</button>
          <button class="audio-control-btn send" id="audioSendBtn" style="display:none;">üì§ Send</button>
        </div>
      </div>
    </div>

    <!-- Mobile Gesture Hints -->
    <div class="recording-overlay" id="recordingOverlay"></div>
    <div class="gesture-hint" id="gestureHint">
      <div class="gesture-lock" id="gestureLock">üîí</div>
      <div class="gesture-cancel" id="gestureCancel">‚ùå</div>
      <div class="gesture-text" id="gestureText">Hold to record</div>
    </div>

    <div class="log" id="log"></div>
  </section>
</main>

<!-- ========================================
     RESOURCE MONITOR - Network Usage Display
     ======================================== -->
<div class="resource-monitor" id="resourceMonitor">
  <div class="resource-header">
    <span>üìä</span>
    <span>Network Usage</span>
  </div>
  <div class="resource-row">
    <span class="resource-label">Downloaded:</span>
    <span class="resource-value" id="resourceDownloaded">0 KB</span>
  </div>
  <div class="resource-row">
    <span class="resource-label">Uploaded:</span>
    <span class="resource-value" id="resourceUploaded">0 KB</span>
  </div>
  <div class="resource-row">
    <span class="resource-label">Total:</span>
    <span class="resource-value" id="resourceTotal">0 KB</span>
  </div>
  <div id="resourceProgressContainer" style="display:none;">
    <div class="resource-progress">
      <div class="resource-progress-bar" id="resourceProgressBar" style="width:0%"></div>
    </div>
    <div class="resource-status" id="resourceStatus"></div>
  </div>
</div>

<!-- AUTH MODAL -->
<div class="modalBackdrop" id="authModalBack">
  <div class="modal">
    <div class="top">
      <b id="authModalTitle">Auth</b>
      <button id="authCloseBtn">‚úï</button>
    </div>
    <div class="body">
      <div class="field">
        <label>Username (global)</label>
        <input id="authUserInput" placeholder="username" autocomplete="username"/>
      </div>
      <div class="field">
        <label>Password (dictionary‚Äëvalidated)</label>
        <input id="authPassInput" type="password" placeholder="password" autocomplete="current-password"/>
        <div class="hint" id="dictHint">Loading password dictionary‚Ä¶</div>
      </div>
      <div class="hint" id="authMsg"></div>
    </div>
    <div class="footer">
      <button id="authActionBtn" class="primary">OK</button>
    </div>
  </div>
</div>

<script>
/* ============================================================
   CONFIG
   ============================================================ */

// Repo target (your "backend")
const GH_OWNER  = "Sotravil";
const GH_REPO   = "chat-db";
const GH_BRANCH = "main";

// Token from paste.rs (read-only) via CORS proxy
const TOKEN_PASTE_URL = "https://paste.rs/4UElW.txt";
const CORS_PROXY      = "https://corsproxy.io/?";

// Read receipts / presence
const PRESENCE_ACTIVE_HEARTBEAT_MS = 10_000;   // 10s while ACTIVE
const PRESENCE_RECENT_MS           = 5 * 60_000; // 5 min "recent"

// === ACTIVITY TRACKER ===
const POLL_MS_BURST          = 500;     // Fast checks during conversation burst
const POLL_MS_INTERACTION    = 2000;    // Check after interaction
const POLL_BURST_DURATION    = 10_000;  // 10s burst after sending message
const POLL_MS_IDLE           = 90_000;  // 90s (for presence only)
const IDLE_THRESHOLD_MS      = 2_000;   // 2s since last interaction => idle
const ACTIVE_BURST_MS        = 2_000;   // keep active for 2s after last interaction
const INTERACTION_THROTTLE_MS= 150;     // update timestamps at most every 150ms

// === V3 STORAGE ===
const MANIFEST_VERSION_V3 = 3;

// micro-segmentation
const CELL_MAX_MESSAGES = 4;         // 4 messages per cell (you requested)
const BOX_MAX_CELLS     = 100;       // 100 cells per box (you requested)
const CELLS_PER_BOX     = BOX_MAX_CELLS;

// Paths
const ROOMS_DIR        = "rooms";
const ROOMS_META_DIR   = "rooms-meta";
const ROOMS_CELLS_BASE = "rooms-cells"; // V3 base
const MASTER_ROOMS_DIR = "master-rooms"; // Master sync files

// Password dictionary (immutable / READ ONLY)
const PASSWORD_DICTIONARY_PATH = "config/password_dictionary_v1.json";

/* ============================================================
   DOM
   ============================================================ */
const el = (id)=>document.getElementById(id);
const netDot = el("netDot");
const netText= el("netText");

const authPill   = el("authPill");
const loginBtn   = el("loginBtn");
const registerBtn= el("registerBtn");
const logoutBtn  = el("logoutBtn");
const browseRoomsBtn = el("browseRoomsBtn");

const authModalBack = el("authModalBack");
const authModalTitle= el("authModalTitle");
const authCloseBtn  = el("authCloseBtn");
const authActionBtn = el("authActionBtn");
const authUserInput = el("authUserInput");
const authPassInput = el("authPassInput");
const dictHint      = el("dictHint");
const authMsg       = el("authMsg");

const roomInput  = el("roomInput");
const nameInput  = el("nameInput");
const pollInput  = el("pollInput");
const joinBtn    = el("joinBtn");
const leaveBtn   = el("leaveBtn");
const syncBtn    = el("syncBtn");
const fullscreenBtn = el("fullscreenBtn");

const chatPanel  = el("chatPanel");
const roomTitle  = el("roomTitle");
const roomSub    = el("roomSub");
const roomSubText = el("roomSubText");
const cellIndicator = el("cellIndicator");
const cellViewingNum = el("cellViewingNum");
const cellTotalNum = el("cellTotalNum");
const presenceSummary = el("presenceSummary");
const presenceText = el("presenceText");
const unreadBadge = el("unreadBadge");
const mentionBadge = el("mentionBadge");

const messagesEl = el("messages");
const msgInput   = el("msgInput");
const sendBtn    = el("sendBtn");
const audioRecordBtn = el("audioRecordBtn");
const audioModal = el("audioModal");
const audioCloseBtn = el("audioCloseBtn");
const audioVisualizer = el("audioVisualizer");
const audioTimer = el("audioTimer");
const audioStopBtn = el("audioStopBtn");
const audioPauseBtn = el("audioPauseBtn");
const audioSendBtn = el("audioSendBtn");
const recordingOverlay = el("recordingOverlay");
const gestureHint = el("gestureHint");
const gestureLock = el("gestureLock");
const gestureCancel = el("gestureCancel");
const gestureText = el("gestureText");
const clearBtn   = el("clearBtn");
const replyPreview = el("replyPreview");
const replyToUser = el("replyToUser");
const replyToText = el("replyToText");
const cancelReply = el("cancelReply");
const logEl      = el("log");
const pullRefreshIndicator = el("pullRefreshIndicator");
const pullRefreshText = el("pullRefreshText");

/* ============================================================
   UTIL
   ============================================================ */
function log(msg, level="INFO"){
  const now = new Date();
  const hh = String(now.getHours()).padStart(2,"0");
  const mm = String(now.getMinutes()).padStart(2,"0");
  const ss = String(now.getSeconds()).padStart(2,"0");
  const line = document.createElement("div");
  line.textContent = `[${hh}:${mm}:${ss}] [${level}] ${msg}`;
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function pad6(n){ return String(n).padStart(6,"0"); }
function padBox(n){ return String(n).padStart(6,"0"); }
function b64EncodeUtf8(str){ return btoa(unescape(encodeURIComponent(str))); }
function b64DecodeUtf8(b64){ return decodeURIComponent(escape(atob(b64))); }
function buildProxyUrl(url){
  // Supports urls that arrive already URL-encoded
  let target=url;
  try{
    const decoded = decodeURIComponent(url);
    if(decoded.startsWith("http://") || decoded.startsWith("https://")) target = decoded;
  }catch(_){}
  return `${CORS_PROXY}${target}`;
}
function ghFileUrl(path){
  const encoded = encodeURIComponent(path).replace(/%2F/g,"/");
  return `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encoded}`;
}
function rawUrl(path){
  const clean = path.replace(/^\/+/,"");
  return `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${clean}`;
}
function setNet(state, text){
  netText.textContent = text;
  netDot.classList.remove("ok","bad");
  if(state==="ok"){ netDot.classList.add("ok"); }
  if(state==="bad"){ netDot.classList.add("bad"); }
}

/* ============================================================
   TOAST NOTIFICATIONS
   ============================================================ */
let toastContainer = null;

function ensureToastContainer(){
  if(!toastContainer){
    toastContainer = document.createElement('div');
    toastContainer.className = 'toast-container';
    document.body.appendChild(toastContainer);
  }
  return toastContainer;
}

function showToast(message, type='info', duration=4000){
  const container = ensureToastContainer();
  
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  
  const icon = document.createElement('div');
  icon.className = 'toast-icon';
  const icons = {
    success: '‚úì',
    error: '‚úï',
    warning: '‚ö†',
    info: '‚Ñπ'
  };
  icon.textContent = icons[type] || icons.info;
  
  const msg = document.createElement('div');
  msg.className = 'toast-message';
  msg.textContent = message;
  
  const closeBtn = document.createElement('button');
  closeBtn.className = 'toast-close';
  closeBtn.textContent = '√ó';
  closeBtn.onclick = () => removeToast(toast);
  
  toast.appendChild(icon);
  toast.appendChild(msg);
  toast.appendChild(closeBtn);
  
  container.appendChild(toast);
  
  // Auto remove after duration
  if(duration > 0){
    setTimeout(() => removeToast(toast), duration);
  }
  
  return toast;
}

function removeToast(toast){
  if(!toast || !toast.parentElement) return;
  toast.classList.add('toast-out');
  setTimeout(() => {
    if(toast.parentElement) toast.parentElement.removeChild(toast);
  }, 250);
}

/* ============================================================
   TOKEN LOADER (paste.rs -> extract github_pat_ from HTML)
   ============================================================ */
let GH_TOKEN = null;
let ghTokenReady = false;
let ghTokenPromise = null;

async function loadGhTokenFromPaste(){
  const url = buildProxyUrl(TOKEN_PASTE_URL);
  const res = await fetch(url, { headers:{ "Accept":"text/plain" }});
  if(!res.ok) throw new Error(`Token paste read failed status=${res.status}`);
  let html = await res.text();
  html = html.replace(/\r\n/g,"\n");
  const patRegex = /github_pat_[^<\s"]+/;
  const match = html.match(patRegex);
  if(!match) throw new Error("No github_pat_ found in paste HTML.");
  GH_TOKEN = match[0].trim();
  ghTokenReady = true;
  // Safe log (no token leakage)
  log("‚úÖ GitHub token loaded (safe).","INFO");
  setNet("ok","token ok");
}

async function ensureGhToken(){
  if(ghTokenReady && GH_TOKEN) return;
  if(ghTokenPromise){ await ghTokenPromise; return; }
  ghTokenPromise = loadGhTokenFromPaste();
  await ghTokenPromise;
}

/* ============================================================
   GITHUB HELPERS (ETag raw read + Contents API fallback)
   ============================================================ */

// In-memory ETag cache per raw URL
const RAW_ETAG = new Map(); // key: rawUrl -> {etag, text}

async function rawGetText(path){
  const url = rawUrl(path);
  const headers = {};
  const cached = RAW_ETAG.get(url);
  if(cached?.etag) headers["If-None-Match"] = cached.etag;

  const res = await fetch(url, { method:"GET", headers });
  if(res.status === 304 && cached) return { ok:true, status:304, text: cached.text, etag: cached.etag };
  if(!res.ok) return { ok:false, status:res.status, text:"", etag:null };
  const etag = res.headers.get("etag");
  const text = await res.text();
  if(etag) RAW_ETAG.set(url, { etag, text });
  return { ok:true, status:res.status, text, etag };
}

// Contents GET JSON + sha
async function ghGetJsonWithSha(path){
  await ensureGhToken();
  const res = await fetch(ghFileUrl(path), {
    method:"GET",
    headers:{
      "Accept":"application/vnd.github+json",
      "Authorization":`Bearer ${GH_TOKEN}`
    },
    cache: 'no-store' // Disable cache for real-time updates
  });

  if(res.status===404) return { ok:false, status:404, obj:null, sha:null, rawText:null };
  const rawText = await res.text();
  
  // Track download on success
  if(res.ok && rawText){
    trackDownload(new Blob([rawText]).size, path.split('/').pop());
  }
  
  if(!res.ok) return { ok:false, status:res.status, obj:null, sha:null, rawText };
  const data = JSON.parse(rawText);
  const contentB64 = (data.content||"").replace(/\n/g,"");
  const jsonText = contentB64 ? b64DecodeUtf8(contentB64) : "";
  const obj = jsonText.trim() ? JSON.parse(jsonText) : null;
  return { ok:true, status:res.status, obj, sha:data.sha||null, rawText };
}

// Contents PUT File (for binary data like audio)
async function ghPutFile(path, base64Content, sha=null, message="upload file"){
  await ensureGhToken();
  const body = {
    message: `${message} ${new Date().toISOString()}`,
    content: base64Content,
    branch: GH_BRANCH
  };
  if(sha) body.sha = sha;

  // Try PUT, and on 422/409 attempt one retry by fetching current sha
  const doPut = async (putBody) => {
    const res = await fetch(ghFileUrl(path), {
      method:"PUT",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`,
        "Content-Type":"application/json"
      },
      body: JSON.stringify(putBody)
    });
    const raw = await res.text();
    return { res, raw };
  };

  let attempt = 0;
  let lastErr = null;
  while(attempt < 2){
    const { res, raw } = await doPut(body);
    if(res.ok){
      const data = JSON.parse(raw || '{}');
      return { ok:true, status: res.status, sha: data?.content?.sha || null, url: data?.content?.download_url || null };
    }

    // If GitHub complains about missing sha or conflict, try to GET current sha and retry once
    if((res.status === 422 || res.status === 409) && attempt === 0){
      try{
        const got = await ghGetJsonWithSha(path);
        if(got.sha) body.sha = got.sha;
        else body.sha = null;
        attempt++;
        continue;
      }catch(e){
        lastErr = e;
        break;
      }
    }

    // Other failures: capture and throw
    console.error("[ghPutFile ERROR]", {path, status: res.status, raw});
    lastErr = new Error(`ghPutFile failed status=${res.status} path=${path}`);
    break;
  }

  throw lastErr || new Error(`ghPutFile failed for ${path}`);
}

// Contents PUT JSON
async function ghPutJson(path, obj, sha=null, message="update"){
  await ensureGhToken();
  const jsonText = JSON.stringify(obj, null, 2);
  const contentSize = new Blob([jsonText]).size; // Calculate size for tracking
  const body = {
    message: `${message} ${new Date().toISOString()}`,
    content: b64EncodeUtf8(jsonText),
    branch: GH_BRANCH
  };
  if(sha) body.sha = sha;

  // Try PUT, and on 422/409 attempt one retry by fetching current sha.
  const doPut = async (putBody) => {
    const res = await fetch(ghFileUrl(path), {
      method:"PUT",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`,
        "Content-Type":"application/json"
      },
      body: JSON.stringify(putBody)
    });
    const raw = await res.text();
    
    // Track upload on success
    if(res.ok){
      trackUpload(contentSize, path.split('/').pop());
    }
    
    return { res, raw };
  };

  let attempt = 0;
  let lastErr = null;
  while(attempt < 2){
    const { res, raw } = await doPut(body);
    if(res.ok){
      const data = JSON.parse(raw || '{}');
      return { ok:true, status: res.status, sha: data?.content?.sha || null };
    }

    // If GitHub complains about missing sha or conflict, try to GET current sha and retry once
    if((res.status === 422 || res.status === 409) && attempt === 0){
      try{
        const got = await ghGetJsonWithSha(path);
        if(got.sha) body.sha = got.sha;
        else body.sha = null; // still try even if null
        attempt++;
        continue;
      }catch(e){
        lastErr = e;
        break;
      }
    }

    // Other failures: capture and throw
    console.error("[ghPutJson ERROR]", {path, status: res.status, raw});
    lastErr = new Error(`ghPutJson failed status=${res.status} path=${path} raw=${raw}`);
    break;
  }

  throw lastErr || new Error(`ghPutJson failed for ${path}`);
}

// List directory via Contents API (needed for auth + presence browsing)
async function ghListDir(path){
  await ensureGhToken();
  const res = await fetch(ghFileUrl(path), {
    method:"GET",
    headers:{
      "Accept":"application/vnd.github+json",
      "Authorization":`Bearer ${GH_TOKEN}`
    }
  });
  if(res.status===404) return { ok:false, status:404, items:[] };
  const raw = await res.text();
  if(!res.ok) return { ok:false, status:res.status, items:[] };
  const items = JSON.parse(raw);
  return { ok:true, status:res.status, items: Array.isArray(items)? items: [] };
}

/* ============================================================
   === DICTIONARY LOADER (READ ONLY) ===
   ============================================================ */
let PWD_DICT = null;            // { sha, charset, map }
let PWD_DICT_READY = false;
let PWD_DICT_ERROR = null;

function setAuthDisabled(reason){
  loginBtn.disabled = true;
  registerBtn.disabled = true;
  dictHint.textContent = reason;
  dictHint.style.color = "rgba(239,68,68,.9)";
}

async function loadPasswordDictionary(){
  try{
    // localStorage cache
    const cacheKey = "pwd_dict_cache_v1";
    const cached = localStorage.getItem(cacheKey);
    if(cached){
      try{
        const c = JSON.parse(cached);
        if(c?.sha && c?.dict?.map){
          PWD_DICT = { sha:c.sha, charset:c.dict.charset||"", map:c.dict.map };
          PWD_DICT_READY = true;
          dictHint.textContent = "Dictionary cached ‚úÖ";
        }
      }catch(_){}
    }

    // Always re-check sha (cheap) so we can refresh if repo updates it
    const got = await ghGetJsonWithSha(PASSWORD_DICTIONARY_PATH);
    if(!got.ok || !got.obj){
      PWD_DICT_ERROR = `Dictionary missing/unreadable (status=${got.status}).`;
      setAuthDisabled(PWD_DICT_ERROR);
      return;
    }

    const dict = got.obj;
    if(!dict?.map || typeof dict.map !== "object"){
      PWD_DICT_ERROR = "Dictionary invalid (missing map).";
      setAuthDisabled(PWD_DICT_ERROR);
      return;
    }

    // Store in memory (READ ONLY)
    PWD_DICT = { sha: got.sha, charset: dict.charset || "", map: dict.map };
    PWD_DICT_READY = true;
    PWD_DICT_ERROR = null;

    localStorage.setItem("pwd_dict_cache_v1", JSON.stringify({ sha:got.sha, dict: { charset: PWD_DICT.charset, map: PWD_DICT.map }}));
    dictHint.textContent = "Dictionary ready ‚úÖ";
  }catch(e){
    console.error("[Dictionary ERROR]", e);
    PWD_DICT_ERROR = "Dictionary load failed (network).";
    setAuthDisabled(PWD_DICT_ERROR);
  }
}

async function reloadDictionary(){
  // Safe refresh: just calls load again; sha-based localStorage keeps it cheap.
  PWD_DICT_READY = false;
  await loadPasswordDictionary();
}

/* ============================================================
   === AUTH (GLOBAL USER ACCOUNT, DEVICE SESSION) ===
   ============================================================ */
const SESSION_KEY = "cp2p_session_v1";
let session = null; // {userId, username, loginAt}

function normalizeUsername(u){
  return (u||"").trim().toLowerCase();
}

async function sha256Hex(str){
  const data = new TextEncoder().encode(str);
  const digest = await crypto.subtle.digest("SHA-256", data);
  return [...new Uint8Array(digest)].map(b=>b.toString(16).padStart(2,"0")).join("");
}

function randomSaltB64(){
  const bytes = new Uint8Array(16);
  crypto.getRandomValues(bytes);
  // base64
  let bin = "";
  for(const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}

function validatePasswordWithDict(pw){
  if(!PWD_DICT_READY || !PWD_DICT?.map) return { ok:false, reason:"Dictionary not ready." };
  const map = PWD_DICT.map;
  for(const ch of pw){
    if(!map.hasOwnProperty(ch)) return { ok:false, reason:`Password char not allowed: "${ch}"` };
  }
  return { ok:true };
}

function passwordToNumericStream(pw){
  const map = PWD_DICT.map;
  let out = "";
  for(const ch of pw){
    out += String(map[ch]);
  }
  return out;
}

function splitStream(stream, chunkLen=500){
  const chunks = [];
  for(let i=0;i<stream.length;i+=chunkLen) chunks.push(stream.slice(i, i+chunkLen));
  return chunks;
}

async function hashChunks(streamChunks, salt){
  const hashes = [];
  for(const chunk of streamChunks){
    const hex = await sha256Hex(`${salt}:${chunk}`);
    hashes.push(hex);
  }
  return hashes;
}

async function ensureUsersIndex(){
  // users/index.json format:
  // { v:1, byUsernameLower: { "name": "u_xxx" }, updatedAt }
  const path = "users/index.json";
  const got = await ghGetJsonWithSha(path);
  if(got.ok && got.obj) return { ok:true, sha:got.sha, obj:got.obj };
  if(got.status === 404){
    const obj = { v:1, byUsernameLower:{}, updatedAt: Date.now() };
    const put = await ghPutJson(path, obj, null, "init users index");
    return { ok:true, sha:put.sha, obj };
  }
  return { ok:false, sha:null, obj:null, status:got.status };
}

async function registerUser(username, password){
  if(!PWD_DICT_READY) throw new Error("Password dictionary not ready.");
  const uLower = normalizeUsername(username);
  if(!uLower) throw new Error("Username required.");
  if(uLower.length < 3) throw new Error("Username too short.");
  if(password.length < 4) throw new Error("Password too short.");

  const valid = validatePasswordWithDict(password);
  if(!valid.ok) throw new Error(valid.reason);

  const idx = await ensureUsersIndex();
  if(!idx.ok) throw new Error(`users/index load failed (status=${idx.status})`);

  if(idx.obj.byUsernameLower?.[uLower]) throw new Error("Username already exists.");

  // userId derived from username hash (stable)
  const userId = "u_" + (await sha256Hex(uLower)).slice(0,16);

  const salt = randomSaltB64();
  const stream = passwordToNumericStream(password);
  const chunks = splitStream(stream, 500);
  const hashes = await hashChunks(chunks, salt);

  const profilePath = `users/${userId}/profile.json`;
  const profile = {
    v:1,
    userId,
    username,
    usernameLower: uLower,
    createdAt: Date.now(),
    salt,
    authChunks: hashes.length
  };

  // Write profile
  await ghPutJson(profilePath, profile, null, "create profile");

  // Write chunk hashes
  for(let i=0;i<hashes.length;i++){
    const chunkPath = `users/${userId}/auth/chunk-${pad6(i+1)}.json`;
    const obj = { v:1, idx:i+1, hashHex: hashes[i] };
    await ghPutJson(chunkPath, obj, null, "auth chunk");
  }

  // Update index
  idx.obj.byUsernameLower[uLower] = userId;
  idx.obj.updatedAt = Date.now();
  await ghPutJson("users/index.json", idx.obj, idx.sha, "register user index");

  // Save session device-bound
  session = { userId, username, loginAt: Date.now() };
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  applySessionToUi();
}

async function loginUser(username, password){
  if(!PWD_DICT_READY) throw new Error("Password dictionary not ready.");
  const uLower = normalizeUsername(username);
  if(!uLower) throw new Error("Username required.");

  const valid = validatePasswordWithDict(password);
  if(!valid.ok) throw new Error(valid.reason);

  const idx = await ensureUsersIndex();
  const userId = idx?.obj?.byUsernameLower?.[uLower];
  if(!userId) throw new Error("User not found.");

  const prof = await ghGetJsonWithSha(`users/${userId}/profile.json`);
  if(!prof.ok || !prof.obj) throw new Error("Profile missing.");

  const salt = prof.obj.salt;
  const authChunks = prof.obj.authChunks || 0;
  if(!salt || authChunks<=0) throw new Error("Profile invalid (missing salt/authChunks).");

  const stream = passwordToNumericStream(password);
  const chunks = splitStream(stream, 500);
  const hashes = await hashChunks(chunks, salt);

  if(hashes.length !== authChunks) throw new Error("Password mismatch (chunk count).");

  for(let i=0;i<authChunks;i++){
    const chk = await ghGetJsonWithSha(`users/${userId}/auth/chunk-${pad6(i+1)}.json`);
    if(!chk.ok || !chk.obj) throw new Error("Auth data missing.");
    if(chk.obj.hashHex !== hashes[i]) throw new Error("Password incorrect.");
  }

  session = { userId, username: prof.obj.username || username, loginAt: Date.now() };
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  applySessionToUi();
}

function logout(){
  session = null;
  localStorage.removeItem(SESSION_KEY);
  applySessionToUi();
}

function loadSessionFromStorage(){
  try{
    const raw = localStorage.getItem(SESSION_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(s?.userId && s?.username) session = s;
  }catch(_){}
}

function applySessionToUi(){
  if(session){
    authPill.textContent = `@${session.username}`;
    loginBtn.style.display = "none";
    registerBtn.style.display = "none";
    logoutBtn.style.display = "";
    browseRoomsBtn.style.display = "";
    // Helpful default display name
    if(!nameInput.value.trim()) nameInput.value = session.username;
    // Load last joined room
    loadLastJoinedRoom();
  }else{
    authPill.textContent = "Guest";
    loginBtn.style.display = "";
    registerBtn.style.display = "";
    logoutBtn.style.display = "none";
    browseRoomsBtn.style.display = "none";
  }
}

/* ============================================================
   === ROOM BROWSER & DISCOVERY ===
   ============================================================ */
const LAST_ROOM_KEY = "cp2p_last_room_v1";

function saveLastJoinedRoom(roomName){
  try{
    const data = { room: roomName, userId: session?.userId, timestamp: Date.now() };
    localStorage.setItem(LAST_ROOM_KEY, JSON.stringify(data));
  }catch(_){}
}

function loadLastJoinedRoom(){
  try{
    const raw = localStorage.getItem(LAST_ROOM_KEY);
    if(!raw) return null;
    const data = JSON.parse(raw);
    // Only use if same user and within last 7 days
    if(data.userId === session?.userId && (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000)){
      if(data.room && !roomInput.value.trim()){
        roomInput.value = data.room;
        roomInput.setAttribute('placeholder', `Last: ${data.room}`);
      }
      return data.room;
    }
  }catch(_){}
  return null;
}

async function discoverRooms(){
  try{
    // List all rooms from the rooms directory
    const listed = await ghListDir(ROOMS_DIR);
    if(!listed.ok) return [];
    
    const rooms = [];
    
    // Process rooms in parallel batches for faster loading
    const BATCH_SIZE = 5;
    for(let i = 0; i < listed.items.length; i += BATCH_SIZE){
      const batch = listed.items.slice(i, i + BATCH_SIZE);
      const batchResults = await Promise.all(
        batch.map(async (item) => {
          if(item.type !== 'file' || !item.name.endsWith('.json')) return null;
          const roomName = item.name.replace('.json', '');
          
          try{
            // Try V3 index first (faster, more accurate)
            const indexPath = roomIndexPath(roomName);
            const indexData = await ghGetJsonWithSha(indexPath);
            
            if(indexData.ok && indexData.obj){
              return {
                name: roomName,
                totalMessages: indexData.obj.totalMessages || 0,
                updatedAt: indexData.obj.updatedAt || 0,
                latestCell: indexData.obj.latestCell || 0,
                lastMessageAt: indexData.obj.updatedAt || 0
              };
            }
            
            // Fallback to manifest only if index doesn't exist
            if(indexData.status === 404){
              const manifest = await readManifestSmart(roomName);
              if(manifest.ok && manifest.obj){
                return {
                  name: roomName,
                  totalMessages: manifest.obj.totalMessages || 0,
                  updatedAt: manifest.obj.updatedAt || 0,
                  latestCell: 0,
                  lastMessageAt: manifest.obj.updatedAt || 0
                };
              }
            }
          }catch(e){
            console.warn(`[discoverRooms] Failed to load room ${roomName}:`, e.message);
          }
          
          return null;
        })
      );
      
      // Add successful room loads
      rooms.push(...batchResults.filter(r => r !== null));
    }
    
    return rooms;
  }catch(e){
    console.error('[discoverRooms ERROR]', e);
    return [];
  }
}

async function getRoomActiveUsers(roomName){
  try{
    const dir = await ghListDir(`${ROOMS_META_DIR}/${roomName}/presence`);
    if(!dir.ok) return { active: 0, recent: 0, users: [], lastActivityAt: 0 };
    
    const now = Date.now();
    let active = 0;
    let recent = 0;
    const users = [];
    let lastActivityAt = 0;
    
    for(const item of dir.items){
      if(item.type !== 'file' || !item.name.endsWith('.json')) continue;
      
      const got = await ghGetJsonWithSha(`${ROOMS_META_DIR}/${roomName}/presence/${item.name}`);
      if(got.ok && got.obj){
        const p = got.obj;
        const lastActive = p.lastActiveAt || p.lastSeenAt || 0;
        
        // Track the most recent activity across all users
        if(lastActive > lastActivityAt) lastActivityAt = lastActive;
        
        if(now - lastActive < 30_000){ // 30 seconds = active
          active++;
          users.push({ 
            username: p.username || p.userId, 
            status: 'active',
            lastActiveAt: lastActive
          });
        }else if(now - lastActive < PRESENCE_RECENT_MS){ // 5 min = recent
          recent++;
          users.push({ 
            username: p.username || p.userId, 
            status: 'recent',
            lastActiveAt: lastActive
          });
        }
      }
    }
    
    return { active, recent, users, lastActivityAt };
  }catch(e){
    console.error('[getRoomActiveUsers ERROR]', e);
    return { active: 0, recent: 0, users: [], lastActivityAt: 0 };
  }
}

async function openRoomBrowser(){
  ensureModalDom();
  const overlay = document.getElementById('modalOverlay');
  const titleEl = document.getElementById('modalTitle');
  const bodyEl = document.getElementById('modalBody');
  const okBtn = document.getElementById('modalOk');
  const cancelBtn = document.getElementById('modalCancel');
  
  titleEl.textContent = '\uD83D\uDCC1 Browse Rooms';
  bodyEl.innerHTML = '<div style="text-align:center;padding:20px;color:var(--muted)"><div style="font-size:24px;margin-bottom:10px">üîÑ</div>Loading rooms...</div>';
  okBtn.style.display = 'none';
  cancelBtn.textContent = 'Close';
  overlay.classList.remove('modal-hidden');
  
  // Get current sort preference - MUST be declared before use
  const currentSort = localStorage.getItem('roomBrowserSort') || 'recent-activity';
  
  // Load rooms and presence data
  const rooms = await discoverRooms();
  const lastRoom = loadLastJoinedRoom();
  
  if(rooms.length === 0){
    bodyEl.innerHTML = '<div class="empty-rooms">\uD83C\uDF10 No rooms found.<br>Create one by joining a new room name!</div>';
    return;
  }
  
  // Update loading message with count
  bodyEl.innerHTML = `<div style="text-align:center;padding:20px;color:var(--muted)"><div style="font-size:24px;margin-bottom:10px">üîÑ</div>Loading presence for ${rooms.length} rooms...</div>`;
  
  // Get presence for each room (in parallel batches of 5 for faster loading)
  const roomsWithPresence = [];
  for(let i = 0; i < rooms.length; i += 5){
    const batch = rooms.slice(i, i + 5);
    const results = await Promise.all(
      batch.map(async room => {
        try{
          return {
            ...room,
            presence: await getRoomActiveUsers(room.name)
          };
        }catch(e){
          console.warn(`[openRoomBrowser] Failed to get presence for ${room.name}:`, e.message);
          return {
            ...room,
            presence: { active: 0, recent: 0, users: [], lastActivityAt: 0 }
          };
        }
      })
    );
    roomsWithPresence.push(...results);
    
    // Update progress
    const progress = Math.round((roomsWithPresence.length / rooms.length) * 100);
    bodyEl.innerHTML = `<div style="text-align:center;padding:20px;color:var(--muted)"><div style="font-size:24px;margin-bottom:10px">üîÑ</div>Loading presence: ${progress}%</div>`;
  }
  
  // Function to sort rooms based on selected criteria
  const sortRooms = (sortType) => {
    const sorted = [...roomsWithPresence];
    
    sorted.sort((a, b) => {
      // Always keep last joined room at top if sorting by recent activity
      if(sortType === 'recent-activity'){
        if(a.name === lastRoom) return -1;
        if(b.name === lastRoom) return 1;
      }
      
      switch(sortType){
        case 'recent-activity':
          if(a.presence.active !== b.presence.active) return b.presence.active - a.presence.active;
          if(a.presence.recent !== b.presence.recent) return b.presence.recent - a.presence.recent;
          const aLatest = Math.max(a.presence.lastActivityAt || 0, a.lastMessageAt || 0);
          const bLatest = Math.max(b.presence.lastActivityAt || 0, b.lastMessageAt || 0);
          return bLatest - aLatest;
          
        case 'newest-first':
          return (b.updatedAt || 0) - (a.updatedAt || 0);
          
        case 'oldest-first':
          return (a.updatedAt || 0) - (b.updatedAt || 0);
          
        case 'most-active':
          if(a.presence.active !== b.presence.active) return b.presence.active - a.presence.active;
          if(a.presence.recent !== b.presence.recent) return b.presence.recent - a.presence.recent;
          return (b.totalMessages || 0) - (a.totalMessages || 0);
          
        case 'most-messages':
          return (b.totalMessages || 0) - (a.totalMessages || 0);
          
        default:
          return 0;
      }
    });
    
    return sorted;
  };
  
  // Initial sort
  let sortedRooms = sortRooms(currentSort);
  
  // Create sort selector
  const sortContainer = document.createElement('div');
  sortContainer.style.cssText = 'padding: 10px 15px; border-bottom: 1px solid var(--border); background: var(--bg-secondary)';
  
  const sortLabel = document.createElement('label');
  sortLabel.style.cssText = 'font-size: 13px; color: var(--muted); margin-right: 8px;';
  sortLabel.textContent = '\uD83D\uDD04 Sort by:';
  
  const sortSelect = document.createElement('select');
  sortSelect.style.cssText = 'padding: 5px 10px; border-radius: 4px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text); font-size: 13px; cursor: pointer;';
  sortSelect.innerHTML = `
    <option value="recent-activity">Recent Activity</option>
    <option value="newest-first">Newest Rooms</option>
    <option value="oldest-first">Oldest Rooms</option>
    <option value="most-active">Most Active</option>
    <option value="most-messages">Most Messages</option>
  `;
  sortSelect.value = currentSort;
  
  sortSelect.onchange = () => {
    const newSort = sortSelect.value;
    localStorage.setItem('roomBrowserSort', newSort);
    sortedRooms = sortRooms(newSort);
    renderRoomList();
  };
  
  sortContainer.appendChild(sortLabel);
  sortContainer.appendChild(sortSelect);
  
  // Render room list function
  const renderRoomList = () => {
    const listDiv = document.createElement('div');
    listDiv.className = 'room-list';
    
    for(const room of sortedRooms){
      const item = document.createElement('div');
      item.className = 'room-item';
      if(room.name === lastRoom) item.classList.add('last-joined');
      
      const info = document.createElement('div');
      info.className = 'room-info';
      
      const name = document.createElement('div');
      name.className = 'room-name';
      name.textContent = `#${room.name}`;
      
      const meta = document.createElement('div');
      meta.className = 'room-meta';
      
      const hasActiveUsers = room.presence.active > 0;
      const lastActivity = room.lastMessageAt || room.updatedAt;
      const age = lastActivity ? formatLastActivity(lastActivity, hasActiveUsers) : 'unknown';
      const cellInfo = room.latestCell > 0 ? ` \u00b7 ${room.latestCell} cells` : '';
      
      meta.textContent = `${room.totalMessages || 0} messages${cellInfo} \u00b7 ${age}`;
      
      info.appendChild(name);
      info.appendChild(meta);
      
      const status = document.createElement('div');
      status.className = 'room-status';
      if(room.presence.active > 0) status.classList.add('active');
      
      const count = document.createElement('span');
      count.className = 'user-count';
      
      if(room.presence.active > 0){
        count.innerHTML = `\uD83D\uDFE2 ${room.presence.active}`;
        count.title = `${room.presence.active} active now${room.presence.recent > 0 ? `, ${room.presence.recent} recent` : ''}`;
      }else if(room.presence.recent > 0){
        count.innerHTML = `\uD83D\uDC65 ${room.presence.recent}`;
        count.title = `${room.presence.recent} recent (within 5 min)`;
      }else{
        count.innerHTML = `\uD83D\uDC65 0`;
        count.title = 'No active users';
      }
      
      status.appendChild(count);
      
      item.appendChild(info);
      item.appendChild(status);
      
      item.onclick = () => {
        roomInput.value = room.name;
        closeModal(false);
        setTimeout(() => joinBtn.focus(), 100);
      };
      
      listDiv.appendChild(item);
    }
    
    bodyEl.innerHTML = '';
    bodyEl.appendChild(sortContainer);
    bodyEl.appendChild(listDiv);
  };
  
  // Initial render
  renderRoomList();
} // This closing brace was missing - it closes openRoomBrowser()

function formatTimeAgo(timestamp){
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  if(seconds < 5) return 'just now';
  if(seconds < 60) return `${seconds}s ago`;
  if(seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if(seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  if(seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
  return `${Math.floor(seconds / 604800)}w ago`;
}

function formatLastActivity(timestamp, hasActive){
  if(!timestamp) return 'unknown';
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  
  // For active rooms, show very precise timing
  if(hasActive){
    if(seconds < 5) return 'active now';
    if(seconds < 60) return `active ${seconds}s ago`;
    if(seconds < 300) return `active ${Math.floor(seconds / 60)}m ago`;
  }
  
  // For recent activity
  if(seconds < 5) return 'just now';
  if(seconds < 60) return `${seconds}s ago`;
  if(seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if(seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  if(seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
  return `${Math.floor(seconds / 604800)}w ago`;
}

/* ============================================================
   === ACTIVITY TRACKER ===
   ============================================================ */
window._chat_lastInteraction = Date.now();
window._chat_activeUntil = Date.now() + ACTIVE_BURST_MS;
window._chat_lastMarkAt = 0;
window._chat_fastScrollingUntil = 0;

/* ============================================================
   === MOBILE GESTURE & EMOTION DETECTION ===
   ============================================================ */
const userBehavior = {
  tapHistory: [],
  dwellTimes: new Map(), // msgId -> {startTime, totalTime, visits}
  scrollPatterns: [],
  currentDwell: null,
  engagement: {
    rapidTaps: 0,        // Excitement indicator
    longDwells: 0,       // Interest indicator
    quickScrolls: 0,     // Disinterest/searching
    slowScrolls: 0,      // Reading/interested
    swipeLeft: 0,        // Dismissive gesture
    swipeRight: 0,       // Engaging gesture
    swipeUp: 0,          // Scrolling through
    swipeDown: 0         // Revisiting
  }
};

// Detect tap patterns (single, double, rapid rage taps)
function detectTapPattern(x, y){
  const now = Date.now();
  const tap = { x, y, time: now };
  
  userBehavior.tapHistory.push(tap);
  
  // Keep only last 5 taps (2 second window)
  userBehavior.tapHistory = userBehavior.tapHistory.filter(t => now - t.time < 2000);
  
  if(userBehavior.tapHistory.length >= 3){
    const recentTaps = userBehavior.tapHistory.slice(-3);
    const timeSpan = recentTaps[2].time - recentTaps[0].time;
    
    // Rapid taps within 1 second = excitement/frustration
    if(timeSpan < 1000){
      userBehavior.engagement.rapidTaps++;
      log(`üì± Rapid tap detected (${userBehavior.engagement.rapidTaps}x) - High engagement!`, "INFO");
      return 'rapid';
    }
  }
  
  if(userBehavior.tapHistory.length >= 2){
    const lastTwo = userBehavior.tapHistory.slice(-2);
    const timeDiff = lastTwo[1].time - lastTwo[0].time;
    
    // Double tap within 500ms
    if(timeDiff < 500){
      return 'double';
    }
  }
  
  return 'single';
}

// Track dwell time on messages (how long user looks at each message)
function startMessageDwell(msgId){
  if(!msgId) return;
  
  const now = Date.now();
  
  // End previous dwell if exists
  if(userBehavior.currentDwell && userBehavior.currentDwell.msgId !== msgId){
    endMessageDwell(userBehavior.currentDwell.msgId);
  }
  
  userBehavior.currentDwell = { msgId, startTime: now };
  
  if(!userBehavior.dwellTimes.has(msgId)){
    userBehavior.dwellTimes.set(msgId, {
      startTime: now,
      totalTime: 0,
      visits: 0
    });
  }
}

function endMessageDwell(msgId){
  if(!msgId) return;
  
  const dwell = userBehavior.dwellTimes.get(msgId);
  if(!dwell) return;
  
  const now = Date.now();
  const dwellTime = now - (userBehavior.currentDwell?.startTime || now);
  
  dwell.totalTime += dwellTime;
  dwell.visits++;
  
  // Long dwell (>3 seconds) = high interest
  if(dwellTime > 3000){
    userBehavior.engagement.longDwells++;
    log(`üëÄ Long dwell on message (${(dwellTime/1000).toFixed(1)}s) - User interested!`, "INFO");
  }
  
  userBehavior.currentDwell = null;
}

// Analyze scroll behavior for emotional state
function analyzeScrollBehavior(speed, direction, deltaY){
  const now = Date.now();
  
  const pattern = {
    speed,
    direction, // 'up' or 'down'
    deltaY,
    time: now  };
  
  userBehavior.scrollPatterns.push(pattern);
  
  // Keep only last 10 scrolls (5 second window)
  userBehavior.scrollPatterns = userBehavior.scrollPatterns.filter(p => now - p.time < 5000);
  
  // Fast scrolling (>2000px/s) = searching/disengaged
  if(speed > 2000){
    userBehavior.engagement.quickScrolls++;
    if(userBehavior.engagement.quickScrolls > 5){
      log(`‚ö° Fast scrolling detected - User searching or disengaged`, "INFO");
    }
  }
  // Slow scrolling (<500px/s) = reading carefully
  else if(speed < 500 && Math.abs(deltaY) > 20){
    userBehavior.engagement.slowScrolls++;
    if(userBehavior.engagement.slowScrolls > 3){
      log(`üìñ Slow scrolling - User reading carefully`, "INFO");
    }
  }
}

// Detect swipe emotions
function analyzeSwipe(direction, distance, speed){
  const swipeMap = {
    'left': 'swipeLeft',
    'right': 'swipeRight',
    'up': 'swipeUp',
    'down': 'swipeDown'
  };
  
  if(swipeMap[direction]){
    userBehavior.engagement[swipeMap[direction]]++;
    
    // Fast aggressive swipes = dismissive/negative
    if(speed > 1000 && (direction === 'left' || direction === 'up')){
      log(`üëé Dismissive swipe ${direction} - Possible dislike`, "WARN");
    }
    // Slower, deliberate swipes = engaging
    else if(speed < 500 && (direction === 'right' || direction === 'down')){
      log(`üëç Engaging swipe ${direction} - User interested`, "INFO");
    }
  }
}

// Calculate overall engagement score
function getEngagementScore(){
  const e = userBehavior.engagement;
  
  // Positive signals
  const positive = (e.longDwells * 3) + (e.slowScrolls * 2) + (e.swipeRight * 1.5) + (e.swipeDown * 1);
  
  // Negative signals
  const negative = (e.quickScrolls * 2) + (e.swipeLeft * 1.5) + (e.swipeUp * 1);
  
  // Neutral/excitement
  const excitement = e.rapidTaps * 1;
  
  const score = positive - negative + (excitement * 0.5);
  
  return {
    score: Math.max(0, score),
    sentiment: score > 10 ? 'highly engaged' : score > 5 ? 'engaged' : score > 0 ? 'neutral' : 'disengaged',
    breakdown: { positive, negative, excitement }
  };
}

// Log engagement summary periodically
function logEngagementSummary(){
  const engagement = getEngagementScore();
  const dwellCount = userBehavior.dwellTimes.size;
  
  log(`üìä Engagement: ${engagement.sentiment} (score: ${engagement.score.toFixed(1)}) | Dwells: ${dwellCount} | Taps: ${userBehavior.engagement.rapidTaps}`, "INFO");
}

// Reset engagement tracking (e.g., when switching rooms)
function resetBehaviorTracking(){
  userBehavior.tapHistory = [];
  userBehavior.dwellTimes.clear();
  userBehavior.scrollPatterns = [];
  userBehavior.currentDwell = null;
  for(const key in userBehavior.engagement){
    userBehavior.engagement[key] = 0;
  }
}

/* ============================================================
   PULL-TO-REFRESH GESTURE SYSTEM
   ============================================================ */
let lastRefreshTime = 0;
const REFRESH_COOLDOWN_MS = 3000; // 3 seconds between refreshes

// Unified refresh function
async function triggerManualRefresh(source = "unknown"){
  const now = Date.now();
  
  // Cooldown to prevent spam
  if(now - lastRefreshTime < REFRESH_COOLDOWN_MS){
    log(`‚è±Ô∏è Refresh cooldown active (${((REFRESH_COOLDOWN_MS - (now - lastRefreshTime))/1000).toFixed(1)}s remaining)`, "WARN");
    return false;
  }
  
  if(!currentRoom || !running){
    log("‚ö†Ô∏è Cannot refresh: no active room", "WARN");
    return false;
  }
  
  lastRefreshTime = now;
  
  try{
    // Show indicator as syncing
    pullRefreshIndicator.classList.add('active', 'syncing');
    pullRefreshText.textContent = 'Syncing...';
    
    log(`üîÑ Manual refresh triggered (${source})`, "INFO");
    showToast('üîÑ Syncing messages...', 'info', 2000);
    
    // Call the sync function
    await syncLatestFromStorage();
    
    // Success feedback
    pullRefreshText.textContent = '‚úì Synced!';
    log(`‚úÖ Manual refresh complete`, "INFO");
    showToast('‚úì Chat synced successfully', 'success', 2000);
    
    // Hide indicator after delay
    setTimeout(()=>{
      pullRefreshIndicator.classList.remove('active', 'syncing');
      pullRefreshText.textContent = 'Pull to refresh';
    }, 1500);
    
    return true;
  }catch(e){
    log(`‚ùå Manual refresh failed: ${e.message}`, "ERROR");
    showToast(`‚ùå Sync failed: ${e.message}`, 'error', 3000);
    
    pullRefreshText.textContent = '‚úï Failed';
    setTimeout(()=>{
      pullRefreshIndicator.classList.remove('active', 'syncing');
      pullRefreshText.textContent = 'Pull to refresh';
    }, 1500);
    
    return false;
  }
}

// Pull-to-refresh gesture detection (SINGLE METHOD: tap-hold-drag)
// Stricter requirements to avoid accidental triggers
let pullGestureState = {
  active: false,
  startY: 0,
  startTime: 0,
  currentY: 0,
  holdTimer: null,
  moved: false,
  holdConfirmed: false
};

function initPullToRefreshGesture(){
  if(!messagesEl) return;
  
  messagesEl.addEventListener("touchstart", (e)=>{
    const touch = e.touches[0];
    pullGestureState.startY = touch.clientY;
    pullGestureState.startTime = Date.now();
    pullGestureState.currentY = touch.clientY;
    pullGestureState.moved = false;
    pullGestureState.active = false;
    pullGestureState.holdConfirmed = false;
    
    // Longer hold timer: activate after 500ms (more deliberate)
    clearTimeout(pullGestureState.holdTimer);
    pullGestureState.holdTimer = setTimeout(()=>{
      pullGestureState.holdConfirmed = true;
      pullRefreshIndicator.classList.add('active');
      pullRefreshText.textContent = 'Drag slowly to refresh';
      log("üëÜ Pull gesture ready (hold 500ms)", "INFO");
      
      // Haptic feedback if available
      if(navigator.vibrate) navigator.vibrate(50);
    }, 500);
  }, {passive: true});
  
  messagesEl.addEventListener("touchmove", (e)=>{
    const touch = e.touches[0];
    pullGestureState.currentY = touch.clientY;
    pullGestureState.moved = true;
    
    // Only activate if hold was confirmed
    if(pullGestureState.holdConfirmed && !pullGestureState.active){
      const delta = pullGestureState.currentY - pullGestureState.startY;
      const absDelta = Math.abs(delta);
      
      // Require 20px movement after hold to activate
      if(absDelta > 20){
        pullGestureState.active = true;
        log("üëÜ Pull gesture active (dragging)", "INFO");
      }
    }
    
    if(pullGestureState.active){
      const delta = pullGestureState.currentY - pullGestureState.startY;
      const absDelta = Math.abs(delta);
      const elapsed = Date.now() - pullGestureState.startTime;
      const speed = absDelta / elapsed; // px/ms
      
      // Check for slow vertical movement (> 60px)
      if(absDelta > 60){
        // Slow drag: < 0.3 px/ms (slower than before)
        if(speed < 0.3){
          pullRefreshText.textContent = 'üîÑ Release to refresh';
        }else{
          pullRefreshText.textContent = 'Drag slower...';
        }
      }
    }
  }, {passive: true});
  
  messagesEl.addEventListener("touchend", (e)=>{
    clearTimeout(pullGestureState.holdTimer);
    
    if(pullGestureState.active && pullGestureState.moved){
      const delta = pullGestureState.currentY - pullGestureState.startY;
      const absDelta = Math.abs(delta);
      const elapsed = Date.now() - pullGestureState.startTime;
      const speed = absDelta / elapsed;
      
      // STRICT TRIGGER: held 500ms + moved > 80px slowly (< 0.3 px/ms)
      const holdDuration = elapsed;
      if(holdDuration >= 500 && absDelta > 80 && speed < 0.3){
        log(`‚úì Refresh triggered: hold=${holdDuration}ms, dist=${absDelta.toFixed(0)}px, speed=${speed.toFixed(3)}px/ms`, "INFO");
        triggerManualRefresh("pull-to-refresh");
      }else{
        // Reset without triggering - show why it failed
        if(holdDuration < 500){
          log(`‚úó Hold too short: ${holdDuration}ms (need 500ms+)`, "WARN");
        }else if(absDelta < 80){
          log(`‚úó Movement too small: ${absDelta.toFixed(0)}px (need 80px+)`, "WARN");
        }else if(speed >= 0.3){
          log(`‚úó Drag too fast: ${speed.toFixed(3)}px/ms (need <0.3px/ms)`, "WARN");
        }
        pullRefreshIndicator.classList.remove('active');
        pullRefreshText.textContent = 'Pull to refresh';
      }
    }else{
      pullRefreshIndicator.classList.remove('active');
      pullRefreshText.textContent = 'Pull to refresh';
    }
    
    pullGestureState.active = false;
    pullGestureState.holdConfirmed = false;
  }, {passive: true});
  
  messagesEl.addEventListener("touchcancel", ()=>{
    clearTimeout(pullGestureState.holdTimer);
    pullGestureState.active = false;
    pullGestureState.holdConfirmed = false;
    pullRefreshIndicator.classList.remove('active');
    pullRefreshText.textContent = 'Pull to refresh';
  }, {passive: true});
}

function markInteraction(kind="unknown"){
  const now = Date.now();
  if(now - window._chat_lastMarkAt < INTERACTION_THROTTLE_MS) return;
  window._chat_lastMarkAt = now;
  window._chat_lastInteraction = now;
  window._chat_activeUntil = now + ACTIVE_BURST_MS;

  // Presence: if we were idle, flip online=true once
  if(presenceState.inRoom && presenceState.isIdle){
    presenceSetOnline(true, "interaction");
  }
  
  // Trigger poll check on interaction (if in room and not already polling)
  if(running && currentRoom && !pollInFlight){
    clearTimeout(pollTimer);
    scheduleNextPoll(parseInt(pollInput.value||POLL_MS_INTERACTION,10));
  }
}

function isActiveNow(){
  const now = Date.now();
  return (now <= window._chat_activeUntil) || (now - window._chat_lastInteraction <= IDLE_THRESHOLD_MS);
}

function installInteractionListeners(){
  const opts = { passive:true };

  // Pointer / mouse / keyboard
  ["pointerdown","pointermove","pointerup","click","wheel","scroll","keydown"].forEach(ev=>{
    window.addEventListener(ev, ()=>markInteraction(ev), opts);
  });

  // Touch events with tap pattern detection
  window.addEventListener("touchstart", (e)=>{
    const touch = e.touches[0];
    if(touch){
      const tapPattern = detectTapPattern(touch.clientX, touch.clientY);
      if(tapPattern === 'rapid'){
        markInteraction("rapid-tap");
      }
    }
  }, opts);

  ["touchmove","touchend","touchcancel"].forEach(ev=>{
    window.addEventListener(ev, ()=>markInteraction(ev), opts);
  });

  // Long-press/hold (>= 350ms) with dwell tracking
  let holdTimer = null;
  let holdTarget = null;
  
  window.addEventListener("touchstart", (e)=>{
    holdTarget = e.target.closest('.msg');
    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>{
      markInteraction("long-press");
      if(holdTarget){
        const msgId = holdTarget.dataset.msgId;
        if(msgId){
          startMessageDwell(msgId);
          log(`üîç User dwelling on message`, "INFO");
        }
      }
    }, 350);
  }, opts);
  
  window.addEventListener("touchend", (e)=>{
    clearTimeout(holdTimer);
    if(holdTarget){
      const msgId = holdTarget.dataset.msgId;
      if(msgId) endMessageDwell(msgId);
    }
    holdTarget = null;
  }, opts);
  
  // Mobile gesture detection: swipe with emotion analysis
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  
  window.addEventListener("touchstart", (e)=>{
    touchStartX = e.touches[0]?.clientX || 0;
    touchStartY = e.touches[0]?.clientY || 0;
    touchStartTime = Date.now();
  }, opts);
  
  window.addEventListener("touchend", (e)=>{
    const touchEndX = e.changedTouches[0]?.clientX || 0;
    const touchEndY = e.changedTouches[0]?.clientY || 0;
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;
    const absDeltaX = Math.abs(deltaX);
    const absDeltaY = Math.abs(deltaY);
    const deltaTime = Date.now() - touchStartTime;
    
    // Detect swipe (fast gesture > 50px in < 500ms)
    if(deltaTime < 500 && (absDeltaX > 50 || absDeltaY > 50)){
      const distance = Math.sqrt(absDeltaX * absDeltaX + absDeltaY * absDeltaY);
      const speed = distance / (deltaTime / 1000); // px/s
      
      let direction;
      if(absDeltaX > absDeltaY){
        direction = deltaX > 0 ? 'right' : 'left';
      }else{
        direction = deltaY > 0 ? 'down' : 'up';
      }
      
      analyzeSwipe(direction, distance, speed);
      markInteraction("swipe");
    }
  }, opts);
  
  // Pinch/zoom gesture (indicates engagement)
  window.addEventListener("gesturestart", ()=>markInteraction("pinch"), opts);
  window.addEventListener("gesturechange", ()=>markInteraction("pinch"), opts);
  
  // Orientation change (user rotated device)
  window.addEventListener("orientationchange", ()=>{
    markInteraction("orientation");
    // Check messages after orientation change
    if(running && currentRoom && !pollInFlight){
      setTimeout(pollLoop, 200);
    }
  });
  
  // Focus events (keyboard opened/closed on mobile)
  msgInput.addEventListener("focus", ()=>{
    markInteraction("input-focus");
    startTypingMode();
  });
  
  msgInput.addEventListener("blur", ()=>{
    markInteraction("input-blur");
  });

  // Fast-scroll detector with behavior analysis
  let lastScrollTop = 0;
  let lastT = performance.now();
  messagesEl.addEventListener("scroll", ()=>{
    const now = performance.now();
    const dt = Math.max(1, now - lastT);
    const currentScrollTop = messagesEl.scrollTop;
    const dy = currentScrollTop - lastScrollTop;
    const absDy = Math.abs(dy);
    const speed = (absDy / dt) * 1000; // px/s
    
    // Determine scroll direction
    const direction = dy > 0 ? 'down' : 'up';
    
    // Analyze scrolling behavior for emotions
    analyzeScrollBehavior(speed, direction, dy);
    
    lastScrollTop = currentScrollTop;
    lastT = now;
    
    if(speed > 1600){ // Fast scrolling threshold
      window._chat_fastScrollingUntil = Date.now() + 300;
    }
  }, opts);
  
  // Track message visibility (IntersectionObserver for dwell detection)
  const dwellObserver = new IntersectionObserver((entries)=>{
    entries.forEach(entry =>{
      const msgId = entry.target.dataset.msgId;
      if(!msgId) return;
      
      if(entry.isIntersecting && entry.intersectionRatio > 0.7){
        // Message is 70%+ visible - start dwell tracking
        startMessageDwell(msgId);
      }else if(!entry.isIntersecting || entry.intersectionRatio < 0.3){
        // Message left viewport or mostly hidden
        endMessageDwell(msgId);
      }
    });
  }, {
    root: messagesEl,
    threshold: [0, 0.3, 0.7, 1.0]
  });
  
  // Observe all messages for dwell tracking
  const observeMessages = ()=>{
    messagesEl.querySelectorAll('.msg').forEach(msg => {
      dwellObserver.observe(msg);
    });
  };
  
  // Initial observation
  setTimeout(observeMessages, 500);
  
  // Re-observe when new messages arrive
  const msgObserver = new MutationObserver(observeMessages);
  msgObserver.observe(messagesEl, { childList: true });
  
  // Log engagement summary every 30 seconds
  setInterval(()=>{
    if(running && currentRoom){
      logEngagementSummary();
    }
  }, 30000);
}

/* ============================================================
   ROOM STATE
   ============================================================ */
let currentRoom = null;
let running = false;

// Last known master state
let masterLastValue = false;

/* ============================================================
   REPLY & MENTION SYSTEM
   ============================================================ */
let replyingTo = null; // {msgId, sender, text}
let lastReadMessageTs = 0; // Timestamp of last message user has seen
let unreadCount = 0;
let mentionCount = 0;

function setReplyTo(msg){
  if(!msg) return;
  replyingTo = {
    msgId: msg.id,
    sender: msg.sender,
    text: msg.text,
    userId: msg.userId
  };
  replyPreview.classList.add('active');
  replyToUser.textContent = msg.sender;
  replyToText.textContent = msg.text;
  msgInput.focus();
  log(`üëâ Replying to ${msg.sender}`, "INFO");
}

function cancelReplyTo(){
  replyingTo = null;
  replyPreview.classList.remove('active');
  replyToUser.textContent = '';
  replyToText.textContent = '';
}

function detectMentions(text){
  // Match @username patterns
  const mentionRegex = /@([\w\-]+)/g;
  const mentions = [];
  let match;
  while((match = mentionRegex.exec(text)) !== null){
    mentions.push(match[1]);
  }
  return mentions;
}

function highlightMentions(text, currentUser){
  if(!text) return '';
  const mentionRegex = /@([\w\-]+)/g;
  return text.replace(mentionRegex, (match, username) => {
    const isSelf = (username.toLowerCase() === currentUser.toLowerCase());
    const className = isSelf ? 'mention mention-me' : 'mention';
    return `<span class="${className}">${match}</span>`;
  });
}

function scrollToMessage(msgId){
  const msgEl = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
  if(!msgEl) {
    log(`‚ö†Ô∏è Message ${msgId} not in view`, "WARN");
    return;
  }
  
  // Scroll to message
  msgEl.scrollIntoView({behavior: 'smooth', block: 'center'});
  
  // Highlight it
  msgEl.classList.add('msg-highlight');
  setTimeout(()=>{
    msgEl.classList.remove('msg-highlight');
  }, 2000);
}

function updateUnreadBadge(){
  if(unreadCount > 0){
    unreadBadge.textContent = unreadCount > 99 ? '99+' : String(unreadCount);
  }else{
    unreadBadge.textContent = '';
  }
}

function updateMentionBadge(){
  if(mentionCount > 0){
    mentionBadge.textContent = mentionCount > 99 ? '99+' : String(mentionCount);
  }else{
    mentionBadge.textContent = '';
  }
}

function checkNewMessages(messages){
  if(!session && !localGuest.userId) return;
  
  const userId = session?.userId || localGuest.userId;
  const username = session?.username || nameInput.value || localGuest.name;
  
  let newUnread = 0;
  let newMentions = 0;
  
  for(const msg of messages){
    // Skip own messages
    if(msg.userId === userId) continue;
    
    // Check if message is newer than last read
    if(msg.ts > lastReadMessageTs){
      newUnread++;
      
      // Check for mentions
      const mentions = detectMentions(msg.text);
      if(mentions.some(m => m.toLowerCase() === username.toLowerCase())){
        newMentions++;
      }
    }
  }
  
  unreadCount = newUnread;
  mentionCount = newMentions;
  
  updateUnreadBadge();
  updateMentionBadge();
}

function markAllAsRead(){
  // Set last read to most recent message timestamp
  if(loadedMessages.length > 0){
    const latestMsg = loadedMessages[loadedMessages.length - 1];
    lastReadMessageTs = latestMsg.ts;
  }else{
    lastReadMessageTs = Date.now();
  }
  
  unreadCount = 0;
  mentionCount = 0;
  updateUnreadBadge();
  updateMentionBadge();
  
  // Save to localStorage
  if(currentRoom){
    try{
      const key = `cp2p_lastread_${currentRoom}`;
      localStorage.setItem(key, String(lastReadMessageTs));
    }catch(e){}
  }
}

function loadLastReadTimestamp(){
  if(!currentRoom) return;
  try{
    const key = `cp2p_lastread_${currentRoom}`;
    const stored = localStorage.getItem(key);
    if(stored){
      lastReadMessageTs = parseInt(stored, 10);
      log(`üìñ Last read: ${new Date(lastReadMessageTs).toLocaleTimeString()}`, "INFO");
    }
  }catch(e){}
}

/* ============================================================
   CELL TRACKING & CACHE
   ============================================================ */
let cellMetadata = {
  currentViewingCell: null,
  totalCells: 0,
  latestCell: 0,
  isSynced: false,
  lastUpdate: 0
};

function saveCellMetadataToCache(){
  if(!currentRoom) return;
  try{
    const key = `cp2p_cell_${currentRoom}`;
    localStorage.setItem(key, JSON.stringify(cellMetadata));
  }catch(e){
    console.warn("[Cell Cache] Save failed:", e);
  }
}

function loadCellMetadataFromCache(){
  if(!currentRoom) return;
  try{
    const key = `cp2p_cell_${currentRoom}`;
    const raw = localStorage.getItem(key);
    if(raw){
      const cached = JSON.parse(raw);
      cellMetadata = {...cellMetadata, ...cached};
      updateCellIndicatorUI();
      log(`üì¶ Cell cache loaded: viewing ${cached.currentViewingCell}/${cached.totalCells}`, "INFO");
    }
  }catch(e){
    console.warn("[Cell Cache] Load failed:", e);
  }
}

function updateCellMetadata(viewing, total, latest){
  cellMetadata.currentViewingCell = viewing;
  cellMetadata.totalCells = total;
  cellMetadata.latestCell = latest;
  cellMetadata.isSynced = (viewing >= latest - 1); // Synced if viewing latest or one before
  cellMetadata.lastUpdate = Date.now();
  
  updateCellIndicatorUI();
  saveCellMetadataToCache();
}

function updateCellIndicatorUI(){
  const viewing = cellMetadata.currentViewingCell || 0;
  const total = cellMetadata.totalCells || 0;
  const latest = cellMetadata.latestCell || 0;
  
  if(viewing > 0 && total > 0){
    cellViewingNum.textContent = `Cell ${viewing}`;
    cellTotalNum.textContent = `${total}`;
    
    // Update sync status
    cellIndicator.classList.remove('synced', 'behind');
    if(viewing >= latest){
      cellIndicator.classList.add('synced');
      cellIndicator.title = `Viewing latest cell (${viewing}/${total})`;
    }else if(latest - viewing >= 2){
      cellIndicator.classList.add('behind');
      cellIndicator.title = `Behind by ${latest - viewing} cells - pull to refresh`;
    }else{
      cellIndicator.title = `Viewing cell ${viewing} of ${total}`;
    }
  }else{
    cellViewingNum.textContent = '‚Äî';
    cellTotalNum.textContent = '‚Äî';
    cellIndicator.title = 'No cells loaded';
  }
}

// Poll loop guards
let pollTimer = null;
let pollInFlight = false;
let isTypingMode = false;
let typingTimeout = null;
let lastTypingAt = 0;
let burstModeUntil = 0;  // Timestamp for burst mode end
let lastMessageSyncAt = 0; // Track last time we synced messages for active users

// V3 loaded window
let loadedCellsMin = null;
let loadedCellsMax = null;
let loadedMessages = []; // currently displayed (newest last)
let roomIndex = null;    // rooms-cells/<room>/index.json (cached)
let roomIndexSha = null;

// Presence cache
let presenceCache = new Map(); // userId -> obj
let presenceDirSha = null;
let lastPresenceRefreshAt = 0;

// Audio cache for in-browser playback
let audioCache = new Map(); // audioPath -> { blob, blobUrl, size, cachedAt }
const AUDIO_CACHE_MAX_AGE = 3600000; // 1 hour in milliseconds

// ========================================
// RESOURCE TRACKING - Network Usage Monitor
// ========================================
let resourceStats = {
  downloaded: 0,    // Total bytes downloaded
  uploaded: 0,      // Total bytes uploaded
  currentUpload: null, // Current upload tracking {name, size, loaded}
  currentDownload: null // Current download tracking {name, size, loaded}
};

// Resource monitor DOM elements
let resourceMonitorEl;
let resourceDownloadedEl;
let resourceUploadedEl;
let resourceTotalEl;
let resourceProgressContainer;
let resourceProgressBar;
let resourceStatusEl;

// Read receipts throttling
let lastReadWriteAt = 0;

/* ============================================================
   === V3 AUTO MIGRATION ===
   ============================================================ */

function manifestPath(roomName){ return `${ROOMS_DIR}/${roomName}.json`; }
function masterPath(roomName){ return `${MASTER_ROOMS_DIR}/${roomName}.json`; }

function roomIndexPath(roomName){ return `${ROOMS_CELLS_BASE}/${roomName}/index.json`; }
function boxesIndexPath(roomName){ return `${ROOMS_CELLS_BASE}/${roomName}/boxes/boxes-index.json`; }
function boxPath(roomName, boxNum){ return `${ROOMS_CELLS_BASE}/${roomName}/boxes/box-${padBox(boxNum)}.json`; }
function cellPath(roomName, cellNum){ return `${ROOMS_CELLS_BASE}/${roomName}/cells/cell-${pad6(cellNum)}.json`; }

function presencePath(roomName, userId){ return `${ROOMS_META_DIR}/${roomName}/presence/${userId}.json`; }

async function readManifestSmart(roomName){
  // Prefer raw for low-rate reads; fallback to API for 404/errors
  const raw = await rawGetText(manifestPath(roomName));
  if(raw.ok){
    try{ return { ok:true, obj: JSON.parse(raw.text), source:"raw" }; }catch(e){}
  }
  const api = await ghGetJsonWithSha(manifestPath(roomName));
  if(api.ok && api.obj) return { ok:true, obj: api.obj, source:"api", sha: api.sha };
  return { ok:false, status: raw.status || api.status || 0 };
}

async function ensureRoomV3(roomName){
  // If missing -> create V3 manifest + initial indexes + first cell + first box
  const got = await ghGetJsonWithSha(manifestPath(roomName));
  if(got.status === 404){
    const now = Date.now();

    const manifest = {
      v: MANIFEST_VERSION_V3,
      room: roomName,
      createdAt: now,
      updatedAt: now,
      storage: {
        cellMaxMessages: CELL_MAX_MESSAGES,
        cellsPerBox: CELLS_PER_BOX
      },
      paths: {
        roomIndex: roomIndexPath(roomName),
        boxesIndex: boxesIndexPath(roomName),
        cellsDir: `${ROOMS_CELLS_BASE}/${roomName}/cells/`,
        boxesDir: `${ROOMS_CELLS_BASE}/${roomName}/boxes/`
      }
    };

    // init room index
    const idxObj = {
      v:3,
      room: roomName,
      latestCell: 1,
      totalMessages: 0,
      updatedAt: now
    };

    const boxesIdxObj = {
      v:3,
      room: roomName,
      boxes: [ { box: 1, startCell: 1, endCell: 1, updatedAt: now } ],
      updatedAt: now
    };

    const boxObj = { v:3, room: roomName, box:1, startCell:1, endCell:1, cellCount:1, updatedAt: now };

    // create files (order doesn't matter, but keep clean)
    await ghPutJson(roomIndexPath(roomName), idxObj, null, "init room index");
    await ghPutJson(boxesIndexPath(roomName), boxesIdxObj, null, "init boxes index");
    await ghPutJson(boxPath(roomName, 1), boxObj, null, "init box");
    await ghPutJson(cellPath(roomName, 1), [], null, "init cell");
    await ghPutJson(manifestPath(roomName), manifest, null, "init room manifest v3");

    // Ensure master file exists (false)
    await ensureMasterExists(roomName);

    log(`üÜï Room "${roomName}" created (V3).`);
    return { ok:true, manifest };
  }

  // If exists but not v3 -> migrate silently
  if(got.ok && got.obj && got.obj.v === 3){
    await ensureMasterExists(roomName);
    return { ok:true, manifest: got.obj };
  }

  // Migration path: we will attempt to load all messages and rebuild V3 structure
  log(`üîß Migrating room "${roomName}" to V3 (silent)‚Ä¶`, "INFO");
  const all = await loadAllMessagesAny(roomName, got.obj);
  await rebuildV3FromMessages(roomName, all);

  // Overwrite manifest to V3
  const now = Date.now();
  const manifest = {
    v: MANIFEST_VERSION_V3,
    room: roomName,
    createdAt: (got.obj?.createdAt || now),
    updatedAt: now,
    migratedFrom: (got.obj?.v || "legacy"),
    storage: { cellMaxMessages: CELL_MAX_MESSAGES, cellsPerBox: CELLS_PER_BOX },
    paths: {
      roomIndex: roomIndexPath(roomName),
      boxesIndex: boxesIndexPath(roomName),
      cellsDir: `${ROOMS_CELLS_BASE}/${roomName}/cells/`,
      boxesDir: `${ROOMS_CELLS_BASE}/${roomName}/boxes/`
    }
  };
  await ghPutJson(manifestPath(roomName), manifest, got.sha || null, "migrate manifest v3");
  await ensureMasterExists(roomName);

  log(`‚úÖ Migration done (${all.length} msgs).`, "INFO");
  return { ok:true, manifest };
}

async function loadAllMessagesAny(roomName, existingManifestObj){
  // 1) If rooms/<room>.json is an array (legacy), treat it as history
  if(Array.isArray(existingManifestObj)){
    return existingManifestObj.map(normalizeMessage).filter(Boolean).sort((a,b)=>a.ts-b.ts);
  }

  // 2) If manifest looks like V2 that stored messages in the manifest itself
  // (some earlier builds used rooms/<room>.json as an array)
  const got = await ghGetJsonWithSha(manifestPath(roomName));
  if(got.ok && Array.isArray(got.obj)){
    return got.obj.map(normalizeMessage).filter(Boolean).sort((a,b)=>a.ts-b.ts);
  }

  // 3) Try list cells directory (v2)
  const listed = await ghListDir(`${ROOMS_CELLS_BASE}/${roomName}/cells`);
  if(listed.ok){
    const cellFiles = listed.items
      .filter(it=>it.type==="file" && /^cell-\d{6}\.json$/.test(it.name))
      .sort((a,b)=>a.name.localeCompare(b.name));
    const out = [];
    for(const f of cellFiles){
      const gotCell = await ghGetJsonWithSha(`${ROOMS_CELLS_BASE}/${roomName}/cells/${f.name}`);
      if(gotCell.ok && Array.isArray(gotCell.obj)){
        for(const raw of gotCell.obj){
          const msg = normalizeMessage(raw);
          if(msg) out.push(msg);
        }
      }
    }
    out.sort((a,b)=>a.ts-b.ts);
    return out;
  }

  return [];
}

async function rebuildV3FromMessages(roomName, messages){
  const now = Date.now();
  // Split into cells of 4
  const cells = [];
  for(let i=0;i<messages.length;i+=CELL_MAX_MESSAGES){
    cells.push(messages.slice(i, i+CELL_MAX_MESSAGES));
  }
  const totalCells = Math.max(1, cells.length);

  // Write cells
  for(let c=1;c<=totalCells;c++){
    const arr = cells[c-1] || [];
    await ghPutJson(cellPath(roomName, c), arr, null, `migrate cell ${c}`);
  }

  // Build boxes: 100 cells per box
  const totalBoxes = Math.max(1, Math.ceil(totalCells / CELLS_PER_BOX));
  const boxesIndex = { v:3, room:roomName, boxes:[], updatedAt: now };

  for(let b=1;b<=totalBoxes;b++){
    const startCell = (b-1)*CELLS_PER_BOX + 1;
    const endCell = Math.min(totalCells, b*CELLS_PER_BOX);
    const boxObj = { v:3, room:roomName, box:b, startCell, endCell, cellCount:(endCell-startCell+1), updatedAt: now };
    await ghPutJson(boxPath(roomName,b), boxObj, null, `migrate box ${b}`);
    boxesIndex.boxes.push({ box:b, startCell, endCell, updatedAt: now });
  }
  await ghPutJson(boxesIndexPath(roomName), boxesIndex, null, "migrate boxes index");

  // Room index
  const idxObj = { v:3, room: roomName, latestCell: totalCells, totalMessages: messages.length, updatedAt: now };
  await ghPutJson(roomIndexPath(roomName), idxObj, null, "migrate room index");
}

/* ============================================================
   MESSAGE NORMALIZATION
   ============================================================ */
function normalizeMessage(raw){
  if(!raw || typeof raw !== "object") return null;
  const ts = (typeof raw.ts === "number") ? raw.ts : Date.now();
  const normalized = {
    id: raw.id || `m-${ts}-${Math.random().toString(36).slice(2,8)}`,
    room: raw.room || currentRoom || "unknown",
    sender: raw.sender || "Anon",
    userId: raw.userId || "legacy",
    ts,
    text: String(raw.text || ""),
    edited: !!raw.edited,
    editedAt: raw.editedAt || null,
    deleted: !!raw.deleted,
    createdAt: raw.createdAt || ts,
    replyTo: raw.replyTo || null, // {msgId, sender, text}
    mentions: raw.mentions || [] // Array of mentioned usernames
  };
  
  // ========================================
  // AUDIO METADATA: Preserve all audio-specific fields when loading from GitHub
  // This ensures audio messages maintain their playback info and listen tracking
  // ========================================
  if(raw.type === 'audio'){
    normalized.type = 'audio';
    normalized.audioPath = raw.audioPath || null;           // GitHub path to audio file
    normalized.audioData = raw.audioData || null;           // Base64 data (legacy/just-sent)
    normalized.audioSize = raw.audioSize || 0;              // File size in bytes
    normalized.audioFileName = raw.audioFileName || null;   // Original filename
    normalized.audioFolderType = raw.audioFolderType || null; // 'recorded-audios' or 'media-audios'
    normalized.audioDuration = raw.audioDuration || 0;      // Duration in seconds
    normalized.listenedBy = raw.listenedBy || [];          // AUDIO READ RECEIPT: Array of {userId, username, listenedAt}
  }
  
  return normalized;
}

/* ============================================================
   V3 LOAD / APPEND
   ============================================================ */
async function loadRoomIndex(roomName){
  const got = await ghGetJsonWithSha(roomIndexPath(roomName));
  if(got.ok && got.obj){
    roomIndex = got.obj;
    roomIndexSha = got.sha;
    return roomIndex;
  }
  // If missing (shouldn't), rebuild from scratch empty
  const now = Date.now();
  roomIndex = { v:3, room:roomName, latestCell:1, totalMessages:0, updatedAt: now };
  const put = await ghPutJson(roomIndexPath(roomName), roomIndex, null, "repair room index");
  roomIndexSha = put.sha;
  return roomIndex;
}

async function saveRoomIndex(roomName){
  if(!roomIndex) return;
  roomIndex.updatedAt = Date.now();
  const put = await ghPutJson(roomIndexPath(roomName), roomIndex, roomIndexSha, "update room index");
  roomIndexSha = put.sha;
}

async function ensureCellExists(roomName, cellNum){
  const got = await ghGetJsonWithSha(cellPath(roomName, cellNum));
  if(got.status === 404){
    const put = await ghPutJson(cellPath(roomName, cellNum), [], null, `init cell ${cellNum}`);
    return { ok:true, arr:[], sha: put.sha || null };
  }
  if(!got.ok || !Array.isArray(got.obj)) return { ok:false, arr:[], sha:null };
  return { ok:true, arr:got.obj, sha: got.sha };
}

async function loadCellsRange(roomName, startCell, endCell){
  const out = [];
  for(let c=startCell;c<=endCell;c++){
    const got = await ghGetJsonWithSha(cellPath(roomName, c));
    if(got.ok && Array.isArray(got.obj)){
      for(const raw of got.obj){
        const msg = normalizeMessage(raw);
        if(msg){
          // Tag message with cell number for live tracking
          msg.cell = c;
          out.push(msg);
          
          // Debug: Log audio messages
          if(msg.type === 'audio'){
            console.log('üìº Loaded audio message from GitHub:', {
              msgId: msg.id,
              hasPath: !!msg.audioPath,
              hasData: !!msg.audioData,
              size: formatBytes(msg.audioSize || 0),
              duration: msg.audioDuration,
              path: msg.audioPath
            });
          }
        }
      }
    }
  }
  out.sort((a,b)=>a.ts-b.ts);
  return out;
}

async function loadLatestMessages(roomName, wantCount=50){
  await loadRoomIndex(roomName);
  const latestCell = roomIndex.latestCell || 1;
  const needCells = Math.max(1, Math.ceil(wantCount / CELL_MAX_MESSAGES));
  const startCell = Math.max(1, latestCell - needCells + 1);
  const msgs = await loadCellsRange(roomName, startCell, latestCell);
  loadedCellsMin = startCell;
  loadedCellsMax = latestCell;
  return msgs;
}

async function loadOlderByMessages(roomName, count){
  await loadRoomIndex(roomName);
  if(loadedCellsMin === null) return [];
  if(loadedCellsMin <= 1) return [];

  const needCells = Math.max(1, Math.ceil(count / CELL_MAX_MESSAGES));
  const newStart = Math.max(1, loadedCellsMin - needCells);
  const msgs = await loadCellsRange(roomName, newStart, loadedCellsMin-1);
  loadedCellsMin = newStart;
  return msgs;
}

async function appendMessageV3(roomName, msgObj){
  await loadRoomIndex(roomName);
  let cellNum = roomIndex.latestCell || 1;

  const cell = await ensureCellExists(roomName, cellNum);
  let arr = cell.arr || [];
  let sha = cell.sha;

  // If cell full -> next cell
  if(arr.length >= CELL_MAX_MESSAGES){
    cellNum += 1;
    arr = [];
    sha = null;
    roomIndex.latestCell = cellNum;

    // ensure new cell file exists
    const initResult = await ghPutJson(cellPath(roomName, cellNum), [], null, `init cell ${cellNum}`);
    if(!initResult || !initResult.ok){
      throw new Error(`Failed to initialize new cell ${cellNum}`);
    }

    // update boxes structures when crossing box boundary
    await ensureBoxForCell(roomName, cellNum);
  }

  // write the cell index into the message for later edits
  msgObj.cell = cellNum;
  arr.push(msgObj);
  
  // Critical: Write message to GitHub and verify success
  const put = await ghPutJson(cellPath(roomName, cellNum), arr, sha, `append msg cell ${cellNum}`);
  if(!put || !put.ok || !put.sha){
    throw new Error(`Failed to write message to cell ${cellNum} - no SHA returned`);
  }
  
  // Update room index
  roomIndex.totalMessages = (roomIndex.totalMessages || 0) + 1;
  await saveRoomIndex(roomName);

  // notify master (with retry logic)
  await saveMasterValue(roomName, true);

  log(`‚úì Message appended to cell ${cellNum}, total messages: ${roomIndex.totalMessages}`, "INFO");
  return { cellNum, cellSha: put.sha };
}

async function ensureBoxForCell(roomName, cellNum){
  const boxNum = Math.max(1, Math.ceil(cellNum / CELLS_PER_BOX));
  const startCell = (boxNum-1)*CELLS_PER_BOX + 1;
  const endCell = cellNum;

  // boxes-index
  const gotIdx = await ghGetJsonWithSha(boxesIndexPath(roomName));
  let idxObj = gotIdx.ok && gotIdx.obj ? gotIdx.obj : { v:3, room:roomName, boxes:[], updatedAt: Date.now() };
  let idxSha = gotIdx.sha || null;
  if(!Array.isArray(idxObj.boxes)) idxObj.boxes = [];

  let entry = idxObj.boxes.find(b=>b.box===boxNum);
  if(!entry){
    entry = { box: boxNum, startCell, endCell, updatedAt: Date.now() };
    idxObj.boxes.push(entry);
    idxObj.boxes.sort((a,b)=>a.box-b.box);
  }else{
    entry.endCell = Math.max(entry.endCell||endCell, endCell);
    entry.updatedAt = Date.now();
  }
  idxObj.updatedAt = Date.now();
  const putIdx = await ghPutJson(boxesIndexPath(roomName), idxObj, idxSha, "update boxes-index");
  // box file
  const gotBox = await ghGetJsonWithSha(boxPath(roomName, boxNum));
  const boxObj = gotBox.ok && gotBox.obj ? gotBox.obj : { v:3, room:roomName, box:boxNum, startCell, endCell, cellCount:(endCell-startCell+1), updatedAt:Date.now() };

  boxObj.startCell = startCell;
  boxObj.endCell = Math.max(boxObj.endCell||endCell, endCell);
  boxObj.cellCount = (boxObj.endCell - boxObj.startCell + 1);
  boxObj.updatedAt = Date.now();
  await ghPutJson(boxPath(roomName, boxNum), boxObj, gotBox.sha||null, "update box");
}

/* ============================================================
   MASTER (raw read + API fallback) + POLL LOOP (activity/idle)
   ============================================================ */
async function ensureMasterExists(roomName){
  // Only use new path: master-rooms/<room>.json
  const path = masterPath(roomName);
  
  // Check if exists via raw read (fast)
  const raw = await rawGetText(path);
  if(raw.ok) return;
  
  // Create new master file if doesn't exist
  const got = await ghGetJsonWithSha(path);
  if(got.status === 404){
    await ghPutJson(path, false, null, "init master");
  }
}

async function readMasterValue(roomName){
  const path = masterPath(roomName);
  
  // 1) Try raw read (fast)
  const raw = await rawGetText(path);
  if(raw.ok){
    const t = raw.text.trim().toLowerCase();
    if(t==="true" || t==="false") return { ok:true, value: t==="true", source:"raw" };
    // Some builds store JSON "true"
    try{
      const v = JSON.parse(raw.text);
      return { ok:true, value: !!v, source:"raw-json" };
    }catch(_){}
  }

  // 2) Fallback to API
  try{
    const api = await ghGetJsonWithSha(path);
    if(api.ok){
      return { ok:true, value: !!api.obj, source:"api" };
    }
    return { ok:false, status: api.status, value:false, source:"api" };
  }catch(e){
    return { ok:false, status:0, value:false, source:"error" };
  }
}

async function saveMasterValue(roomName, value){
  const p = masterPath(roomName);
  try{
    const got = await ghGetJsonWithSha(p);
    const sha = got.ok ? got.sha : null;
    const result = await ghPutJson(p, !!value, sha, "set master");
    
    if(!result || !result.ok){
      // Retry once if failed
      log(`‚ö†Ô∏è Master flag update failed, retrying...`, "WARN");
      await sleep(500);
      const got2 = await ghGetJsonWithSha(p);
      const sha2 = got2.ok ? got2.sha : null;
      await ghPutJson(p, !!value, sha2, "set master (retry)");
    }else{
      log(`‚úì Master flag set to ${value}`, "INFO");
    }
  }catch(e){
    console.error('[saveMasterValue ERROR]', e);
    log(`‚ùå Failed to set master flag: ${e.message}`, "ERROR");
  }
}

function scheduleNextPoll(ms){
  clearTimeout(pollTimer);
  pollTimer = setTimeout(pollLoop, ms);
}

// Typing mode: enable fast polling when user is typing
function startTypingMode(){
  const now = Date.now();
  lastTypingAt = now;
  
  if(!isTypingMode){
    isTypingMode = true;
    // Trigger immediate check when typing starts
    clearTimeout(pollTimer);
    setTimeout(pollLoop, 0);
  }
  
  // Auto-disable typing mode after 3 seconds of no typing
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    isTypingMode = false;
    // One final check when typing stops
    if(running && currentRoom) pollLoop();
  }, 3000);
}

function stopTypingMode(){
  clearTimeout(typingTimeout);
  isTypingMode = false;
}

async function pollLoop(){
  try{
    if(!running || !currentRoom) return;
    if(pollInFlight) return;
    
    const roomSnapshot = currentRoom; // Capture room to detect changes

    const now = Date.now();
    const active = isActiveNow();
    
    // Handle idle state
    if(!active){
      if(presenceState.inRoom && !presenceState.isIdle){
        await presenceSetOnline(false, "idle");
      }
      // No more polling when idle - will resume on interaction
      return;
    }

    // Active: ensure presence online
    if(presenceState.inRoom && presenceState.isIdle){
      await presenceSetOnline(true, "active");
    }

    pollInFlight = true;

    // Read master flag (lightweight check)
    const master = await readMasterValue(currentRoom);
    if(!master.ok){
      pollInFlight = false;
      return;
    }

    // ========================================
    // ACTIVE USER MESSAGE SYNC:
    // If user is actively viewing the chat, periodically sync messages
    // even if master flag is false. This ensures they see new messages
    // from other users without waiting for interactions.
    // ========================================
    const shouldForceSync = active && (now - lastMessageSyncAt > 5000); // Sync every 5s when active
    
    // Sync if master=true OR if user is actively viewing (force sync)
    if(master.value || shouldForceSync){
      if(master.value){
        log(`üîÑ Syncing new messages (master=true)...`, "INFO");
      }else{
        log(`üîÑ Active user sync - checking for new messages...`, "INFO");
      }
      
      await syncLatestFromStorage();
      lastMessageSyncAt = now; // Track last sync time
      
      if(master.value){
        await sleep(100);
        await saveMasterValue(currentRoom, false);
      }
      
      // Enter burst mode: check frequently for quick back-and-forth
      burstModeUntil = now + POLL_BURST_DURATION;
    }else{
      // No new messages, just refresh presence
      await maybeRefreshPresence();
    }

    // Smart scheduling:
    // - Burst mode (after message received): aggressive polling for 10s
    // - Typing mode: check while typing
    // - Active viewing: moderate polling to catch new messages
    // - Otherwise: NO automatic polling (wait for interaction)
    
    const inBurstMode = now < burstModeUntil;
    
    if(inBurstMode || isTypingMode || active){
      // Continue polling during conversation or when actively viewing
      let interval;
      if(inBurstMode){
        interval = POLL_MS_BURST;           // 500ms - very fast during conversation
      }else if(isTypingMode){
        interval = POLL_MS_INTERACTION;     // 2000ms - while typing
      }else{
        interval = POLL_MS_INTERACTION * 2; // 4000ms - when just viewing
      }
      scheduleNextPoll(interval);
    }
    // else: stop polling, wait for next interaction
    
  }catch(e){
    console.error("[pollLoop ERROR]", e);
  }finally{
    pollInFlight = false;
  }
}

/* ============================================================
   RENDER + LAZY LOAD (gesture speed based)
   ============================================================ */
function renderAll(messages){
  messagesEl.innerHTML = "";
  loadedMessages = [];
  for(const m of messages) addMessageToDom(m, true);
  messagesEl.scrollTop = messagesEl.scrollHeight;
  setupReadObserver(); // attach read receipts to current DOM nodes
  
  // Check for unread messages and mentions
  checkNewMessages(messages);
}

function addMessageToDom(m, silent=false, prepend=false){
  // Skip if message already exists in DOM
  const existing = messagesEl.querySelector(`[data-msg-id="${m.id}"]`);
  if(existing) return;
  
  // Skip if already in loadedMessages
  if(loadedMessages.some(msg => msg.id === m.id)) return;
  
  // Store to loaded list
  if(prepend) loadedMessages.unshift(m);
  else loadedMessages.push(m);

  const wrap = document.createElement("div");
  wrap.className = "msg" + ((session && m.userId===session.userId) ? " me" : "");
  wrap.dataset.msgId = m.id;
  // Store cell number for live detection
  if(m.cell !== undefined && m.cell !== null){
    wrap.dataset.cell = String(m.cell);
  }
  wrap.dataset.ts = String(m.ts);

  // Reply preview (if message is replying to another)
  if(m.replyTo && m.replyTo.msgId){
    const replyDiv = document.createElement("div");
    replyDiv.className = "msg-reply";
    replyDiv.dataset.replyTo = m.replyTo.msgId;
    replyDiv.onclick = ()=> scrollToMessage(m.replyTo.msgId);
    
    const replyAuthor = document.createElement("div");
    replyAuthor.className = "msg-reply-author";
    replyAuthor.textContent = m.replyTo.sender || "Unknown";
    
    const replyText = document.createElement("div");
    replyText.className = "msg-reply-text";
    replyText.textContent = m.replyTo.text || "";
    
    replyDiv.appendChild(replyAuthor);
    replyDiv.appendChild(replyText);
    wrap.appendChild(replyDiv);
  }

  const text = document.createElement("div");
  text.className = "text";
  
  // Check if this is an audio message
  if(m.type === 'audio' && (m.audioData || m.audioPath)){
    const audioMsg = document.createElement("div");
    audioMsg.className = "msg-audio";
    audioMsg.dataset.msgId = m.id;
    
    const audioPlayBtn = document.createElement("button");
    audioPlayBtn.className = "audio-play-btn";
    audioPlayBtn.innerHTML = "‚¨áÔ∏è"; // Download icon initially
    audioPlayBtn.dataset.playing = "false";
    audioPlayBtn.dataset.loaded = "false";
    audioPlayBtn.title = "Tap to download and play";
    
    const audioWaveform = document.createElement("div");
    audioWaveform.className = "audio-waveform";
    
    // Generate waveform bars
    const barCount = 30;
    for(let i = 0; i < barCount; i++){
      const bar = document.createElement("div");
      bar.className = "audio-wave-bar";
      const height = Math.random() * 30 + 10;
      bar.style.height = height + 'px';
      audioWaveform.appendChild(bar);
    }
    
    const audioDuration = document.createElement("div");
    audioDuration.className = "audio-duration";
    
    // Show file size initially if not downloaded yet
    const audioSize = m.audioSize || 0;
    const durationSec = Math.floor(m.audioDuration || 0);
    
    if(audioSize > 0){
      // Show size before download
      audioDuration.innerHTML = `<span style="opacity:0.7">${formatBytes(audioSize)}</span> ¬∑ ${formatDuration(durationSec)}`;
    }else{
      audioDuration.textContent = formatDuration(durationSec);
    }
    
    // Audio element (hidden)
    const audioElement = document.createElement("audio");
    audioElement.style.display = "none";
    audioElement.preload = "metadata";
    audioElement.dataset.msgId = m.id;
    
    // Load audio function (on-demand)
    const loadAudioOnDemand = async () => {
      if(audioPlayBtn.dataset.loaded === "true") return true;
      
      audioPlayBtn.innerHTML = "‚è≥";
      audioPlayBtn.disabled = true;
      audioDuration.innerHTML = `<span style="opacity:0.7">Loading...</span>`;
      
      try{
        if(m.audioPath){
          // Get from cache or download
          const cached = await getCachedAudio(m.audioPath);
          if(!cached) throw new Error('Failed to download audio');
          
          audioElement.src = cached.blobUrl;
          audioPlayBtn.innerHTML = "‚ñ∂Ô∏è";
          audioPlayBtn.disabled = false;
          audioPlayBtn.dataset.loaded = "true";
          audioPlayBtn.title = "Play audio";
          
          // Update duration display to show just time now
          audioDuration.textContent = formatDuration(durationSec);
          
          console.log('Audio ready for playback:', {
            msgId: m.id,
            size: formatBytes(cached.size),
            path: m.audioPath
          });
          
          return true;
        }else if(m.audioData){
          // Use base64 data (legacy or just-sent)
          audioElement.src = m.audioData;
          audioPlayBtn.innerHTML = "‚ñ∂Ô∏è";
          audioPlayBtn.disabled = false;
          audioPlayBtn.dataset.loaded = "true";
          audioPlayBtn.title = "Play audio";
          audioDuration.textContent = formatDuration(durationSec);
          return true;
        }
      }catch(err){
        console.error('Error loading audio:', err);
        audioPlayBtn.innerHTML = "‚ùå";
        audioPlayBtn.disabled = true;
        audioDuration.innerHTML = `<span style="opacity:0.7;color:var(--danger)">Failed</span>`;
        showToast('Failed to load audio: ' + err.message, 'error');
        return false;
      }
    };
    
    // Handle audio element errors
    audioElement.addEventListener('error', (e) => {
      console.error('Audio playback error:', e);
      audioPlayBtn.innerHTML = "‚ùå";
      audioPlayBtn.disabled = true;
      showToast('Audio playback failed', 'error');
    });
    
    // Play/pause functionality with on-demand loading
    audioPlayBtn.onclick = async () => {
      if(audioPlayBtn.disabled) return;
      
      // Load audio if not loaded yet
      if(audioPlayBtn.dataset.loaded !== "true"){
        const loaded = await loadAudioOnDemand();
        if(!loaded) return;
        // Don't auto-play after download, wait for second click
        showToast('Audio ready. Tap to play.', 'success');
        return;
      }
      
      const isPlaying = audioPlayBtn.dataset.playing === "true";
      
      if(isPlaying){
        audioElement.pause();
        audioPlayBtn.innerHTML = "‚ñ∂Ô∏è";
        audioPlayBtn.dataset.playing = "false";
      }else{
        // Pause all other audio players
        document.querySelectorAll('.audio-play-btn[data-playing="true"]').forEach(btn => {
          if(btn !== audioPlayBtn){
            const otherMsgId = btn.closest('.msg-audio').dataset.msgId;
            const otherAudio = document.querySelector(`audio[data-msg-id="${otherMsgId}"]`);
            if(otherAudio){
              otherAudio.pause();
              btn.innerHTML = "‚ñ∂Ô∏è";
              btn.dataset.playing = "false";
            }
          }
        });
        
        // Play this audio
        audioElement.play().then(() => {
          audioPlayBtn.innerHTML = "‚è∏Ô∏è";
          audioPlayBtn.dataset.playing = "true";
          console.log('Audio playing:', m.id);
          
          // ========================================
          // AUDIO READ RECEIPT: Mark as listened when playback starts
          // This is the ONLY way audio messages get marked as "read"
          // (not just by being visible like regular text messages)
          // ========================================
          markAudioAsListened(m.id);
        }).catch(e => {
          console.error('Error playing audio:', e);
          showToast('Could not play audio: ' + e.message, 'error');
          audioPlayBtn.innerHTML = "‚ùå";
        });
      }
    };
    
    // Update waveform and time during playback
    let playbackAnimationId = null;
    
    const updatePlaybackProgress = () => {
      if(!audioElement.duration) return;
      
      const progress = audioElement.currentTime / audioElement.duration;
      const bars = audioWaveform.querySelectorAll('.audio-wave-bar');
      const activeBarCount = Math.floor(progress * bars.length);
      
      bars.forEach((bar, idx) => {
        if(idx < activeBarCount){
          bar.classList.add('active');
        }else{
          bar.classList.remove('active');
        }
      });
      
      // Update duration display with current time
      const currentSec = Math.floor(audioElement.currentTime);
      audioDuration.textContent = formatDuration(currentSec);
      
      // Continue animation while playing
      if(!audioElement.paused){
        playbackAnimationId = requestAnimationFrame(updatePlaybackProgress);
      }
    };
    
    audioElement.addEventListener('play', () => {
      updatePlaybackProgress();
    });
    
    audioElement.addEventListener('pause', () => {
      if(playbackAnimationId){
        cancelAnimationFrame(playbackAnimationId);
        playbackAnimationId = null;
      }
    });
    
    audioElement.addEventListener('timeupdate', updatePlaybackProgress);
    
    audioElement.addEventListener('ended', () => {
      audioPlayBtn.innerHTML = "‚ñ∂Ô∏è";
      audioPlayBtn.dataset.playing = "false";
      
      // Reset waveform
      const bars = audioWaveform.querySelectorAll('.audio-wave-bar');
      bars.forEach(bar => bar.classList.remove('active'));
      
      // Reset duration
      audioDuration.textContent = formatDuration(durationSec);
    });
    
    // Click waveform to seek
    audioWaveform.onclick = (e) => {
      if(!audioElement.duration) return;
      
      const rect = audioWaveform.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const progress = Math.max(0, Math.min(1, x / rect.width));
      audioElement.currentTime = progress * audioElement.duration;
    };
    
    audioMsg.appendChild(audioPlayBtn);
    audioMsg.appendChild(audioWaveform);
    audioMsg.appendChild(audioDuration);
    
    // ========================================
    // AUDIO READ RECEIPTS: markAudioAsListened()
   
    // Tracks when users actually PLAY audio messages (not just see them).
    // This function is called when user clicks play button on an audio message.
   
    // What it does:
    // 1. Checks if user already listened (prevents duplicates)
    // 2. Adds {userId, username, listenedAt} to message.listenedBy array
    // 3. Updates message in GitHub cell with listened status
    // 4. Marks message as "read" in presence tracking
    // 5. Updates UI badges to show "listened by" count
    // ========================================
    const userId = session?.userId || localGuest.userId;
    const isMyMessage = m.userId === userId;
    
    if(isMyMessage && m.listenedBy && m.listenedBy.length > 0){
      const listenedCount = m.listenedBy.length;
      const listeners = m.listenedBy.map(l => l.username).join(', ');
      const listenedIndicator = document.createElement('div');
      listenedIndicator.className = 'audio-listened-indicator';
      listenedIndicator.innerHTML = `<span title="Listened by: ${listeners}">üéß ${listenedCount}</span>`;
      listenedIndicator.style.cssText = 'font-size:10px; opacity:0.7; margin-top:4px; text-align:right; color:var(--muted);';
      audioMsg.appendChild(listenedIndicator);
    }
    
    text.appendChild(audioMsg);
    text.appendChild(audioElement);
  }else{
    // Regular text message
    // Highlight mentions in text
    if(!m.deleted){
      const currentUser = session?.username || nameInput.value || localGuest.name;
      const highlightedText = highlightMentions(m.text, currentUser);
      text.innerHTML = highlightedText;
    }else{
      text.textContent = "[deleted]";
    }
  }

  const meta = document.createElement("div");
  meta.className = "meta";
  const d = new Date(m.ts);
  const hh = String(d.getHours()).padStart(2,"0");
  const mm = String(d.getMinutes()).padStart(2,"0");
  const timeText = document.createElement("span");
  timeText.textContent = `${hh}:${mm} ¬∑ ${m.sender}${m.edited ? " ¬∑ edited":""}`;
  meta.appendChild(timeText);

  // Message status indicator (for own messages only)
  if(session && m.userId === session.userId){
    const status = document.createElement("span");
    status.className = `msg-status status-${m.status || 'sending'}`;
    status.dataset.msgId = m.id;
    meta.appendChild(status);

    // Retry button for failed messages
    if(m.status === 'failed'){
      const retry = document.createElement("button");
      retry.className = "msg-retry";
      retry.textContent = "Retry";
      retry.onclick = (e) => { e.stopPropagation(); retryMessage(m); };
      meta.appendChild(retry);
      wrap.classList.add('msg-failed');
    }
  }

  const reads = document.createElement("div");
  reads.className = "reads";
  reads.textContent = ""; // filled by updateReadBadges()

  wrap.appendChild(text);
  wrap.appendChild(meta);
  wrap.appendChild(reads);

  // Actions (edit/delete/reply) for all messages
  const actions = document.createElement('div');
  actions.className = 'msg-actions';

  // Reply button (for all messages)
  const replyBtn = document.createElement('button');
  replyBtn.textContent = '‚Ü©Ô∏è Reply';
  replyBtn.addEventListener('click', (e)=>{ 
    e.stopPropagation(); 
    setReplyTo(m); 
  });
  actions.appendChild(replyBtn);

  // Edit/Delete only for own messages
  if(session && m.userId === session.userId){
    // Don't show edit button for audio messages (can't edit audio)
    if(m.type !== 'audio'){
      const editBtn = document.createElement('button');
      editBtn.textContent = '‚úèÔ∏è Edit';
      editBtn.addEventListener('click', (e)=>{ e.stopPropagation(); editMessageById(m.id); });
      actions.appendChild(editBtn);
    }

    const delBtn = document.createElement('button');
    delBtn.textContent = 'üóëÔ∏è Delete';
    delBtn.className = 'danger';
    delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); deleteMessageById(m.id); });

    actions.appendChild(delBtn);
  }
  
  wrap.appendChild(actions);

  if(prepend){
    messagesEl.insertBefore(wrap, messagesEl.firstChild);
  }else{
    messagesEl.appendChild(wrap);
    if(!silent) messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  // Observe for read receipts
  if(readObserver) readObserver.observe(wrap);
}

function clearView(){
  messagesEl.innerHTML = "";
  loadedMessages = [];
  loadedCellsMin = null;
  loadedCellsMax = null;
  log("üßπ Cleared view (history still in GitHub).","INFO");
}

function pickLoadCountFromScrollSpeed(pxPerSec){
  // Mobile flick / fast wheel -> bigger batch
  if(pxPerSec >= 2400) return 100;
  if(pxPerSec >= 1200) return 50;
  return 20;
}

/* ============================================================
   LIVE CELL DETECTION (Scroll-based)
   ============================================================ */
let cellDetectionThrottle = null;

function detectVisibleCells(){
  if(!messagesEl || !currentRoom || !running) return;
  try{
    // Get all message nodes in viewport
    const rect = messagesEl.getBoundingClientRect();
    const messages = messagesEl.querySelectorAll('.msg');
    
    if(messages.length === 0) return;
  
  // Find messages in viewport (center 50% for stability)
  const centerY = rect.top + rect.height / 2;
  const tolerance = rect.height * 0.25; // 25% tolerance
  
  const visibleCells = new Set();
  let closestToCenter = null;
  let closestDistance = Infinity;
  
  for(const msg of messages){
    const msgRect = msg.getBoundingClientRect();
    const msgCenterY = msgRect.top + msgRect.height / 2;
    const distance = Math.abs(msgCenterY - centerY);
    
    // Check if in viewport center area
    if(distance < tolerance){
      const cellNum = parseInt(msg.dataset.cell || '0', 10);
      if(cellNum > 0) visibleCells.add(cellNum);
    }
    
    // Track closest to exact center
    if(distance < closestDistance){
      closestDistance = distance;
      closestToCenter = msg;
    }
  }
  
  // Use cell closest to center as "current viewing cell"
  let viewingCell = null;
  if(closestToCenter){
    viewingCell = parseInt(closestToCenter.dataset.cell || '0', 10);
  }
  
  // If no cell found, use first visible
  if(!viewingCell && visibleCells.size > 0){
    viewingCell = Math.min(...Array.from(visibleCells));
  }
  
  // Update metadata if changed
  if(viewingCell && viewingCell !== cellMetadata.currentViewingCell){
    const totalCells = loadedCellsMax || roomIndex?.latestCell || 0;
    const latestCell = roomIndex?.latestCell || totalCells;
    updateCellMetadata(viewingCell, totalCells, latestCell);
  }
  }catch(e){
    console.warn('[detectVisibleCells]', e.message);
  }
}

function startCellDetection(){
  if(!messagesEl) return;
  
  // Throttled scroll listener
  messagesEl.addEventListener('scroll', ()=>{
    clearTimeout(cellDetectionThrottle);
    cellDetectionThrottle = setTimeout(detectVisibleCells, 150);
  }, {passive: true});
  
  // Initial detection
  setTimeout(detectVisibleCells, 500);
  
  // Periodic check every 3 seconds (backup)
  setInterval(()=>{
    if(running && currentRoom && messagesEl.childElementCount > 0){
      detectVisibleCells();
    }
  }, 3000);
}

function installLazyLoader(){
  let lastTop = messagesEl.scrollTop;
  let lastT = performance.now();

  messagesEl.addEventListener("scroll", async ()=>{
    // If near top -> load older
    if(messagesEl.scrollTop > 90) return;

    const now = performance.now();
    const dt = Math.max(1, now-lastT);
    const dy = Math.abs(messagesEl.scrollTop-lastTop);
    const speed = (dy/dt)*1000; // px/s
    lastTop = messagesEl.scrollTop;
    lastT = now;

    const want = pickLoadCountFromScrollSpeed(speed);

    // Preserve current viewport anchor so content doesn't jump
    const prevHeight = messagesEl.scrollHeight;

    const older = await loadOlderByMessages(currentRoom, want);
    if(!older.length) return;

    // Prepend older
    for(let i=older.length-1;i>=0;i--){
      addMessageToDom(older[i], true, true);
    }
    // Keep scroll position steady (so user doesn't get yeeted)
    const newHeight = messagesEl.scrollHeight;
    messagesEl.scrollTop = newHeight - prevHeight;
    setupReadObserver();
    updateReadBadges();
  }, { passive:true });
}

/* ============================================================
   MESSAGE EDIT / DELETE helpers
   - editMessageById: allow owner to change text; write back to correct cell
   - deleteMessageById: mark deleted=true (delete for everyone)
 ============================================================ */

async function findMessageLocation(msgId){
  // Try loadedMessages first
  for(const m of loadedMessages){
    if(m.id === msgId){
      // If message has cell stored, return quickly
      if(m.cell) return { cell: m.cell, msg: m };
    }
  }

  // Fallback: scan last few cells from roomIndex.latestCell downwards
  await loadRoomIndex(currentRoom);
  const latest = roomIndex?.latestCell || 1;
  const scanCount = Math.min(6, latest); // scan up to last 6 cells
  for(let c = latest; c >= Math.max(1, latest - scanCount + 1); c--){
    try{
      const got = await ghGetJsonWithSha(cellPath(currentRoom, c));
      if(!got.ok || !Array.isArray(got.obj)) continue;
      for(const raw of got.obj){
        if(raw && raw.id === msgId){
          const msg = normalizeMessage(raw);
          msg.cell = c;
          return { cell: c, msg, cellArr: got.obj, cellSha: got.sha };
        }
      }
    }catch(_){/* ignore */}
  }
  return null;
}

/* =========================
   Modal UI (v3 style) ‚Äî openModal / closeModal / showEditModal / showConfirmModal
   These avoid alerts/prompts and use the DOM modal overlay.
   Requires elements with ids: modalOverlay, modalTitle, modalBody, modalOk, modalCancel, modalClose
   If not present, we create a minimal modal markup now.
========================= */

let _modalResolve = null;
function ensureModalDom(){
  if(document.getElementById('modalOverlay')) return;
  const html = `
  <div id="modalOverlay" class="modal-overlay modal-hidden" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-header">
        <div id="modalTitle" class="modal-title">Modal</div>
        <button id="modalClose" class="modal-close">‚úï</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer">
        <button id="modalCancel" class="btn-ghost">Cancel</button>
        <button id="modalOk" class="primary">OK</button>
      </div>
    </div>
  </div>`;
  document.body.insertAdjacentHTML('beforeend', html);
  const mo = document.getElementById('modalOverlay');
  document.getElementById('modalClose').addEventListener('click', ()=> closeModal(false));
  document.getElementById('modalCancel').addEventListener('click', ()=> closeModal(false));
  document.getElementById('modalOk').addEventListener('click', ()=> closeModal(true));
}

function openModal({ title, bodyNode, okText='OK', cancelText='Cancel', showCancel=true }){
  ensureModalDom();
  const overlay = document.getElementById('modalOverlay');
  const titleEl = document.getElementById('modalTitle');
  const bodyEl = document.getElementById('modalBody');
  const okBtn = document.getElementById('modalOk');
  const cancelBtn = document.getElementById('modalCancel');

  titleEl.textContent = title || 'Modal';
  bodyEl.innerHTML = '';
  if(bodyNode) bodyEl.appendChild(bodyNode);
  okBtn.textContent = okText;
  cancelBtn.textContent = cancelText;
  cancelBtn.style.display = showCancel ? '' : 'none';
  overlay.classList.remove('modal-hidden');
  return new Promise((resolve)=>{ _modalResolve = resolve; });
}

function closeModal(result){
  const overlay = document.getElementById('modalOverlay');
  if(overlay) overlay.classList.add('modal-hidden');
  try{ if(_modalResolve) _modalResolve(result); }finally{ _modalResolve = null; }
}

async function showEditModal(oldText){
  const wrap = document.createElement('div');
  const p = document.createElement('p'); p.textContent = 'Edit your message:'; wrap.appendChild(p);
  const ta = document.createElement('textarea'); ta.value = oldText || ''; ta.style.width = '100%'; ta.style.minHeight = '120px';
  wrap.appendChild(ta);
  const ok = await openModal({ title:'Edit message', bodyNode: wrap, okText:'Save', cancelText:'Cancel', showCancel:true });
  if(!ok) return null;
  const val = (ta.value||'').trim();
  return val.length ? val : null;
}

async function showConfirmModal(text){
  const wrap = document.createElement('div');
  const p = document.createElement('p'); p.textContent = text || 'Confirm?'; wrap.appendChild(p);
  const ok = await openModal({ title:'Confirm', bodyNode: wrap, okText:'Yes', cancelText:'No', showCancel:true });
  return !!ok;
}

async function editMessageById(msgId){
  if(!currentRoom) return;
  // Find message in loadedMessages or storage
  const loc = await findMessageLocation(msgId);
  if(!loc) { log('Message not found','WARN'); return; }
  const orig = loc.msg;

  const userId = session?.userId || localGuest.userId;
  if(orig.userId !== userId){ log('You can only edit your own messages','WARN'); return; }

  const newText = await showEditModal(orig.text || '');
  if(!newText) return; // canceled or empty
  const trimmed = String(newText).trim();

  // Load the cell array if we don't have it
  let cellArr = loc.cellArr;
  let cellSha = loc.cellSha;
  if(!cellArr){
    const got = await ghGetJsonWithSha(cellPath(currentRoom, loc.cell));
    if(!got.ok || !Array.isArray(got.obj)){ showToast('Failed to read cell for edit', 'error'); return; }
    cellArr = got.obj;
    cellSha = got.sha;
  }

  // Find message inside cellArr
  const idx = cellArr.findIndex(x => x && x.id === msgId);
  if(idx === -1){ showToast('Message not found in storage', 'error'); return; }

  // Update fields
  cellArr[idx].text = trimmed;
  cellArr[idx].edited = true;
  cellArr[idx].editedAt = Date.now();
  cellArr[idx].editedBy = userId;

  // PUT back
  try{
    const put = await ghPutJson(cellPath(currentRoom, loc.cell), cellArr, cellSha, `edit msg ${msgId}`);
    // Update in-memory loadedMessages and DOM
    for(const m of loadedMessages){ if(m.id === msgId){ m.text = trimmed; m.edited = true; m.editedAt = cellArr[idx].editedAt; } }
    const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
    if(el){
      const textEl = el.querySelector('.text'); if(textEl) textEl.textContent = trimmed;
      const meta = el.querySelector('.meta'); if(meta){
        const d = new Date(cellArr[idx].ts||Date.now());
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        meta.textContent = `${hh}:${mm} ¬∑ ${cellArr[idx].sender} ¬∑ edited`;
      }
    }
    showToast('Message edited successfully', 'success');
  }catch(e){ console.error('[editMessage ERROR]', e); showToast('Edit failed: '+String(e), 'error'); }
}

async function deleteMessageById(msgId){
  if(!currentRoom) return;
  const loc = await findMessageLocation(msgId);
  if(!loc) { log('Message not found','WARN'); return; }
  const orig = loc.msg;
  const userId = session?.userId || localGuest.userId;
  if(orig.userId !== userId){ log('You can only delete your own messages','WARN'); return; }

  const ok = await showConfirmModal('Delete this message for everyone? This will mark it deleted.');
  if(!ok) return;

  let cellArr = loc.cellArr;
  let cellSha = loc.cellSha;
  if(!cellArr){
    const got = await ghGetJsonWithSha(cellPath(currentRoom, loc.cell));
    if(!got.ok || !Array.isArray(got.obj)){ showToast('Failed to read cell for delete', 'error'); return; }
    cellArr = got.obj;
    cellSha = got.sha;
  }

  const idx = cellArr.findIndex(x => x && x.id === msgId);
  if(idx === -1){ showToast('Message not found in storage', 'error'); return; }

  cellArr[idx].deleted = true;
  cellArr[idx].deletedAt = Date.now();
  cellArr[idx].deletedBy = userId;

  try{
    const put = await ghPutJson(cellPath(currentRoom, loc.cell), cellArr, cellSha, `delete msg ${msgId}`);
    // Update in-memory and DOM
    for(const m of loadedMessages){ if(m.id === msgId){ m.deleted = true; } }
    const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
    if(el){
      const textEl = el.querySelector('.text'); if(textEl) textEl.textContent = '[deleted]';
      const meta = el.querySelector('.meta'); if(meta){ meta.textContent = `deleted`; }
    }
    log('Message deleted','INFO');
    showToast('Message deleted successfully', 'success');
  }catch(e){ console.error('[deleteMessage ERROR]', e); log('Delete failed: '+String(e),'ERROR'); showToast('Delete failed: '+String(e), 'error'); }
}

/* ============================================================
   === PRESENCE ===
   ============================================================ */
const presenceState = {
  inRoom:false,
  isIdle:true,
  heartbeatTimer:null,
  lastOnlineWriteAt:0,
  lastPresenceWriteSha:null
};

async function presenceWrite(obj){
  if(!currentRoom) return;
  const p = presencePath(currentRoom, obj.userId);
  const got = await ghGetJsonWithSha(p);
  const sha = got.ok ? got.sha : null;
  await ghPutJson(p, obj, sha, "presence");
}

async function presenceSetOnline(online, reason=""){
  if(!currentRoom) return;

  const now = Date.now();
  const userId = session?.userId || localGuest.userId;
  const username = session?.username || localGuest.name || "Guest";

  const base = presenceCache.get(userId) || {
    v:1, room: currentRoom, userId, username,
    online:false,
    lastSeenAt: now,
    lastActiveAt: now,
    lastReadTs: 0,
    lastReadMsgId: null,
    device: { ua: navigator.userAgent, platform: navigator.platform || "" }
  };

  if(online){
    base.online = true;
    base.lastActiveAt = now;
    base.lastSeenAt = now;
    presenceState.isIdle = false;

    // Start heartbeat if not running
    if(!presenceState.heartbeatTimer){
      presenceState.heartbeatTimer = setInterval(async ()=>{
        if(!running || !currentRoom) return;
        if(!isActiveNow()){
          // Stop on idle
          await presenceSetOnline(false, "idle-heartbeat");
          return;
        }
        await presenceSetOnline(true, "heartbeat");
      }, PRESENCE_ACTIVE_HEARTBEAT_MS);
    }
  }else{
    base.online = false;
    base.lastSeenAt = now;
    presenceState.isIdle = true;

    // Stop heartbeat
    if(presenceState.heartbeatTimer){
      clearInterval(presenceState.heartbeatTimer);
      presenceState.heartbeatTimer = null;
    }
  }

  // Throttle "online/offline" writes so we don't spam
  if(now - presenceState.lastOnlineWriteAt < 700 && reason!=="heartbeat") return;
  presenceState.lastOnlineWriteAt = now;

  presenceCache.set(userId, base);
  await presenceWrite(base);
}

async function refreshPresence(){
  if(!currentRoom) return;

  const dir = await ghListDir(`${ROOMS_META_DIR}/${currentRoom}/presence`);
  if(!dir.ok) return;

  // Pull each presence file (small)
  const now = Date.now();
  const next = new Map();

  for(const it of dir.items){
    if(it.type!=="file" || !it.name.endsWith(".json")) continue;
    const got = await ghGetJsonWithSha(`${ROOMS_META_DIR}/${currentRoom}/presence/${it.name}`);
    if(got.ok && got.obj && got.obj.userId){
      next.set(got.obj.userId, got.obj);
    }
  }

  presenceCache = next;
  lastPresenceRefreshAt = now;
  renderPresenceSummary();
  updateReadBadges();
}

async function maybeRefreshPresence(){
  const now = Date.now();
  if(now - lastPresenceRefreshAt < 10_000) return; // at most every 10s active
  await refreshPresence();
}

function renderPresenceSummary(){
  if(!currentRoom) return;
  const now = Date.now();
  let active=0, recent=0;
  for(const p of presenceCache.values()){
    const lastActiveAt = p.lastActiveAt||0;
    const lastSeenAt = p.lastSeenAt||0;
    if(now - lastActiveAt < 10_000) active++;
    else if(now - lastSeenAt < PRESENCE_RECENT_MS) recent++;
  }
  presenceText.textContent = `presence: ${active} active ¬∑ ${recent} recent`;
}

/* ============================================================
   === READ RECEIPTS ===
   ============================================================ */
let readObserver = null;
let readHoldTimers = new Map(); // msgId -> timer

function setupReadObserver(){
  if(!messagesEl) return;
  if(readObserver){
    readObserver.disconnect();
    // Clear pending timers
    for(const timer of readHoldTimers.values()){
      clearTimeout(timer);
    }
    readHoldTimers.clear();
    readObserver = null;
  }

  readObserver = new IntersectionObserver((entries)=>{
    for(const ent of entries){
      const node = ent.target;
      const msgId = node.dataset.msgId;
      const ts = Number(node.dataset.ts||0);
      
      // ========================================
      // AUDIO READ RECEIPT: Skip automatic read tracking for audio messages
      // Audio messages require explicit user interaction (download + play)
      // to be marked as "listened". This prevents marking audio as "read"
      // when user just scrolls past it without actually listening.
      // ========================================
      const isAudioMsg = node.querySelector('.msg-audio');
      if(isAudioMsg){
        continue;
      }

      // Only consider if visible enough
      if(ent.intersectionRatio < 0.60){
        // cancel pending
        if(readHoldTimers.has(msgId)){
          clearTimeout(readHoldTimers.get(msgId));
          readHoldTimers.delete(msgId);
        }
        continue;
      }

      // If fast scrolling, ignore
      if(Date.now() < window._chat_fastScrollingUntil) continue;

      // Hold 250ms visible
      if(readHoldTimers.has(msgId)) continue;

      const t = setTimeout(async ()=>{
        readHoldTimers.delete(msgId);
        // Re-check visibility by bounding box within container
        if(Date.now() < window._chat_fastScrollingUntil) return;

        // Zone weighting (TOP/CENTER/BOTTOM) ‚Äì we only store monotonic lastReadTs
        const rect = node.getBoundingClientRect();
        const rootRect = messagesEl.getBoundingClientRect();
        const centerY = rect.top + rect.height/2;
        const rel = (centerY - rootRect.top) / Math.max(1, rootRect.height);
        // Zones: [0..0.33]=TOP, (0.33..0.66]=CENTER, (0.66..1]=BOTTOM
        const zone = (rel <= 0.33) ? "TOP" : (rel <= 0.66 ? "CENTER" : "BOTTOM");

        await markRead(ts, msgId, zone);
      }, 250);

      readHoldTimers.set(msgId, t);
    }
  }, { root: messagesEl, threshold: [0,0.6,1] });

  // Observe existing nodes
  for(const node of messagesEl.querySelectorAll(".msg")){
    readObserver.observe(node);
  }
}

async function markRead(ts, msgId, zone){
  if(!currentRoom) return;

  // If user is reading old messages (scrolled up), we still only store monotonic lastReadTs
  const userId = session?.userId || localGuest.userId;

  const p = presenceCache.get(userId);
  if(!p) return;

  const prev = p.lastReadTs || 0;
  const next = Math.max(prev, ts);

  if(next === prev) return; // no change

  p.lastReadTs = next;
  p.lastReadMsgId = msgId;
  p.lastSeenAt = Date.now();
  if(zone !== "TOP") p.lastActiveAt = Date.now(); // center/bottom implies more "engaged"

  presenceCache.set(userId, p);

  // Throttle writes
  const now = Date.now();
  if(now - lastReadWriteAt < 1500) return;
  lastReadWriteAt = now;

  await presenceWrite(p);
  updateReadBadges();
}

/* ============================================================
   AUDIO READ RECEIPTS: markAudioAsListened()
   
   Tracks when users actually PLAY audio messages (not just see them).
   This function is called when user clicks play button on an audio message.
   
   What it does:
   1. Checks if user already listened (prevents duplicates)
   2. Adds {userId, username, listenedAt} to message.listenedBy array
   3. Updates message in GitHub cell with listened status
   4. Marks message as "read" in presence tracking
   5. Updates UI badges to show "listened by" count
   
   GitHub Storage:
   - listenedBy array saved to: rooms-cells/<room>/cells/cell-NNNNNN.json
   - Synced across all devices via poll loop
   - Sender can see who listened to their audio messages
   ============================================================ */
async function markAudioAsListened(msgId){
  if(!currentRoom) return;
  
  const userId = session?.userId || localGuest.userId;
  const username = session?.username || localGuest.name || "Guest";
  
  // Find the message in loadedMessages array
  const msg = loadedMessages.find(m => m.id === msgId);
  if(!msg || msg.type !== 'audio') return;
  
  // Prevent duplicate entries - check if this user already listened
  if(!msg.listenedBy) msg.listenedBy = [];
  const alreadyListened = msg.listenedBy.some(l => l.userId === userId);
  if(alreadyListened) return;
  
  // Create listened entry with user info and timestamp
  const listenEntry = {
    userId,
    username,
    listenedAt: Date.now()
  };
  msg.listenedBy.push(listenEntry);
  
  log(`üéß Marked audio as listened: ${msgId}`, 'INFO');
  
  // ========================================
  // Save listened status to GitHub for cross-device sync
  // This updates the message in the cell JSON file
  // ========================================
  try{
    const cellNum = msg.cell;
    if(!cellNum){
      console.warn('No cell number for message:', msgId);
      return;
    }
    
    const got = await ghGetJsonWithSha(cellPath(currentRoom, cellNum));
    if(!got.ok || !Array.isArray(got.obj)){
      console.error('Failed to load cell for audio listened update');
      return;
    }
    
    const cellArr = got.obj;
    const idx = cellArr.findIndex(m => m.id === msgId);
    if(idx === -1){
      console.warn('Message not found in cell:', msgId);
      return;
    }
    
    // Update the message in the cell with listened entry
    if(!cellArr[idx].listenedBy) cellArr[idx].listenedBy = [];
    cellArr[idx].listenedBy.push(listenEntry);
    
    // Write updated cell back to GitHub with SHA for conflict resolution
    const put = await ghPutJson(cellPath(currentRoom, cellNum), cellArr, got.sha, `audio listened ${msgId}`);
    if(put && put.ok){
      log(`‚úì Audio listened status saved to GitHub`, 'INFO');
      
      // Also mark as read in presence (updates lastReadTs)
      // This ensures the message is considered "read" for badge calculations
      await markRead(msg.ts, msgId, 'CENTER');
      
      // Refresh UI to show "listened by" count
      updateReadBadges();
    }
  }catch(err){
    console.error('Error updating audio listened status:', err);
  }
}

function updateReadBadges(){
  // ========================================
  // READ RECEIPTS: Show "read by" for text, "listened by" for audio
  // 
  // Text messages: Use presence.lastReadTs (automatic when visible)
  // Audio messages: Use message.listenedBy array (only when played)
  // 
  // This dual system ensures:
  // - Text messages = seen = read (traditional)
  // - Audio messages = played = read (engagement-based)
  // ========================================
  const nodes = messagesEl.querySelectorAll(".msg");
  const selfId = session?.userId || localGuest.userId;
  
  for(const node of nodes){
    const ts = Number(node.dataset.ts||0);
    const msgId = node.dataset.msgId;
    const readsEl = node.querySelector(".reads");
    if(!readsEl) continue;
    
    // Check if this is an audio message
    const isAudioMsg = node.querySelector('.msg-audio');
    
    if(isAudioMsg){
      // ========================================
      // AUDIO READ RECEIPT: Use listenedBy array (not presence tracking)
      // Shows "listened by" instead of "read by"
      // Only counts users who actually played the audio
      // ========================================
      const msg = loadedMessages.find(m => m.id === msgId);
      if(msg && msg.listenedBy && msg.listenedBy.length > 0){
        const listeners = msg.listenedBy
          .filter(l => l.userId !== selfId)  // Exclude self from count
          .map(l => l.username || l.userId);
        
        if(listeners.length > 0){
          readsEl.textContent = `listened by: ${listeners.slice(0,3).join(", ")}${listeners.length>3?"‚Ä¶":""}`;
          
          // Update message status indicator to 'read' (‚úì‚úì)
          const statusEl = node.querySelector('.msg-status');
          if(statusEl){
            updateMessageStatus(msgId, 'read');
          }
        }else{
          readsEl.textContent = "";
        }
      }else{
        readsEl.textContent = "";
      }
    }else{
      // ========================================
      // REGULAR MESSAGE READ RECEIPT: Use presence.lastReadTs
      // Traditional read tracking - marks as read when visible
      // ========================================
      const readers = [];
      let hasOtherReaders = false;
      
      for(const p of presenceCache.values()){
        if(!p.userId) continue;
        if((p.lastReadTs||0) >= ts){
          // don't show self
          if(p.userId !== selfId){
            readers.push(p.username || p.userId);
              hasOtherReaders = true;
          }
        }
      }
      readsEl.textContent = readers.length ? `read by: ${readers.slice(0,3).join(", ")}${readers.length>3?"‚Ä¶":""}` : "";
      
      // Update own message status to 'read' if others have read it
      const statusEl = node.querySelector('.msg-status');
      if(statusEl && hasOtherReaders){
        const currentStatus = statusEl.className.match(/status-(\w+)/)?.[1];
        if(currentStatus && ['sent', 'delivered'].includes(currentStatus)){
          updateMessageStatus(msgId, 'read');
        }
      }
    }
  }
}

/* ============================================================
   SENDING + SYNC
   ============================================================ */
async function sendMessage(){
  if(!running || !currentRoom){
    showToast('Not connected to a room', 'warning');
    return;
  }
  
  // Prevent double sends
  if(sendBtn.disabled) return;
  sendBtn.disabled = true;

  const text = (msgInput.value||"").trim();
  if(!text) return;

  const now = Date.now();
  const userId = session?.userId || localGuest.userId;
  const sender = (nameInput.value||"").trim() || session?.username || localGuest.name || "Anon";

  // Detect mentions in message
  const mentions = detectMentions(text);

  // attach rich metadata for provenance
  const ip = null; // IP tracking disabled
  const device = `${navigator.platform || 'unknown'} - ${navigator.userAgent.slice(0,50)}`;
  const sessionType = session?.userId ? 'registered' : (String(localGuest.userId||'').startsWith('g-') ? 'guest' : 'anon');

  const msg = {
    id: `m-${now}-${Math.random().toString(36).slice(2,8)}`,
    room: currentRoom,
    sender,
    userId,
    ts: now,
    text,
    edited:false,
    editedAt:null,
    deleted:false,
    createdAt: now,
    status: 'sending', // New status field
    replyTo: replyingTo ? {
      msgId: replyingTo.msgId,
      sender: replyingTo.sender,
      text: replyingTo.text,
      userId: replyingTo.userId
    } : null,
    mentions: mentions,
    meta: {
      sessionType,
      sessionUsername: session?.username || null,
      device,
      ip,
      ua: navigator.userAgent || null
    }
  };

  // OPTIMISTIC UI: Show message immediately with "sending" status
  addMessageToDom(msg);
  msgInput.value = "";
  cancelReplyTo(); // Clear reply after sending
  markInteraction("send");

  // Send to GitHub (wait for confirmation before marking as sent)
  try{
    log(`üì§ Sending message to GitHub...`, "INFO");
    
    // This will throw an error if the write fails
    const result = await appendMessageV3(currentRoom, msg);
    
    // Only mark as sent if GitHub confirmed the write
    if(result && result.cellSha){
      msg.status = 'sent';
      updateMessageStatus(msg.id, 'sent');
      log(`‚úÖ Message successfully written to GitHub (cell ${result.cellNum})`, "INFO");
      
      // Enter burst mode: check frequently for quick back-and-forth
      burstModeUntil = Date.now() + POLL_BURST_DURATION;
      if(running && currentRoom){
        clearTimeout(pollTimer);
        scheduleNextPoll(POLL_MS_BURST);
      }
      
      // Presence update
      await presenceSetOnline(true, "send");
      
      // Refresh presence list occasionally
      await maybeRefreshPresence();
      
      // After a brief moment, update to delivered
      setTimeout(() => {
        msg.status = 'delivered';
        updateMessageStatus(msg.id, 'delivered');
      }, 500);
    }else{
      throw new Error("GitHub write returned no SHA (write may have failed)");
    }
    
  }catch(e){
    console.error('[sendMessage ERROR]', e);
    msg.status = 'failed';
    updateMessageStatus(msg.id, 'failed');
    log(`‚ùå Failed to write message to GitHub: ${e.message}`, "ERROR");
    showToast('Failed to send message to GitHub. Click retry to try again.', 'error', 6000);
  }finally{
    sendBtn.disabled = false;
  }
}

function updateMessageStatus(msgId, status){
  // Update in loadedMessages
  for(const m of loadedMessages){
    if(m.id === msgId){
      m.status = status;
      break;
    }
  }
  
  // Update DOM
  const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
  if(!el) return;
  
  const statusEl = el.querySelector('.msg-status');
  if(statusEl){
    statusEl.className = `msg-status status-${status}`;
  }
  
  // Handle failed state
  if(status === 'failed'){
    el.classList.add('msg-failed');
    // Add retry button if not exists
    if(!el.querySelector('.msg-retry')){
      const meta = el.querySelector('.meta');
      if(meta){
        const retry = document.createElement('button');
        retry.className = 'msg-retry';
        retry.textContent = 'Retry';
        const msg = loadedMessages.find(m => m.id === msgId);
        retry.onclick = (e) => { e.stopPropagation(); if(msg) retryMessage(msg); };
        meta.appendChild(retry);
      }
    }
  }else{
    el.classList.remove('msg-failed');
    const retry = el.querySelector('.msg-retry');
    if(retry) retry.remove();
  }
}

async function retryMessage(msg){
  if(!msg || !currentRoom) return;
  
  // Update status to sending
  updateMessageStatus(msg.id, 'sending');
  
  try{
    await appendMessageV3(currentRoom, msg);
    updateMessageStatus(msg.id, 'sent');
    showToast('Message sent successfully', 'success');
    
    setTimeout(() => {
      updateMessageStatus(msg.id, 'delivered');
    }, 500);
    
  }catch(e){
    console.error('[retryMessage ERROR]', e);
    updateMessageStatus(msg.id, 'failed');
    showToast('Retry failed. Please try again.', 'error');
  }
}

async function syncLatestFromStorage(){
  // Load newest messages - check last 3 cells to ensure completeness
  await loadRoomIndex(currentRoom);

  const latestCellNum = roomIndex.latestCell || 1;

  // If nothing loaded yet -> load latest
  if(loadedCellsMax === null){
    const msgs = await loadLatestMessages(currentRoom, 50);
    renderAll(msgs);
    updateReadBadges();
    return;
  }

  // CRITICAL: Check if user is behind by comparing their last loaded cell to actual latest
  // Always check the last 3 cells to catch any missed messages
  const safeCheckFrom = Math.max(1, latestCellNum - 2); // Check last 3 cells
  const needToCheck = loadedCellsMax < safeCheckFrom;
  
  if(needToCheck){
    // User is significantly behind - load ALL missing cells
    log(`üì¶ Loading missing cells ${loadedCellsMax+1} to ${latestCellNum}`, "INFO");
    const newMsgs = await loadCellsRange(currentRoom, loadedCellsMax+1, latestCellNum);
    loadedCellsMax = latestCellNum;
    
    // Filter out duplicates and add to DOM
    let addedCount = 0;
    const existingIds = new Set(loadedMessages.map(m => m.id));
    
    for(const m of newMsgs){
      if(existingIds.has(m.id)) continue;
      addMessageToDom(m, false);
      addedCount++;
    }
    
    if(addedCount > 0){
      log(`üì® ${addedCount} new message(s) received (loaded cells)`, "INFO");
      setupReadObserver();
    }
    
    // Update cell metadata after sync
    const totalCells1 = loadedCellsMax || (roomIndex?.latestCell || 0);
    const latestForMeta1 = roomIndex?.latestCell || totalCells1;
    const currentViewing1 = cellMetadata.currentViewingCell || latestForMeta1;
    updateCellMetadata(currentViewing1, totalCells1, latestForMeta1);
    
    // Detect visible cells after new messages load
    setTimeout(detectVisibleCells, 300);
    
    await maybeRefreshPresence();
    updateReadBadges();
    return;
  }

  // User is close to latest - check if there are new cells
  if(latestCellNum <= loadedCellsMax){
    // No new cells, but reload last 3 cells to ensure completeness
    // (in case messages were added to existing cells)
    const reloadFrom = Math.max(1, latestCellNum - 2);
    if(reloadFrom <= loadedCellsMax){
      log(`üîÑ Verifying last 3 cells (${reloadFrom} to ${latestCellNum})`, "INFO");
      const msgs = await loadCellsRange(currentRoom, reloadFrom, latestCellNum);
      
      // Add any messages we don't have yet
      let addedCount = 0;
      const existingIds = new Set(loadedMessages.map(m => m.id));
      
      for(const m of msgs){
        if(existingIds.has(m.id)) continue;
        addMessageToDom(m, false);
        addedCount++;
      }
      
      if(addedCount > 0){
        log(`üì® ${addedCount} message(s) found in verification`, "INFO");
        setupReadObserver();
      }
    }
    
    await maybeRefreshPresence();
    updateReadBadges();
    return;
  }

  // Load new cells from user's position to latest
  log(`üì• Loading new cells ${loadedCellsMax+1} to ${latestCellNum}`, "INFO");
  const newMsgs = await loadCellsRange(currentRoom, loadedCellsMax+1, latestCellNum);
  loadedCellsMax = latestCellNum;

  // Filter out duplicates and add to DOM
  let addedCount = 0;
  const existingIds = new Set(loadedMessages.map(m => m.id));
  
  for(const m of newMsgs){
    // Skip if already in DOM
    if(existingIds.has(m.id)) continue;
    
    addMessageToDom(m, false); // false = auto-scroll
    addedCount++;
  }
  
  if(addedCount > 0){
    log(`üì® ${addedCount} new message(s) received`, "INFO");
    setupReadObserver();
    
    // Check for new messages and mentions
    checkNewMessages(newMsgs);
  }
  
  // Update cell metadata after sync
  const totalCells2 = loadedCellsMax || (roomIndex?.latestCell || 0);
  const latestForMeta2 = roomIndex?.latestCell || totalCells2;
  const currentViewing2 = cellMetadata.currentViewingCell || latestForMeta2;
  updateCellMetadata(currentViewing2, totalCells2, latestForMeta2);
  
  // Detect visible cells after new messages load
  setTimeout(detectVisibleCells, 300);
  
  await maybeRefreshPresence();
  updateReadBadges();
}

/* ============================================================
   LOCAL GUEST IDENTITY (used if not logged in)
   ============================================================ */
const localGuest = {
  userId: null,
  name: "Guest"
};

function initGuestIdentity(){
  try{
    const k="cp2p_guest_v1";
    const raw = localStorage.getItem(k);
    if(raw){
      const obj = JSON.parse(raw);
      if(obj?.userId){
        localGuest.userId = obj.userId;
        localGuest.name = obj.name || "Guest";
        return;
      }
    }
    const now = Date.now();
    const rand = Math.random().toString(36).slice(2,10);
    localGuest.userId = `g-${now}-${rand}`;
    localGuest.name = "Guest";
    localStorage.setItem(k, JSON.stringify(localGuest));
  }catch(_){
    localGuest.userId = `g-${Date.now()}-${Math.random().toString(36).slice(2,10)}`;
  }
}

/* ============================================================
   UI: AUTH MODAL + ROOM JOIN/LEAVE
   ============================================================ */
let authMode = "login"; // "login" | "register"

function openAuth(mode){
  authMode = mode;
  authModalTitle.textContent = mode === "login" ? "Login" : "Register";
  authActionBtn.textContent  = mode === "login" ? "Login" : "Register";
  authMsg.textContent = "";
  authModalBack.style.display = "flex";
  authUserInput.focus();
}

function closeAuth(){
  authModalBack.style.display = "none";
  authUserInput.value = "";
  authPassInput.value = "";
  authMsg.textContent = "";
}

loginBtn.onclick = ()=>openAuth("login");
registerBtn.onclick = ()=>openAuth("register");
logoutBtn.onclick = ()=>logout();
browseRoomsBtn.onclick = ()=>openRoomBrowser();

authCloseBtn.onclick = closeAuth;
authModalBack.addEventListener("click", (e)=>{ if(e.target===authModalBack) closeAuth(); });

authActionBtn.onclick = async ()=>{
  try{
    authMsg.style.color = "var(--muted)";
    authMsg.textContent = "Working‚Ä¶";
    const u = authUserInput.value.trim();
    const p = authPassInput.value;

    if(authMode==="register"){
      await registerUser(u, p);
      authMsg.style.color = "rgba(34,197,94,.95)";
      authMsg.textContent = "Registered ‚úÖ";
      closeAuth();
    }else{
      await loginUser(u, p);
      authMsg.style.color = "rgba(34,197,94,.95)";
      authMsg.textContent = "Logged in ‚úÖ";
      closeAuth();
    }

    // If inside room, presence file path changes from guest->user. Write online once.
    if(running && currentRoom){
      await presenceSetOnline(true, "auth");
      await refreshPresence();
    }
  }catch(e){
    authMsg.style.color = "rgba(239,68,68,.95)";
    authMsg.textContent = String(e?.message || e);
  }
};

joinBtn.onclick = async ()=>{
  try{
    const r = roomInput.value.trim();
    if(!r){ log("Room required.","WARN"); return; }

    const displayName = nameInput.value.trim() || session?.username || "Anon";
    if(!nameInput.value.trim()) nameInput.value = displayName;

    currentRoom = r;
    running = true;

    // Save last joined room for logged-in users
    if(session && session.userId){
      saveLastJoinedRoom(r);
    }

    // Ensure storage (V3) + master file
    setNet("ok","joining‚Ä¶");
    await ensureRoomV3(currentRoom);

    // UI
    chatPanel.style.display = "flex";
    syncBtn.style.display = "inline-block";
    roomTitle.textContent = `#${currentRoom}`;
    roomSubText.textContent = `V3 Storage`;
    
    // Load cell metadata from cache
    loadCellMetadataFromCache();
    
    // Load last read timestamp for unread counter
    loadLastReadTimestamp();

    // Presence: join => online=true
    presenceState.inRoom = true;
    await presenceSetOnline(true, "join");

    // Load latest
    const msgs = await loadLatestMessages(currentRoom, 50);
    renderAll(msgs);

    // Lazy load + observers
    installLazyLoader();
    setupReadObserver();
    
    // Start live cell detection
    startCellDetection();
    
    // Update cell metadata with initial state
    const totalCells = loadedCellsMax || roomIndex?.latestCell || 0;
    const latestCell = roomIndex?.latestCell || totalCells;
    updateCellMetadata(latestCell, totalCells, latestCell);

    // Kick poll loop
    clearTimeout(pollTimer);
    scheduleNextPoll(50);

    // Pull presence list
    await refreshPresence();

    // Reset behavior tracking for new room
    resetBehaviorTracking();
    log(`üìä Behavior tracking initialized`, "INFO");

    log(`‚ú® Joined "${currentRoom}" as ${displayName}.`, "INFO");
  }catch(e){
    console.error("[Join ERROR]", e);
    setNet("bad","join error");
    log("Join failed. Check token / permissions / network.","ERROR");
  }
};

leaveBtn.onclick = async ()=>{
  try{
    if(!running) return;

    // Show final engagement summary before leaving
    const finalEngagement = getEngagementScore();
    log(`üìä Final Engagement: ${finalEngagement.sentiment} (${finalEngagement.score.toFixed(1)})`, "INFO");
    showToast(`Session ended: ${finalEngagement.sentiment} engagement`, 'info');

    // Presence offline once
    await presenceSetOnline(false, "leave");
    presenceState.inRoom = false;

    running = false;
    currentRoom = null;
    clearTimeout(pollTimer);
    pollTimer = null;

    if(presenceState.heartbeatTimer){
      clearInterval(presenceState.heartbeatTimer);
      presenceState.heartbeatTimer = null;
    }

    chatPanel.style.display = "none";
    syncBtn.style.display = "none";
    clearView();
    
    // Reset behavior tracking
    resetBehaviorTracking();
    
    log("Left room.","INFO");
  }catch(e){
    console.error("[Leave ERROR]", e);
  }
};

syncBtn.onclick = async ()=>{
  if(!running || !currentRoom){
    showToast('Not in a room', 'warning');
    return;
  }
  try{
    syncBtn.disabled = true;
    syncBtn.textContent = 'üîÑ Syncing...';
    
    // Use the unified refresh function
    await triggerManualRefresh("sync-button");
    
  }catch(e){
    console.error('[Manual Sync ERROR]', e);
    showToast('Sync failed: ' + e.message, 'error');
  }finally{
    syncBtn.disabled = false;
    syncBtn.textContent = 'üîÑ Check Messages';
  }
};

/* ============================================================
   AUDIO RECORDING WITH GITHUB STORAGE
   ============================================================ */
let mediaRecorder = null;
let audioChunks = [];
let audioStream = null;
let recordingStartTime = 0;
let recordingInterval = null;
let audioPaused = false;
let pausedDuration = 0;
let lastPauseTime = 0;
let visualizerInterval = null;
let audioContext = null;
let analyser = null;
let dataArray = null;
let bufferLength = 0;
let recordedBlob = null;
let isRecordingLocked = false;
let recordingStartPos = { x: 0, y: 0 };
let isMobileGestureRecording = false;
let animationFrameId = null;

// Initialize visualizer bars
function initVisualizer(){
  audioVisualizer.innerHTML = '';
  const barCount = 40;
  for(let i = 0; i < barCount; i++){
    const bar = document.createElement('div');
    bar.className = 'audio-bar';
    bar.style.height = '4px';
    audioVisualizer.appendChild(bar);
  }
}

// Update visualizer with real audio data
function updateVisualizer(){
  if(!analyser || audioPaused) return;
  
  // Get frequency data
  analyser.getByteFrequencyData(dataArray);
  
  const bars = audioVisualizer.querySelectorAll('.audio-bar');
  const barCount = bars.length;
  
  // Calculate how many data points per bar
  const step = Math.floor(bufferLength / barCount);
  
  bars.forEach((bar, index) => {
    // Get average amplitude for this bar's range
    let sum = 0;
    const start = index * step;
    const end = start + step;
    
    for(let i = start; i < end && i < bufferLength; i++){
      sum += dataArray[i];
    }
    
    const average = sum / step;
    
    // Normalize to 0-1 range (dataArray values are 0-255)
    const normalized = average / 255;
    
    // Map to height (minimum 4px, maximum 70px)
    const height = 4 + (normalized * 66);
    bar.style.height = height + 'px';
  });
  
  // Continue animation
  animationFrameId = requestAnimationFrame(updateVisualizer);
}

// Stop visualizer animation
function stopVisualizerAnimation(){
  if(animationFrameId){
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  const bars = audioVisualizer.querySelectorAll('.audio-bar');
  bars.forEach(bar => bar.style.height = '4px');
}

// Update recording timer
function updateTimer(){
  if(audioPaused) return;
  const elapsed = Date.now() - recordingStartTime - pausedDuration;
  const seconds = Math.floor(elapsed / 1000);
  const minutes = Math.floor(seconds / 60);
  const secs = seconds % 60;
  audioTimer.textContent = `${minutes}:${secs.toString().padStart(2, '0')}`;
}

// Upload audio file to GitHub
// isRecorded: true for recorded audio, false for uploaded audio files
async function uploadAudioToGitHub(blob, messageId, roomName, isRecorded = true){
  try{
    const userId = session?.userId || localGuest.userId || 'anon';
    const timestamp = Date.now();
    
    // Determine file extension from blob type
    let ext = 'webm';
    if(blob.type.includes('mp3')) ext = 'mp3';
    else if(blob.type.includes('mp4')) ext = 'mp4';
    else if(blob.type.includes('ogg')) ext = 'ogg';
    else if(blob.type.includes('wav')) ext = 'wav';
    
    // Organize by type: recorded-audios vs media-audios
    const folderType = isRecorded ? 'recorded-audios' : 'media-audios';
    
    // File naming: user_timestamp_msgid.ext
    const fileName = `${userId}_${timestamp}_${messageId}.${ext}`;
    const audioPath = `${ROOMS_META_DIR}/${roomName}/${folderType}/${fileName}`;
    
    // ========================================
    // RESOURCE TRACKING: Start upload tracking
    // ========================================
    startUploadTracking(fileName, blob.size);
    
    // Convert blob to base64
    const reader = new FileReader();
    const base64Promise = new Promise((resolve, reject) => {
      reader.onloadend = () => {
        // Update progress to 50% (encoding complete)
        updateUploadProgress(blob.size * 0.5);
        resolve(reader.result.split(',')[1]);
      };
      reader.onerror = reject;
    });
    reader.readAsDataURL(blob);
    const base64Content = await base64Promise;
    
    // Update progress to 75% (starting upload)
    updateUploadProgress(blob.size * 0.75);
    
    // Upload to GitHub
    const commitMsg = isRecorded 
      ? `Upload recorded audio from ${userId}` 
      : `Upload media audio from ${userId}`;
    const result = await ghPutFile(audioPath, base64Content, null, commitMsg);
    
    if(result.ok){
      log(`üéµ Audio uploaded to GitHub: ${audioPath}`, 'INFO');
      
      // ========================================
      // RESOURCE TRACKING: Complete upload
      // ========================================
      completeUploadTracking(true);
      
      return { 
        ok: true, 
        path: audioPath, 
        url: result.url,
        fileName: fileName,
        folderType: folderType
      };
    }else{
      completeUploadTracking(false);
      throw new Error(`Upload failed with status ${result.status}`);
    }
  }catch(error){
    console.error('Error uploading audio:', error);
    completeUploadTracking(false);
    return { ok: false, error: error.message };
  }
}

// Download audio from GitHub
async function downloadAudioFromGitHub(audioPath){
  try{
    const response = await rawGetBinary(audioPath);
    if(response.ok){
      return response.blob;
    }else{
      throw new Error(`Download failed with status ${response.status}`);
    }
  }catch(error){
    console.error('Error downloading audio:', error);
    return null;
  }
}

// Get cached audio or download if not cached
async function getCachedAudio(audioPath){
  // Check cache first
  const cached = audioCache.get(audioPath);
  if(cached){
    const age = Date.now() - cached.cachedAt;
    if(age < AUDIO_CACHE_MAX_AGE){
      log(`üéµ Using cached audio: ${audioPath}`, 'INFO');
      return cached;
    }else{
      // Cache expired, clean up
      if(cached.blobUrl) URL.revokeObjectURL(cached.blobUrl);
      audioCache.delete(audioPath);
    }
  }
  
  // Download audio
  log(`üì• Downloading audio: ${audioPath}`, 'INFO');
  const blob = await downloadAudioFromGitHub(audioPath);
  if(!blob) return null;
  
  // Create blob URL and cache
  const blobUrl = URL.createObjectURL(blob);
  const cacheEntry = {
    blob,
    blobUrl,
    size: blob.size,
    cachedAt: Date.now()
  };
  audioCache.set(audioPath, cacheEntry);
  
  log(`‚úÖ Audio cached: ${audioPath} (${formatBytes(blob.size)})`, 'INFO');
  return cacheEntry;
}

// Format bytes to human readable size
function formatBytes(bytes, decimals = 2){
  if(bytes === 0) return '0 B';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

// Format duration in seconds to MM:SS
function formatDuration(seconds){
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/* ============================================================
   RESOURCE TRACKING SYSTEM - Network Usage Monitor
   ============================================================ */

// Initialize resource monitor
function initResourceMonitor(){
  resourceMonitorEl = document.getElementById('resourceMonitor');
  resourceDownloadedEl = document.getElementById('resourceDownloaded');
  resourceUploadedEl = document.getElementById('resourceUploaded');
  resourceTotalEl = document.getElementById('resourceTotal');
  resourceProgressContainer = document.getElementById('resourceProgressContainer');
  resourceProgressBar = document.getElementById('resourceProgressBar');
  resourceStatusEl = document.getElementById('resourceStatus');
  
  updateResourceDisplay();
}

// Track downloaded data
function trackDownload(bytes, label = 'Data'){
  resourceStats.downloaded += bytes;
  log(`üì• Downloaded: ${label} (${formatBytes(bytes)})`, 'INFO');
  updateResourceDisplay();
}

// Track uploaded data
function trackUpload(bytes, label = 'Data'){
  resourceStats.uploaded += bytes;
  log(`üì§ Uploaded: ${label} (${formatBytes(bytes)})`, 'INFO');
  updateResourceDisplay();
}

// Start tracking upload progress (for audio files)
function startUploadTracking(name, totalSize){
  resourceStats.currentUpload = {
    name,
    size: totalSize,
    loaded: 0,
    startTime: Date.now()
  };
  
  // Show progress UI
  resourceProgressContainer.style.display = 'block';
  resourceMonitorEl.classList.add('uploading');
  resourceProgressBar.style.width = '0%';
  resourceStatusEl.textContent = `Uploading ${name}...`;
  resourceStatusEl.className = 'resource-status';
  
  updateResourceDisplay();
}

// Update upload progress
function updateUploadProgress(loaded){
  if(!resourceStats.currentUpload) return;
  
  resourceStats.currentUpload.loaded = loaded;
  const percent = Math.round((loaded / resourceStats.currentUpload.size) * 100);
  
  resourceProgressBar.style.width = `${percent}%`;
  resourceStatusEl.textContent = `Uploading... ${percent}% (${formatBytes(loaded)} / ${formatBytes(resourceStats.currentUpload.size)})`;
  
  updateResourceDisplay();
}

// Complete upload tracking
function completeUploadTracking(success = true){
  if(!resourceStats.currentUpload) return;
  
  const upload = resourceStats.currentUpload;
  const duration = ((Date.now() - upload.startTime) / 1000).toFixed(1);
  
  if(success){
    trackUpload(upload.size, upload.name);
    resourceProgressBar.style.width = '100%';
    resourceStatusEl.textContent = `‚úì ${upload.name} uploaded in ${duration}s`;
    resourceStatusEl.className = 'resource-status success';
    
    log(`‚úÖ Upload complete: ${upload.name} (${formatBytes(upload.size)} in ${duration}s)`, 'INFO');
  }else{
    resourceProgressBar.style.width = '0%';
    resourceStatusEl.textContent = `‚úï Upload failed: ${upload.name}`;
    resourceStatusEl.className = 'resource-status error';
    
    log(`‚ùå Upload failed: ${upload.name}`, 'ERROR');
  }
  
  // Hide progress after 3 seconds
  setTimeout(() => {
    resourceProgressContainer.style.display = 'none';
    resourceMonitorEl.classList.remove('uploading');
    resourceStats.currentUpload = null;
  }, 3000);
}

// Update resource display
function updateResourceDisplay(){
  if(!resourceDownloadedEl) return;
  
  const downloaded = formatBytes(resourceStats.downloaded);
  const uploaded = formatBytes(resourceStats.uploaded);
  const total = formatBytes(resourceStats.downloaded + resourceStats.uploaded);
  
  resourceDownloadedEl.textContent = downloaded;
  resourceUploadedEl.textContent = uploaded;
  resourceTotalEl.textContent = total;
  
  // Add uploading class to uploaded value if currently uploading
  if(resourceStats.currentUpload){
    resourceUploadedEl.classList.add('uploading');
  }else{
    resourceUploadedEl.classList.remove('uploading');
  }
}

// Helper to get binary from GitHub raw
async function rawGetBinary(path){
  try{
    const url = `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${path}`;
    const response = await fetch(url);
    if(response.ok){
      const blob = await response.blob();
      
      // Track download
      trackDownload(blob.size, path.split('/').pop());
      
      return { ok: true, blob, status: response.status };
    }else{
      return { ok: false, status: response.status };
    }
  }catch(error){
    return { ok: false, error: error.message };
  }
}

// Start recording
async function startAudioRecording(){
  // Prevent multiple recordings
  if(mediaRecorder && mediaRecorder.state !== 'inactive'){
    showToast('Recording already in progress', 'warning');
    return;
  }
  
  try{
    // Request microphone permission
    audioStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      } 
    });
    
    // Setup MediaRecorder
    const options = { mimeType: 'audio/webm;codecs=opus' };
    if(!MediaRecorder.isTypeSupported(options.mimeType)){
      options.mimeType = 'audio/webm';
      if(!MediaRecorder.isTypeSupported(options.mimeType)){
        options.mimeType = 'audio/mp4';
      }
    }
    
    mediaRecorder = new MediaRecorder(audioStream, options);
    audioChunks = [];
    
    mediaRecorder.ondataavailable = (e) => {
      if(e.data.size > 0){
        audioChunks.push(e.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      recordedBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
      stopVisualizerAnimation();
      
      // If mobile gesture and not locked, send immediately
      if(isMobileGestureRecording && !isRecordingLocked){
        setTimeout(() => sendAudioMessage(), 300);
      }else{
        showAudioPreview();
      }
    };
    
    // Setup Web Audio API for real-time visualization
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioContext.createMediaStreamSource(audioStream);
    analyser = audioContext.createAnalyser();
    
    // Configure analyser
    analyser.fftSize = 256; // Higher = more detail, lower = better performance
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    
    // Connect source to analyser (don't connect to destination to avoid feedback)
    source.connect(analyser);
    
    // Start recording
    mediaRecorder.start(100); // Collect data every 100ms
    recordingStartTime = Date.now();
    pausedDuration = 0;
    audioPaused = false;
    
    // Show modal or overlay based on mode
    if(isMobileGestureRecording){
      recordingOverlay.classList.add('active');
    }else{
      audioModal.classList.add('active');
    }
    
    audioRecordBtn.classList.add('recording');
    
    // Initialize visualizer
    initVisualizer();
    
    // Start timer and real-time visualizer
    recordingInterval = setInterval(updateTimer, 100);
    updateVisualizer(); // Start animation loop
    
    // Show initial time
    audioTimer.textContent = '0:00';
    audioStopBtn.style.display = 'block';
    audioPauseBtn.style.display = 'block';
    audioSendBtn.style.display = 'none';
    
    log('üé§ Audio recording started', 'INFO');
    
  }catch(error){
    console.error('Error starting audio recording:', error);
    showToast('Could not access microphone: ' + error.message, 'error');
    stopAudioRecording();
  }
}

// Pause/Resume recording
function togglePauseRecording(){
  if(!mediaRecorder || mediaRecorder.state === 'inactive') return;
  
  if(audioPaused){
    // Resume
    mediaRecorder.resume();
    pausedDuration += Date.now() - lastPauseTime;
    audioPaused = false;
    audioPauseBtn.innerHTML = '‚è∏Ô∏è Pause';
    audioPauseBtn.classList.remove('record');
    audioPauseBtn.classList.add('pause');
    log('üé§ Recording resumed', 'INFO');
  }else{
    // Pause
    mediaRecorder.pause();
    lastPauseTime = Date.now();
    audioPaused = true;
    audioPauseBtn.innerHTML = '‚ñ∂Ô∏è Resume';
    audioPauseBtn.classList.remove('pause');
    audioPauseBtn.classList.add('record');
    log('‚è∏Ô∏è Recording paused', 'INFO');
  }
}

// Stop recording
function stopAudioRecording(){
  if(mediaRecorder && mediaRecorder.state !== 'inactive'){
    mediaRecorder.stop();
  }
  
  if(audioStream){
    audioStream.getTracks().forEach(track => track.stop());
    audioStream = null;
  }
  
  // Cleanup Web Audio API
  if(audioContext){
    audioContext.close().catch(e => console.warn('Error closing audio context:', e));
    audioContext = null;
  }
  analyser = null;
  dataArray = null;
  
  clearInterval(recordingInterval);
  stopVisualizerAnimation();
  
  audioRecordBtn.classList.remove('recording');
  recordingOverlay.classList.remove('active');
  gestureHint.classList.remove('active');
  isRecordingLocked = false;
  isMobileGestureRecording = false;
}

// Cancel recording
function cancelAudioRecording(){
  stopAudioRecording();
  recordedBlob = null;
  audioChunks = [];
  closeAudioModal();
  log('‚ùå Recording cancelled', 'INFO');
}

// Show preview with play button
function showAudioPreview(){
  audioModal.classList.add('active');
  recordingOverlay.classList.remove('active');
  gestureHint.classList.remove('active');
  
  audioStopBtn.style.display = 'none';
  audioPauseBtn.style.display = 'none';
  audioSendBtn.style.display = 'block';
  
  // Create preview audio element
  const previewContainer = document.createElement('div');
  previewContainer.style.cssText = 'display:flex; align-items:center; justify-content:center; gap:15px; width:100%;';
  
  const playBtn = document.createElement('button');
  playBtn.id = 'previewPlayBtn';
  playBtn.style.cssText = `
    background:linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    border:none;
    color:#fff;
    width:60px;
    height:60px;
    border-radius:50%;
    font-size:24px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:all .2s ease;
  `;
  playBtn.innerHTML = '‚ñ∂Ô∏è';
  
  const previewText = document.createElement('div');
  previewText.style.cssText = 'flex:1; text-align:center; color:var(--muted);';
  previewText.textContent = 'Click to preview audio';
  
  // Create hidden audio element
  const audioEl = document.createElement('audio');
  audioEl.id = 'previewAudio';
  if(recordedBlob){
    const audioUrl = URL.createObjectURL(recordedBlob);
    audioEl.src = audioUrl;
    audioEl.preload = 'auto';
    
    console.log('Preview audio created:', {
      blobSize: recordedBlob.size,
      blobType: recordedBlob.type,
      url: audioUrl
    });
  }
  
  playBtn.onclick = () => {
    if(!audioEl.src){
      showToast('No audio to preview', 'error');
      return;
    }
    
    if(audioEl.paused){
      audioEl.play().then(() => {
        playBtn.innerHTML = '‚è∏Ô∏è';
        previewText.textContent = 'Playing...';
        log('üéµ Playing preview', 'INFO');
      }).catch(e => {
        console.error('Error playing preview:', e);
        showToast('Could not play preview: ' + e.message, 'error');
      });
    }else{
      audioEl.pause();
      playBtn.innerHTML = '‚ñ∂Ô∏è';
      previewText.textContent = 'Click to preview audio';
    }
  };
  
  audioEl.onended = () => {
    playBtn.innerHTML = '‚ñ∂Ô∏è';
    previewText.textContent = 'Click to preview audio';
  };
  
  previewContainer.appendChild(playBtn);
  previewContainer.appendChild(previewText);
  
  audioVisualizer.innerHTML = '';
  audioVisualizer.appendChild(previewContainer);
  audioVisualizer.appendChild(audioEl);
  
  log('üéß Audio preview ready', 'INFO');
}

// Send audio message
async function sendAudioMessage(){
  if(!recordedBlob || !running || !currentRoom) return;
  
  try{
    const now = Date.now();
    const userId = session?.userId || localGuest.userId;
    const sender = (nameInput.value||"").trim() || session?.username || localGuest.name || "Anon";
    
    // Calculate audio duration
    const audioDuration = (Date.now() - recordingStartTime - pausedDuration) / 1000;
    
    const messageId = `m-${now}-${Math.random().toString(36).slice(2,8)}`;
    
    const ip = null;
    const device = `${navigator.platform || 'unknown'} - ${navigator.userAgent.slice(0,50)}`;
    const sessionType = session?.userId ? 'registered' : (String(localGuest.userId||'').startsWith('g-') ? 'guest' : 'anon');
    
    // Upload audio to GitHub first (isRecorded = true)
    log('üì§ Uploading recorded audio to GitHub...', 'INFO');
    const uploadResult = await uploadAudioToGitHub(recordedBlob, messageId, currentRoom, true);
    
    if(!uploadResult.ok){
      throw new Error('Failed to upload audio: ' + uploadResult.error);
    }
    
    const msg = {
      id: messageId,
      room: currentRoom,
      sender,
      userId,
      ts: now,
      text: 'üé§ Voice message',
      type: 'audio',
      audioPath: uploadResult.path,
      audioFileName: uploadResult.fileName,
      audioFolderType: uploadResult.folderType,
      audioDuration: audioDuration,
      audioMimeType: recordedBlob.type,
      audioSize: recordedBlob.size,
      listenedBy: [], // AUDIO READ RECEIPT: Initialize empty array - will be populated when users play the audio
      edited: false,
      editedAt: null,
      deleted: false,
      createdAt: now,
      status: 'sending',
      replyTo: replyingTo ? {
        msgId: replyingTo.msgId,
        sender: replyingTo.sender,
        text: replyingTo.text,
        userId: replyingTo.userId
      } : null,
      meta: {
        sessionType,
        sessionUsername: session?.username || null,
        device,
        ip,
        ua: navigator.userAgent || null
      }
    };
    
    // Show in UI immediately
    addMessageToDom(msg);
    closeAudioModal();
    cancelReplyTo();
    markInteraction("send");
    
    // Send message metadata to GitHub
    try{
      log(`üì§ Sending audio message metadata to GitHub...`, "INFO");
      const result = await appendMessageV3(currentRoom, msg);
      
      if(result && result.cellSha){
        msg.status = 'sent';
        updateMessageStatus(msg.id, 'sent');
        log(`‚úÖ Audio message sent (cell ${result.cellNum})`, "INFO");
        
        // Enter burst mode
        burstModeUntil = Date.now() + POLL_BURST_DURATION;
        if(running && currentRoom){
          clearTimeout(pollTimer);
          scheduleNextPoll(POLL_MS_BURST);
        }
        
        await presenceSetOnline(true, "send");
        await maybeRefreshPresence();
        
        setTimeout(() => {
          msg.status = 'delivered';
          updateMessageStatus(msg.id, 'delivered');
        }, 500);
      }else{
        throw new Error("GitHub write returned no SHA");
      }
    }catch(e){
      console.error('[sendAudioMessage ERROR]', e);
      msg.status = 'failed';
      updateMessageStatus(msg.id, 'failed');
      log(`‚ùå Failed to send audio: ${e.message}`, "ERROR");
      showToast('Failed to send audio message', 'error');
    }
    
  }catch(error){
    console.error('Error sending audio:', error);
    showToast('Failed to send audio message: ' + error.message, 'error');
    closeAudioModal();
  }
}

// Close audio modal
function closeAudioModal(){
  audioModal.classList.remove('active');
  recordingOverlay.classList.remove('active');
  gestureHint.classList.remove('active');
  stopAudioRecording();
  recordedBlob = null;
  audioChunks = [];
  isRecordingLocked = false;
  isMobileGestureRecording = false;
  
  // Clean up audio preview
  const previewAudio = audioModal.querySelector('audio');
  if(previewAudio){
    previewAudio.pause();
    previewAudio.src = '';
    previewAudio.load();
  }
}

// Event listeners
audioRecordBtn.onclick = () => {
  if(!running || !currentRoom){
    showToast('Join a room first', 'warning');
    return;
  }
  startAudioRecording();
};

audioCloseBtn.onclick = closeAudioModal;
audioStopBtn.onclick = stopAudioRecording;
audioPauseBtn.onclick = togglePauseRecording;
audioSendBtn.onclick = sendAudioMessage;

// Mobile: Touch gestures for recording
let touchStartY = 0;
let touchStartX = 0;
let touchStartTime = 0;

audioRecordBtn.addEventListener('touchstart', (e) => {
  if(!running || !currentRoom) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  touchStartY = touch.clientY;
  touchStartX = touch.clientX;
  touchStartTime = Date.now();
  
  const rect = audioRecordBtn.getBoundingClientRect();
  recordingStartPos = {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
  
  // Position gesture hints
  gestureHint.style.left = recordingStartPos.x + 'px';
  gestureHint.style.top = recordingStartPos.y + 'px';
  gestureHint.classList.add('active');
  gestureText.textContent = '‚Üë Slide up to lock';
  
  // Start recording in gesture mode
  isMobileGestureRecording = true;
  isRecordingLocked = false;
  startAudioRecording();
});

audioRecordBtn.addEventListener('touchmove', (e) => {
  if(!isMobileGestureRecording) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  const deltaY = touchStartY - touch.clientY; // Positive when sliding up
  const deltaX = touchStartX - touch.clientX; // Positive when sliding left
  
  // Check for slide up to lock (80px threshold)
  if(deltaY > 80 && !isRecordingLocked){
    isRecordingLocked = true;
    gestureLock.classList.add('highlight');
    gestureText.textContent = 'üîí Recording locked';
    audioModal.classList.add('active');
    recordingOverlay.classList.remove('active');
    setTimeout(() => {
      gestureHint.classList.remove('active');
    }, 500);
    log('üîí Recording locked', 'INFO');
  }
  
  // Check for slide left to cancel (100px threshold)
  if(deltaX > 100 && !isRecordingLocked){
    gestureCancel.classList.add('highlight');
    gestureText.textContent = '‚ùå Cancelled';
    setTimeout(() => {
      cancelAudioRecording();
    }, 200);
  }
  
  // Visual feedback for gestures
  if(deltaY > 40 && !isRecordingLocked){
    gestureLock.classList.add('highlight');
  }else if(!isRecordingLocked){
    gestureLock.classList.remove('highlight');
  }
  
  if(deltaX > 60 && !isRecordingLocked){
    gestureCancel.classList.add('highlight');
  }else{
    gestureCancel.classList.remove('highlight');
  }
});

audioRecordBtn.addEventListener('touchend', (e) => {
  if(!isMobileGestureRecording) return;
  e.preventDefault();
  
  const touchDuration = Date.now() - touchStartTime;
  
  // If locked, keep recording (user can use modal controls)
  if(isRecordingLocked){
    gestureHint.classList.remove('active');
    return;
  }
  
  // If too short (< 500ms), cancel
  if(touchDuration < 500){
    gestureText.textContent = 'Too short!';
    setTimeout(() => {
      cancelAudioRecording();
    }, 300);
    return;
  }
  
  // Otherwise, stop and send
  stopAudioRecording();
  gestureHint.classList.remove('active');
});

// Prevent default click when using touch gestures
audioRecordBtn.addEventListener('touchstart', (e) => {
  e.stopPropagation();
}, { passive: false });

sendBtn.onclick = ()=>sendMessage();
clearBtn.onclick = ()=>{
  clearView();
  // Also reset behavior tracking when clearing view
  resetBehaviorTracking();
  // Reset unread/mention counters
  markAllAsRead();
};

// Cancel reply button
cancelReply.onclick = ()=>{
  cancelReplyTo();
};

// Mark as read when scrolling to bottom
messagesEl.addEventListener('scroll', ()=>{
  const { scrollTop, scrollHeight, clientHeight } = messagesEl;
  const isAtBottom = Math.abs((scrollTop + clientHeight) - scrollHeight) < 50;
  
  if(isAtBottom){
    // User scrolled to bottom - mark all as read
    markAllAsRead();
  }
}, {passive: true});

// Debug command: type "/engagement" to see current score
const originalSendMessage = sendMessage;
window.sendMessage = async function(){
  const text = (msgInput.value||"").trim();
  
  // Check for engagement command
  if(text === '/engagement'){
    const engagement = getEngagementScore();
    const dwells = Array.from(userBehavior.dwellTimes.entries())
      .sort((a,b) => b[1].totalTime - a[1].totalTime)
      .slice(0, 3);
    
    let report = `üìä Engagement Report\n`;
    report += `Sentiment: ${engagement.sentiment}\n`;
    report += `Score: ${engagement.score.toFixed(1)}\n`;
    report += `\nSignals:\n`;
    report += `  ‚úÖ Positive: ${engagement.breakdown.positive.toFixed(1)}\n`;
    report += `  ‚ùå Negative: ${engagement.breakdown.negative.toFixed(1)}\n`;
    report += `  ‚ö° Excitement: ${engagement.breakdown.excitement.toFixed(1)}\n`;
    report += `\nMetrics:\n`;
    report += `  üëÄ Long dwells: ${userBehavior.engagement.longDwells}\n`;
    report += `  üìñ Slow scrolls: ${userBehavior.engagement.slowScrolls}\n`;
    report += `  ‚ö° Quick scrolls: ${userBehavior.engagement.quickScrolls}\n`;
    report += `  üëÜ Rapid taps: ${userBehavior.engagement.rapidTaps}\n`;
    report += `  üëà Swipe left: ${userBehavior.engagement.swipeLeft}\n`;
    report += `  üëâ Swipe right: ${userBehavior.engagement.swipeRight}\n`;
    
    if(dwells.length > 0){
      report += `\nTop dwelled messages:\n`;
      dwells.forEach(([msgId, data], i) => {
        report += `  ${i+1}. ${(data.totalTime/1000).toFixed(1)}s (${data.visits} visits)\n`;
      });
    }
    
    log(report, "INFO");
    showToast(`Engagement: ${engagement.sentiment}`, 'info', 5000);
    msgInput.value = '';
    return;
  }
  
  // Normal send
  return originalSendMessage.call(this);
};

// Fullscreen chat toggle
let isFullscreen = false;
fullscreenBtn.onclick = ()=>{
  isFullscreen = !isFullscreen;
  
  if(isFullscreen){
    document.body.classList.add('chat-fullscreen');
    fullscreenBtn.textContent = '‚úï'; // Close icon
    fullscreenBtn.title = 'Exit fullscreen';
    log('üì± Fullscreen mode enabled', 'INFO');
  }else{
    document.body.classList.remove('chat-fullscreen');
    fullscreenBtn.textContent = '‚õ∂'; // Expand icon
    fullscreenBtn.title = 'Fullscreen chat';
    log('üì± Fullscreen mode disabled', 'INFO');
  }
};

roomInput.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){
    e.preventDefault();
    joinBtn.click();
  }
});

msgInput.addEventListener("input", (e)=>{
  // Trigger typing mode for fast polling
  if(currentRoom && running){
    startTypingMode();
  }
});

msgInput.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){
    // Shift+Enter -> newline, Enter (alone) -> send. Ctrl/Cmd+Enter also sends.
    if(e.shiftKey) return;
    e.preventDefault();
    stopTypingMode(); // Stop fast polling when sending
    sendMessage();
  }
});

/* ============================================================
   BOOT
   ============================================================ */
window.addEventListener("load", async ()=>{
  try{
    setNet("bad","booting‚Ä¶");
    initGuestIdentity();
    loadSessionFromStorage();
    applySessionToUi();

    installInteractionListeners();
    
    // ========================================
    // Initialize Resource Monitor
    // ========================================
    initResourceMonitor();
    log("üìä Resource monitor initialized", "INFO");
    
    // Initialize pull-to-refresh gesture (tap-hold-drag only)
    initPullToRefreshGesture();
    log("‚úÖ Pull-to-refresh gesture initialized (hold 500ms + drag 80px slowly)", "INFO");
    
    // Tab visibility: check for messages when tab becomes visible
    document.addEventListener("visibilitychange", ()=>{
      if(!document.hidden && running && currentRoom && !pollInFlight){
        // Tab became visible - check for new messages
        clearTimeout(pollTimer);
        setTimeout(pollLoop, 100);
      }
    });

    log("‚è≥ Loading token‚Ä¶","INFO");
    await ensureGhToken();

    log("‚è≥ Loading password dictionary (READ ONLY)‚Ä¶","INFO");
    await loadPasswordDictionary();

    if(PWD_DICT_READY){
      log("‚úÖ Dictionary ready.","INFO");
    }else{
      log("‚ùå Dictionary missing. Login/Register disabled.","ERROR");
    }

    setNet("ok","ready");
    log("Ready. Join a room.","INFO");
  }catch(e){
    console.error("[BOOT ERROR]", e);
    setNet("bad","boot error");
    log("Boot error: check network/token.","ERROR");
  }
});
</script>
<!-- Compatibility wrappers for Cp2pv3 API (aliases / helpers) -->
<script>
// These wrappers restore several Cp2pv3 function names expected by older modules.
// They are safe no-ops or thin adapters to Cp2pv4 implementations.
(function(){
  if(typeof b64 === 'undefined' && typeof b64EncodeUtf8 === 'function'){
    window.b64 = function(s){ return b64EncodeUtf8(String(s)); };
  }

  if(typeof ghRawUrl === 'undefined' && typeof rawUrl === 'function'){
    window.ghRawUrl = function(p){ return rawUrl(p); };
  }

  if(typeof makeMsgId === 'undefined'){
    window.makeMsgId = function(){ return `m-${Date.now()}-${Math.random().toString(36).slice(2,10)}`; };
  }

  if(typeof enforceDomCap === 'undefined'){
    window.enforceDomCap = function(){
      try{
        if(!window.messagesEl) return;
        while(messagesEl.children.length > (window.DOM_MAX_MESSAGES || 200)){
          messagesEl.removeChild(messagesEl.firstChild);
        }
      }catch(e){/* ignore */}
    };
  }

  if(typeof scrollToBottomSoon === 'undefined'){
    window.scrollToBottomSoon = function(){ requestAnimationFrame(()=>{ if(window.messagesEl) messagesEl.scrollTop = messagesEl.scrollHeight; }); };
  }

  // ghGetCellWithSha / ghGetManifestWithSha adapters (V3 names -> V4 helpers)
  if(typeof ghGetCellWithSha === 'undefined'){
    window.ghGetCellWithSha = async function(roomName, cellNumber){
      const p = cellPath(roomName, cellNumber);
      const got = await ghGetJsonWithSha(p);
      const arr = Array.isArray(got.obj) ? got.obj : [];
      return { path: p, sha: got.sha || null, arr };
    };
  }

  if(typeof ghGetManifestWithSha === 'undefined'){
    window.ghGetManifestWithSha = async function(roomName){
      const p = manifestPath(roomName);
      const got = await ghGetJsonWithSha(p);
      const obj = (got.obj && typeof got.obj === 'object') ? got.obj : null;
      return { path: p, sha: got.sha || null, obj };
    };
  }

  // appendMessageToCells compatibility -> appendMessageV3
  if(typeof appendMessageToCells === 'undefined' && typeof appendMessageV3 === 'function'){
    window.appendMessageToCells = async function(roomName, msg){
      return await appendMessageV3(roomName, msg);
    };
  }

  // bumpMaster / readMasterStampRaw aliases
  if(typeof bumpMaster === 'undefined' && typeof saveMasterValue === 'function'){
    window.bumpMaster = async function(roomName){
      await saveMasterValue(roomName, Date.now());
    };
  }

  if(typeof readMasterStampRaw === 'undefined' && typeof readMasterValue === 'function'){
    window.readMasterStampRaw = async function(roomName){
      const r = await readMasterValue(roomName);
      return { unchanged: false, stamp: r.ok ? (r.value ? Date.now() : 0) : 0 };
    };
  }

  // ghPutJson older signature compatibility: already implemented in file, keep alias
  if(typeof ghPutJsonCompat === 'undefined'){
    window.ghPutJsonCompat = function(path,obj,sha,commitMsg){ return ghPutJson(path,obj,sha,commitMsg); };
  }

})();
</script>
</body>
</html>
