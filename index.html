<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Chat-p2p V3 (cells+boxes) ‚Äî Sotravil</title>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f172a;
      --panel2:#111c36;
      --txt:#e5e7eb;
      --muted:#94a3b8;
      --ok:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --border:rgba(255,255,255,.08);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --pad:14px;
      --mono:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --accent-primary: #38bdf8;
      --accent-secondary: #a855f7;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;
      /* Hide body scrollbar */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    html::-webkit-scrollbar, body::-webkit-scrollbar {
      display: none;
    }
    body{
      margin:0;
      background:radial-gradient(1200px 700px at 40% -10%, rgba(56,189,248,.15), transparent 60%),
                 radial-gradient(900px 500px at 120% 20%, rgba(168,85,247,.12), transparent 55%),
                 radial-gradient(600px 400px at 80% 100%, rgba(34,197,94,.08), transparent 50%),
                 var(--bg);
      color:var(--txt);
      font-family:var(--sans);
      -webkit-font-smoothing:antialiased;
      overflow:hidden;
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 18px;
      border-bottom:1px solid var(--border);
      background:rgba(15,23,42,.85);
      backdrop-filter: blur(12px);
      box-shadow: 0 2px 8px rgba(0,0,0,.15);
    }
    header .left{display:flex; align-items:center; gap:10px}
    header h1{font-size:14px; margin:0; letter-spacing:.2px; opacity:.95}
    header .status{
      display:inline-flex; align-items:center; gap:8px;
      font-size:12px; color:var(--muted);
      padding:6px 10px; border:1px solid var(--border); border-radius:999px;
      background:rgba(255,255,255,.03);
    }
    .dot{width:10px;height:10px;border-radius:99px;background:var(--warn)}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}

    header .right{display:flex; align-items:center; gap:8px}
    button{
      border:1px solid var(--border);
      background:rgba(255,255,255,.05);
      color:var(--txt);
      padding:9px 14px;
      border-radius:11px;
      font-size:12px;
      font-weight:500;
      cursor:pointer;
      box-shadow:0 2px 4px rgba(0,0,0,.1);
      transition:all .2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    button:hover:not(:disabled){
      background:rgba(255,255,255,.08);
      transform:translateY(-1px);
      box-shadow:0 4px 8px rgba(0,0,0,.2);
    }
    button:active:not(:disabled){
      transform:translateY(0px);
      box-shadow:0 1px 2px rgba(0,0,0,.15);
    }
    button.primary{
      background:linear-gradient(135deg, rgba(34,197,94,.18), rgba(34,197,94,.12));
      border-color:rgba(34,197,94,.4);
      color:#22c55e;
    }
    button.primary:hover:not(:disabled){
      background:linear-gradient(135deg, rgba(34,197,94,.25), rgba(34,197,94,.18));
      border-color:rgba(34,197,94,.5);
    }
    button.danger{
      background:linear-gradient(135deg, rgba(239,68,68,.18), rgba(239,68,68,.12));
      border-color:rgba(239,68,68,.4);
      color:#ef4444;
    }
    button.danger:hover:not(:disabled){
      background:linear-gradient(135deg, rgba(239,68,68,.25), rgba(239,68,68,.18));
      border-color:rgba(239,68,68,.5);
    }
    button:disabled{opacity:.4; cursor:not-allowed}

    main{
      height:calc(100% - 50px);
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:10px;
      padding:12px;
    }
    .panel{
      background:linear-gradient(180deg, rgba(17,28,54,.98), rgba(15,23,42,.95));
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      box-shadow:0 12px 40px rgba(0,0,0,.4), 0 0 1px rgba(255,255,255,.1);
      overflow:hidden;
      position:relative;
    }
    .panel::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:18px;
      padding:1px;
      background:linear-gradient(135deg, rgba(56,189,248,.2), transparent 40%, rgba(168,85,247,.15));
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask-composite:exclude;
      pointer-events:none;
      opacity:.5;
    }
    .join{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .field{display:flex; flex-direction:column; gap:6px; flex:1; min-width:140px}
    label{font-size:11px; color:var(--muted)}
    input{
      width:100%;
      padding:11px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      transition:all .2s ease;
    }
    input:focus{
      border-color:rgba(56,189,248,.5);
      background:rgba(0,0,0,.35);
      box-shadow:0 0 0 3px rgba(56,189,248,.1);
    }
    .hint{font-size:11px;color:var(--muted); line-height:1.25}
    .chat{
      display:flex;
      flex-direction:column;
      min-height:0;
    }
    .chatHeader{
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .chatHeader .meta{display:flex; flex-direction:column; gap:2px; min-width:0}
    .chatHeader .meta .room{font-size:13px; font-weight:650; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .chatHeader .meta .sub{font-size:11px;color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .chatHeader .people{font-size:11px;color:var(--muted); white-space:nowrap}
    .msgs{
      padding:12px;
      overflow:auto;
      scroll-behavior:smooth;
      -webkit-overflow-scrolling:touch;
      min-height:0;
      /* Hide scrollbar but keep functionality */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    .msgs::-webkit-scrollbar {
      display: none; /* Chrome/Safari/Opera */
    }
    .msg{
      max-width:85%;
      padding:11px 13px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.06);
      margin:10px 0;
      word-wrap:break-word;
      transition:all .2s ease;
      box-shadow:0 2px 8px rgba(0,0,0,.15);
    }
    .msg:hover{
      border-color:rgba(255,255,255,.12);
      box-shadow:0 4px 12px rgba(0,0,0,.25);
      transform:translateY(-1px);
    }
    .msg.me{
      margin-left:auto;
      background:linear-gradient(135deg, rgba(56,189,248,.15), rgba(56,189,248,.08));
      border-color:rgba(56,189,248,.3);
    }
    .msg.me:hover{
      background:linear-gradient(135deg, rgba(56,189,248,.2), rgba(56,189,248,.12));
      border-color:rgba(56,189,248,.4);
    }
    .msg .text{font-size:13px; line-height:1.35}
    .msg .meta{font-size:10px; color:var(--muted); margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .msg .reads{font-size:10px;color:rgba(34,197,94,.85)}
    .msg-status{
      font-size:11px;
      color:var(--muted);
      display:inline-flex;
      align-items:center;
      gap:4px;
      margin-left:auto;
    }
    .msg-status.status-sending{
      color:rgba(245,158,11,.85);
    }
    .msg-status.status-sending::before{
      content:'\23F3';
      animation:statusPulse 1.5s ease-in-out infinite;
    }
    .msg-status.status-sent{
      color:var(--muted);
    }
    .msg-status.status-sent::before{
      content:'\2713';
    }
    .msg-status.status-delivered{
      color:rgba(56,189,248,.75);
    }
    .msg-status.status-delivered::before{
      content:'\2713\2713';
    }
    .msg-status.status-read{
      color:rgba(34,197,94,.85);
    }
    .msg-status.status-read::before{
      content:'\2713\2713';
    }
    .msg-status.status-failed{
      color:rgba(239,68,68,.85);
      cursor:pointer;
    }
    .msg-status.status-failed::before{
      content:'\26A0';
    }
    .msg-retry{
      display:none;
      font-size:10px;
      padding:3px 8px;
      margin-left:6px;
      border-radius:6px;
      background:rgba(239,68,68,.15);
      border:1px solid rgba(239,68,68,.35);
      color:#ef4444;
      cursor:pointer;
      transition:all .2s ease;
    }
    .msg-retry:hover{
      background:rgba(239,68,68,.25);
      border-color:rgba(239,68,68,.5);
    }
    .msg.msg-failed .msg-retry{
      display:inline-block;
    }
    .msg.msg-failed{
      opacity:.85;
      border-color:rgba(239,68,68,.3);
    }
    @keyframes statusPulse{
      0%, 100%{opacity:.5}
      50%{opacity:1}
    }
    .composer{
      display:flex;
      gap:10px;
      padding:12px;
      border-top:1px solid var(--border);
    }
    .composer textarea{
      flex:1;
      min-height:44px;
      max-height:120px;
      resize:none;
      padding:11px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      font-family:var(--sans);
      transition:all .2s ease;
      /* Hide scrollbar */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .composer textarea::-webkit-scrollbar {
      display: none;
    }
    .composer textarea:focus{
      border-color:rgba(56,189,248,.5);
      background:rgba(0,0,0,.35);
      box-shadow:0 0 0 3px rgba(56,189,248,.1);
    }
    .log{
      padding:10px 12px;
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted);
      max-height:110px;
      overflow:auto;
      border-top:1px solid var(--border);
      background:rgba(0,0,0,.12);
      /* Hide scrollbar */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .log::-webkit-scrollbar {
      display: none;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      font-size:11px; color:var(--muted);
    }
    .modalBackdrop{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
      background:rgba(0,0,0,.55);
      z-index:50;
    }
    .modal{
      width:min(420px, 100%);
      background:linear-gradient(180deg, rgba(17,28,54,.98), rgba(15,23,42,.98));
      border:1px solid rgba(255,255,255,.15);
      border-radius:20px;
      box-shadow:0 20px 60px rgba(0,0,0,.6), 0 0 1px rgba(255,255,255,.2);
      overflow:hidden;
      animation:modalSlideIn .25s cubic-bezier(0.4, 0, 0.2, 1);
    }
    @keyframes modalSlideIn {
      from {
        opacity:0;
        transform:translateY(-20px) scale(0.95);
      }
      to {
        opacity:1;
        transform:translateY(0) scale(1);
      }
    }
    .modal .top{padding:12px 14px; border-bottom:1px solid var(--border); display:flex; align-items:center; justify-content:space-between}
    .modal .top b{font-size:13px}
    .modal .body{padding:14px; display:flex; flex-direction:column; gap:10px}
    .modal .footer{padding:12px 14px; border-top:1px solid var(--border); display:flex; gap:10px; justify-content:flex-end}

    /* Modal overlay styles for edit/delete confirmations */
    .modal-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:rgba(0,0,0,.65);
      z-index:100;
      backdrop-filter:blur(4px);
    }
    .modal-overlay.modal-hidden{
      display:none !important;
    }
    .modal-overlay:not(.modal-hidden){
      display:flex;
    }
    .modal-header{
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .modal-title{
      font-size:15px;
      font-weight:600;
    }
    .modal-close{
      width:28px;
      height:28px;
      border:none;
      background:rgba(255,255,255,.05);
      color:var(--txt);
      border-radius:8px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
      transition:all .2s ease;
    }
    .modal-close:hover{
      background:rgba(255,255,255,.1);
    }
    .modal-body{
      padding:18px 16px;
    }
    .modal-body p{
      margin:0 0 12px 0;
      line-height:1.5;
    }
    .modal-body textarea{
      width:100%;
      min-height:120px;
      padding:10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      font-family:var(--sans);
      resize:vertical;
      transition:all .2s ease;
    }
    .modal-body textarea:focus{
      border-color:rgba(56,189,248,.5);
      background:rgba(0,0,0,.35);
      box-shadow:0 0 0 3px rgba(56,189,248,.1);
    }
    .modal-footer{
      padding:12px 16px;
      border-top:1px solid var(--border);
      display:flex;
      gap:10px;
      justify-content:flex-end;
    }
    .btn-ghost{
      background:rgba(255,255,255,.03);
      border:1px solid var(--border);
    }
    .btn-ghost:hover:not(:disabled){
      background:rgba(255,255,255,.08);
    }

    /* Message action buttons (edit/delete) */
    .msg-actions{
      margin-top:8px;
      display:flex;
      gap:6px;
      opacity:.6;
      transition:opacity .2s ease;
    }
    .msg:hover .msg-actions{
      opacity:1;
    }
    .msg-actions button{
      padding:5px 10px;
      font-size:11px;
      border-radius:8px;
    }

    /* Toast Notifications */
    .toast-container{
      position:fixed;
      top:20px;
      right:20px;
      z-index:200;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:none;
    }
    .toast{
      min-width:280px;
      max-width:420px;
      padding:14px 16px;
      background:linear-gradient(135deg, rgba(17,28,54,.98), rgba(15,23,42,.95));
      border:1px solid rgba(255,255,255,.15);
      border-radius:14px;
      box-shadow:0 8px 24px rgba(0,0,0,.5), 0 0 1px rgba(255,255,255,.2);
      color:var(--txt);
      font-size:13px;
      line-height:1.4;
      pointer-events:auto;
      animation:toastSlideIn .3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter:blur(10px);
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .toast.toast-success{
      border-color:rgba(34,197,94,.4);
      background:linear-gradient(135deg, rgba(34,197,94,.15), rgba(17,28,54,.95));
    }
    .toast.toast-error{
      border-color:rgba(239,68,68,.4);
      background:linear-gradient(135deg, rgba(239,68,68,.15), rgba(17,28,54,.95));
    }
    .toast.toast-warning{
      border-color:rgba(245,158,11,.4);
      background:linear-gradient(135deg, rgba(245,158,11,.15), rgba(17,28,54,.95));
    }
    .toast.toast-info{
      border-color:rgba(56,189,248,.4);
      background:linear-gradient(135deg, rgba(56,189,248,.15), rgba(17,28,54,.95));
    }
    .toast-icon{
      font-size:18px;
      flex-shrink:0;
      margin-top:1px;
    }
    .toast-success .toast-icon{color:#22c55e}
    .toast-error .toast-icon{color:#ef4444}
    .toast-warning .toast-icon{color:#f59e0b}
    .toast-info .toast-icon{color:#38bdf8}
    .toast-message{
      flex:1;
      word-wrap:break-word;
    }
    .toast-close{
      width:20px;
      height:20px;
      border:none;
      background:rgba(255,255,255,.08);
      color:var(--muted);
      border-radius:6px;
      cursor:pointer;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-shrink:0;
      transition:all .2s ease;
    }
    .toast-close:hover{
      background:rgba(255,255,255,.15);
      color:var(--txt);
    }
    .toast.toast-out{
      animation:toastSlideOut .25s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    @keyframes toastSlideIn{
      from{
        opacity:0;
        transform:translateX(100%) scale(0.9);
      }
      to{
        opacity:1;
        transform:translateX(0) scale(1);
      }
    }
    @keyframes toastSlideOut{
      from{
        opacity:1;
        transform:translateX(0) scale(1);
      }
      to{
        opacity:0;
        transform:translateX(120%) scale(0.9);
      }
    }

    /* Room Browser */
    .room-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height:400px;
      overflow-y:auto;
      scrollbar-width:none;
      -ms-overflow-style:none;
    }
    .room-list::-webkit-scrollbar{
      display:none;
    }
    .room-item{
      padding:12px 14px;
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      border-radius:12px;
      cursor:pointer;
      transition:all .2s ease;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .room-item:hover{
      background:rgba(255,255,255,.08);
      border-color:rgba(56,189,248,.35);
      transform:translateX(4px);
    }
    .room-item.last-joined{
      border-color:rgba(34,197,94,.4);
      background:linear-gradient(135deg, rgba(34,197,94,.12), rgba(255,255,255,.04));
    }
    .room-item.last-joined::before{
      content:'\2B50';
      margin-right:8px;
    }
    .room-info{
      flex:1;
      min-width:0;
    }
    .room-name{
      font-size:14px;
      font-weight:600;
      color:var(--txt);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .room-meta{
      font-size:11px;
      color:var(--muted);
      margin-top:2px;
    }
    .room-status{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:var(--muted);
      flex-shrink:0;
    }
    .room-status.active{
      color:rgba(34,197,94,.85);
    }
    .room-status .user-count{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:4px 8px;
      background:rgba(56,189,248,.12);
      border:1px solid rgba(56,189,248,.3);
      border-radius:8px;
      font-weight:600;
    }
    .room-status.active .user-count{
      background:rgba(34,197,94,.12);
      border-color:rgba(34,197,94,.3);
      color:rgba(34,197,94,.95);
    }
    .empty-rooms{
      padding:40px 20px;
      text-align:center;
      color:var(--muted);
      font-size:13px;
    }
    .browse-btn{
      margin-left:8px;
    }

    /* Mobile-first -> on wide screens keep nice centered content */
    @media (min-width: 960px){
      main{max-width:980px; margin:0 auto}
      .row{flex-wrap:nowrap}
      .msg{max-width:70%}
    }
  </style>
</head>
<body>
<header>
  <div class="left">
    <h1>Chat‚Äëp2p V3 (cells + boxes + indexes)</h1>
    <span class="status"><span id="netDot" class="dot"></span><span id="netText">booting‚Ä¶</span></span>
  </div>
  <div class="right">
    <span class="pill" id="authPill">Guest</span>
    <button id="browseRoomsBtn" class="browse-btn" style="display:none">üìÅ Browse Rooms</button>
    <button id="loginBtn">Login</button>
    <button id="registerBtn" class="primary">Register</button>
    <button id="logoutBtn" class="danger" style="display:none">Logout</button>
  </div>
</header>

<main>
  <section class="panel join">
    <div class="row">
      <div class="field">
        <label>Room</label>
        <input id="roomInput" placeholder="e.g. general" autocomplete="off"/>
      </div>
      <div class="field">
        <label>Display name</label>
        <input id="nameInput" placeholder="e.g. Sotravil" autocomplete="off"/>
      </div>
      <div class="field" style="max-width:170px">
        <label>Poll ms (on interaction)</label>
        <input id="pollInput" type="number" value="2000" min="500" step="100"/>
      </div>
    </div>
    <div class="row" style="align-items:center; justify-content:space-between">
      <div class="hint">
        No backend: <b>Writes</b> via GitHub Contents API, <b>Reads</b> via raw + ETag cache with API fallback.
        Idle = zero network. Active = fast sync.
      </div>
      <div style="display:flex; gap:10px">
        <button id="joinBtn" class="primary">Join</button>
        <button id="leaveBtn">Leave</button>
      </div>
    </div>
  </section>

  <section class="panel chat" id="chatPanel" style="display:none">
    <div class="chatHeader">
      <div class="meta">
        <div class="room" id="roomTitle">‚Äî</div>
        <div class="sub" id="roomSub">‚Äî</div>
      </div>
      <div class="people" id="presenceSummary">presence: ‚Äî</div>
    </div>

    <div class="msgs" id="messages"></div>

    <div class="composer">
      <textarea id="msgInput" placeholder="Type‚Ä¶ (Enter to send ‚Äî Shift+Enter for newline)"></textarea>
      <button id="sendBtn" class="primary">Send</button>
      <button id="clearBtn">Clear view</button>
    </div>

    <div class="log" id="log"></div>
  </section>
</main>

<!-- AUTH MODAL -->
<div class="modalBackdrop" id="authModalBack">
  <div class="modal">
    <div class="top">
      <b id="authModalTitle">Auth</b>
      <button id="authCloseBtn">‚úï</button>
    </div>
    <div class="body">
      <div class="field">
        <label>Username (global)</label>
        <input id="authUserInput" placeholder="username" autocomplete="username"/>
      </div>
      <div class="field">
        <label>Password (dictionary‚Äëvalidated)</label>
        <input id="authPassInput" type="password" placeholder="password" autocomplete="current-password"/>
        <div class="hint" id="dictHint">Loading password dictionary‚Ä¶</div>
      </div>
      <div class="hint" id="authMsg"></div>
    </div>
    <div class="footer">
      <button id="authActionBtn" class="primary">OK</button>
    </div>
  </div>
</div>

<script>
/* ============================================================
   CONFIG
   ============================================================ */

// Repo target (your "backend")
const GH_OWNER  = "Sotravil";
const GH_REPO   = "chat-db";
const GH_BRANCH = "main";

// Token from paste.rs (read-only) via CORS proxy
const TOKEN_PASTE_URL = "https://paste.rs/4UElW.txt";
const CORS_PROXY      = "https://corsproxy.io/?";

// Read receipts / presence
const PRESENCE_ACTIVE_HEARTBEAT_MS = 10_000;   // 10s while ACTIVE
const PRESENCE_RECENT_MS           = 5 * 60_000; // 5 min "recent"

// === ACTIVITY TRACKER ===
const POLL_MS_BURST          = 500;     // Fast checks during conversation burst
const POLL_MS_INTERACTION    = 2000;    // Check after interaction
const POLL_BURST_DURATION    = 10_000;  // 10s burst after sending message
const POLL_MS_IDLE           = 90_000;  // 90s (for presence only)
const IDLE_THRESHOLD_MS      = 2_000;   // 2s since last interaction => idle
const ACTIVE_BURST_MS        = 2_000;   // keep active for 2s after last interaction
const INTERACTION_THROTTLE_MS= 150;     // update timestamps at most every 150ms

// === V3 STORAGE ===
const MANIFEST_VERSION_V3 = 3;

// micro-segmentation
const CELL_MAX_MESSAGES = 4;         // 4 messages per cell (you requested)
const BOX_MAX_CELLS     = 100;       // 100 cells per box (you requested)
const CELLS_PER_BOX     = BOX_MAX_CELLS;

// Paths
const ROOMS_DIR        = "rooms";
const ROOMS_META_DIR   = "rooms-meta";
const ROOMS_CELLS_BASE = "rooms-cells"; // V3 base
const MASTER_ROOMS_DIR = "master-rooms"; // Master sync files

// Password dictionary (immutable / READ ONLY)
const PASSWORD_DICTIONARY_PATH = "config/password_dictionary_v1.json";

/* ============================================================
   DOM
   ============================================================ */
const el = (id)=>document.getElementById(id);
const netDot = el("netDot");
const netText= el("netText");

const authPill   = el("authPill");
const loginBtn   = el("loginBtn");
const registerBtn= el("registerBtn");
const logoutBtn  = el("logoutBtn");
const browseRoomsBtn = el("browseRoomsBtn");

const authModalBack = el("authModalBack");
const authModalTitle= el("authModalTitle");
const authCloseBtn  = el("authCloseBtn");
const authActionBtn = el("authActionBtn");
const authUserInput = el("authUserInput");
const authPassInput = el("authPassInput");
const dictHint      = el("dictHint");
const authMsg       = el("authMsg");

const roomInput  = el("roomInput");
const nameInput  = el("nameInput");
const pollInput  = el("pollInput");
const joinBtn    = el("joinBtn");
const leaveBtn   = el("leaveBtn");

const chatPanel  = el("chatPanel");
const roomTitle  = el("roomTitle");
const roomSub    = el("roomSub");
const presenceSummary = el("presenceSummary");

const messagesEl = el("messages");
const msgInput   = el("msgInput");
const sendBtn    = el("sendBtn");
const clearBtn   = el("clearBtn");
const logEl      = el("log");

/* ============================================================
   UTIL
   ============================================================ */
function log(msg, level="INFO"){
  const now = new Date();
  const hh = String(now.getHours()).padStart(2,"0");
  const mm = String(now.getMinutes()).padStart(2,"0");
  const ss = String(now.getSeconds()).padStart(2,"0");
  const line = document.createElement("div");
  line.textContent = `[${hh}:${mm}:${ss}] [${level}] ${msg}`;
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function pad6(n){ return String(n).padStart(6,"0"); }
function padBox(n){ return String(n).padStart(6,"0"); }
function b64EncodeUtf8(str){ return btoa(unescape(encodeURIComponent(str))); }
function b64DecodeUtf8(b64){ return decodeURIComponent(escape(atob(b64))); }
function buildProxyUrl(url){
  // Supports urls that arrive already URL-encoded
  let target=url;
  try{
    const decoded = decodeURIComponent(url);
    if(decoded.startsWith("http://") || decoded.startsWith("https://")) target = decoded;
  }catch(_){}
  return `${CORS_PROXY}${target}`;
}
function ghFileUrl(path){
  const encoded = encodeURIComponent(path).replace(/%2F/g,"/");
  return `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encoded}`;
}
function rawUrl(path){
  const clean = path.replace(/^\/+/,"");
  return `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${clean}`;
}
function setNet(state, text){
  netText.textContent = text;
  netDot.classList.remove("ok","bad");
  if(state==="ok"){ netDot.classList.add("ok"); }
  if(state==="bad"){ netDot.classList.add("bad"); }
}

/* ============================================================
   TOAST NOTIFICATIONS
   ============================================================ */
let toastContainer = null;

function ensureToastContainer(){
  if(!toastContainer){
    toastContainer = document.createElement('div');
    toastContainer.className = 'toast-container';
    document.body.appendChild(toastContainer);
  }
  return toastContainer;
}

function showToast(message, type='info', duration=4000){
  const container = ensureToastContainer();
  
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  
  const icon = document.createElement('div');
  icon.className = 'toast-icon';
  const icons = {
    success: '‚úì',
    error: '‚úï',
    warning: '‚ö†',
    info: '‚Ñπ'
  };
  icon.textContent = icons[type] || icons.info;
  
  const msg = document.createElement('div');
  msg.className = 'toast-message';
  msg.textContent = message;
  
  const closeBtn = document.createElement('button');
  closeBtn.className = 'toast-close';
  closeBtn.textContent = '√ó';
  closeBtn.onclick = () => removeToast(toast);
  
  toast.appendChild(icon);
  toast.appendChild(msg);
  toast.appendChild(closeBtn);
  
  container.appendChild(toast);
  
  // Auto remove after duration
  if(duration > 0){
    setTimeout(() => removeToast(toast), duration);
  }
  
  return toast;
}

function removeToast(toast){
  if(!toast || !toast.parentElement) return;
  toast.classList.add('toast-out');
  setTimeout(() => {
    if(toast.parentElement) toast.parentElement.removeChild(toast);
  }, 250);
}

/* ============================================================
   TOKEN LOADER (paste.rs -> extract github_pat_ from HTML)
   ============================================================ */
let GH_TOKEN = null;
let ghTokenReady = false;
let ghTokenPromise = null;

async function loadGhTokenFromPaste(){
  const url = buildProxyUrl(TOKEN_PASTE_URL);
  const res = await fetch(url, { headers:{ "Accept":"text/plain" }});
  if(!res.ok) throw new Error(`Token paste read failed status=${res.status}`);
  let html = await res.text();
  html = html.replace(/\r\n/g,"\n");
  const patRegex = /github_pat_[^<\s"]+/;
  const match = html.match(patRegex);
  if(!match) throw new Error("No github_pat_ found in paste HTML.");
  GH_TOKEN = match[0].trim();
  ghTokenReady = true;
  // Safe log (no token leakage)
  log("‚úÖ GitHub token loaded (safe).","INFO");
  setNet("ok","token ok");
}

async function ensureGhToken(){
  if(ghTokenReady && GH_TOKEN) return;
  if(ghTokenPromise){ await ghTokenPromise; return; }
  ghTokenPromise = loadGhTokenFromPaste();
  await ghTokenPromise;
}

/* ============================================================
   GITHUB HELPERS (ETag raw read + Contents API fallback)
   ============================================================ */

// In-memory ETag cache per raw URL
const RAW_ETAG = new Map(); // key: rawUrl -> {etag, text}

async function rawGetText(path){
  const url = rawUrl(path);
  const headers = {};
  const cached = RAW_ETAG.get(url);
  if(cached?.etag) headers["If-None-Match"] = cached.etag;

  const res = await fetch(url, { method:"GET", headers });
  if(res.status === 304 && cached) return { ok:true, status:304, text: cached.text, etag: cached.etag };
  if(!res.ok) return { ok:false, status:res.status, text:"", etag:null };
  const etag = res.headers.get("etag");
  const text = await res.text();
  if(etag) RAW_ETAG.set(url, { etag, text });
  return { ok:true, status:res.status, text, etag };
}

// Contents GET JSON + sha
async function ghGetJsonWithSha(path){
  await ensureGhToken();
  const res = await fetch(ghFileUrl(path), {
    method:"GET",
    headers:{
      "Accept":"application/vnd.github+json",
      "Authorization":`Bearer ${GH_TOKEN}`
    }
  });

  if(res.status===404) return { ok:false, status:404, obj:null, sha:null, rawText:null };
  const rawText = await res.text();
  if(!res.ok) return { ok:false, status:res.status, obj:null, sha:null, rawText };
  const data = JSON.parse(rawText);
  const contentB64 = (data.content||"").replace(/\n/g,"");
  const jsonText = contentB64 ? b64DecodeUtf8(contentB64) : "";
  const obj = jsonText.trim() ? JSON.parse(jsonText) : null;
  return { ok:true, status:res.status, obj, sha:data.sha||null, rawText };
}

// Contents PUT JSON
async function ghPutJson(path, obj, sha=null, message="update"){
  await ensureGhToken();
  const jsonText = JSON.stringify(obj, null, 2);
  const body = {
    message: `${message} ${new Date().toISOString()}`,
    content: b64EncodeUtf8(jsonText),
    branch: GH_BRANCH
  };
  if(sha) body.sha = sha;

  // Try PUT, and on 422/409 attempt one retry by fetching current sha.
  const doPut = async (putBody) => {
    const res = await fetch(ghFileUrl(path), {
      method:"PUT",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`,
        "Content-Type":"application/json"
      },
      body: JSON.stringify(putBody)
    });
    const raw = await res.text();
    return { res, raw };
  };

  let attempt = 0;
  let lastErr = null;
  while(attempt < 2){
    const { res, raw } = await doPut(body);
    if(res.ok){
      const data = JSON.parse(raw || '{}');
      return { ok:true, status: res.status, sha: data?.content?.sha || null };
    }

    // If GitHub complains about missing sha or conflict, try to GET current sha and retry once
    if((res.status === 422 || res.status === 409) && attempt === 0){
      try{
        const got = await ghGetJsonWithSha(path);
        if(got.sha) body.sha = got.sha;
        else body.sha = null; // still try even if null
        attempt++;
        continue;
      }catch(e){
        lastErr = e;
        break;
      }
    }

    // Other failures: capture and throw
    console.error("[ghPutJson ERROR]", {path, status: res.status, raw});
    lastErr = new Error(`ghPutJson failed status=${res.status} path=${path} raw=${raw}`);
    break;
  }

  throw lastErr || new Error(`ghPutJson failed for ${path}`);
}

// List directory via Contents API (needed for auth + presence browsing)
async function ghListDir(path){
  await ensureGhToken();
  const res = await fetch(ghFileUrl(path), {
    method:"GET",
    headers:{
      "Accept":"application/vnd.github+json",
      "Authorization":`Bearer ${GH_TOKEN}`
    }
  });
  if(res.status===404) return { ok:false, status:404, items:[] };
  const raw = await res.text();
  if(!res.ok) return { ok:false, status:res.status, items:[] };
  const items = JSON.parse(raw);
  return { ok:true, status:res.status, items: Array.isArray(items)? items: [] };
}

/* ============================================================
   === DICTIONARY LOADER (READ ONLY) ===
   ============================================================ */
let PWD_DICT = null;            // { sha, charset, map }
let PWD_DICT_READY = false;
let PWD_DICT_ERROR = null;

function setAuthDisabled(reason){
  loginBtn.disabled = true;
  registerBtn.disabled = true;
  dictHint.textContent = reason;
  dictHint.style.color = "rgba(239,68,68,.9)";
}

async function loadPasswordDictionary(){
  try{
    // localStorage cache
    const cacheKey = "pwd_dict_cache_v1";
    const cached = localStorage.getItem(cacheKey);
    if(cached){
      try{
        const c = JSON.parse(cached);
        if(c?.sha && c?.dict?.map){
          PWD_DICT = { sha:c.sha, charset:c.dict.charset||"", map:c.dict.map };
          PWD_DICT_READY = true;
          dictHint.textContent = "Dictionary cached ‚úÖ";
        }
      }catch(_){}
    }

    // Always re-check sha (cheap) so we can refresh if repo updates it
    const got = await ghGetJsonWithSha(PASSWORD_DICTIONARY_PATH);
    if(!got.ok || !got.obj){
      PWD_DICT_ERROR = `Dictionary missing/unreadable (status=${got.status}).`;
      setAuthDisabled(PWD_DICT_ERROR);
      return;
    }

    const dict = got.obj;
    if(!dict?.map || typeof dict.map !== "object"){
      PWD_DICT_ERROR = "Dictionary invalid (missing map).";
      setAuthDisabled(PWD_DICT_ERROR);
      return;
    }

    // Store in memory (READ ONLY)
    PWD_DICT = { sha: got.sha, charset: dict.charset || "", map: dict.map };
    PWD_DICT_READY = true;
    PWD_DICT_ERROR = null;

    localStorage.setItem("pwd_dict_cache_v1", JSON.stringify({ sha:got.sha, dict: { charset: PWD_DICT.charset, map: PWD_DICT.map }}));
    dictHint.textContent = "Dictionary ready ‚úÖ";
  }catch(e){
    console.error("[Dictionary ERROR]", e);
    PWD_DICT_ERROR = "Dictionary load failed (network).";
    setAuthDisabled(PWD_DICT_ERROR);
  }
}

async function reloadDictionary(){
  // Safe refresh: just calls load again; sha-based localStorage keeps it cheap.
  PWD_DICT_READY = false;
  await loadPasswordDictionary();
}

/* ============================================================
   === AUTH (GLOBAL USER ACCOUNT, DEVICE SESSION) ===
   ============================================================ */
const SESSION_KEY = "cp2p_session_v1";
let session = null; // {userId, username, loginAt}

function normalizeUsername(u){
  return (u||"").trim().toLowerCase();
}

async function sha256Hex(str){
  const data = new TextEncoder().encode(str);
  const digest = await crypto.subtle.digest("SHA-256", data);
  return [...new Uint8Array(digest)].map(b=>b.toString(16).padStart(2,"0")).join("");
}

function randomSaltB64(){
  const bytes = new Uint8Array(16);
  crypto.getRandomValues(bytes);
  // base64
  let bin = "";
  for(const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}

function validatePasswordWithDict(pw){
  if(!PWD_DICT_READY || !PWD_DICT?.map) return { ok:false, reason:"Dictionary not ready." };
  const map = PWD_DICT.map;
  for(const ch of pw){
    if(!map.hasOwnProperty(ch)) return { ok:false, reason:`Password char not allowed: "${ch}"` };
  }
  return { ok:true };
}

function passwordToNumericStream(pw){
  const map = PWD_DICT.map;
  let out = "";
  for(const ch of pw){
    out += String(map[ch]);
  }
  return out;
}

function splitStream(stream, chunkLen=500){
  const chunks = [];
  for(let i=0;i<stream.length;i+=chunkLen) chunks.push(stream.slice(i, i+chunkLen));
  return chunks;
}

async function hashChunks(streamChunks, salt){
  const hashes = [];
  for(const chunk of streamChunks){
    const hex = await sha256Hex(`${salt}:${chunk}`);
    hashes.push(hex);
  }
  return hashes;
}

async function ensureUsersIndex(){
  // users/index.json format:
  // { v:1, byUsernameLower: { "name": "u_xxx" }, updatedAt }
  const path = "users/index.json";
  const got = await ghGetJsonWithSha(path);
  if(got.ok && got.obj) return { ok:true, sha:got.sha, obj:got.obj };
  if(got.status === 404){
    const obj = { v:1, byUsernameLower:{}, updatedAt: Date.now() };
    const put = await ghPutJson(path, obj, null, "init users index");
    return { ok:true, sha:put.sha, obj };
  }
  return { ok:false, sha:null, obj:null, status:got.status };
}

async function registerUser(username, password){
  if(!PWD_DICT_READY) throw new Error("Password dictionary not ready.");
  const uLower = normalizeUsername(username);
  if(!uLower) throw new Error("Username required.");
  if(uLower.length < 3) throw new Error("Username too short.");
  if(password.length < 4) throw new Error("Password too short.");

  const valid = validatePasswordWithDict(password);
  if(!valid.ok) throw new Error(valid.reason);

  const idx = await ensureUsersIndex();
  if(!idx.ok) throw new Error(`users/index load failed (status=${idx.status})`);

  if(idx.obj.byUsernameLower?.[uLower]) throw new Error("Username already exists.");

  // userId derived from username hash (stable)
  const userId = "u_" + (await sha256Hex(uLower)).slice(0,16);

  const salt = randomSaltB64();
  const stream = passwordToNumericStream(password);
  const chunks = splitStream(stream, 500);
  const hashes = await hashChunks(chunks, salt);

  const profilePath = `users/${userId}/profile.json`;
  const profile = {
    v:1,
    userId,
    username,
    usernameLower: uLower,
    createdAt: Date.now(),
    salt,
    authChunks: hashes.length
  };

  // Write profile
  await ghPutJson(profilePath, profile, null, "create profile");

  // Write chunk hashes
  for(let i=0;i<hashes.length;i++){
    const chunkPath = `users/${userId}/auth/chunk-${pad6(i+1)}.json`;
    const obj = { v:1, idx:i+1, hashHex: hashes[i] };
    await ghPutJson(chunkPath, obj, null, "auth chunk");
  }

  // Update index
  idx.obj.byUsernameLower[uLower] = userId;
  idx.obj.updatedAt = Date.now();
  await ghPutJson("users/index.json", idx.obj, idx.sha, "register user index");

  // Save session device-bound
  session = { userId, username, loginAt: Date.now() };
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  applySessionToUi();
}

async function loginUser(username, password){
  if(!PWD_DICT_READY) throw new Error("Password dictionary not ready.");
  const uLower = normalizeUsername(username);
  if(!uLower) throw new Error("Username required.");

  const valid = validatePasswordWithDict(password);
  if(!valid.ok) throw new Error(valid.reason);

  const idx = await ensureUsersIndex();
  const userId = idx?.obj?.byUsernameLower?.[uLower];
  if(!userId) throw new Error("User not found.");

  const prof = await ghGetJsonWithSha(`users/${userId}/profile.json`);
  if(!prof.ok || !prof.obj) throw new Error("Profile missing.");

  const salt = prof.obj.salt;
  const authChunks = prof.obj.authChunks || 0;
  if(!salt || authChunks<=0) throw new Error("Profile invalid (missing salt/authChunks).");

  const stream = passwordToNumericStream(password);
  const chunks = splitStream(stream, 500);
  const hashes = await hashChunks(chunks, salt);

  if(hashes.length !== authChunks) throw new Error("Password mismatch (chunk count).");

  for(let i=0;i<authChunks;i++){
    const chk = await ghGetJsonWithSha(`users/${userId}/auth/chunk-${pad6(i+1)}.json`);
    if(!chk.ok || !chk.obj) throw new Error("Auth data missing.");
    if(chk.obj.hashHex !== hashes[i]) throw new Error("Password incorrect.");
  }

  session = { userId, username: prof.obj.username || username, loginAt: Date.now() };
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  applySessionToUi();
}

function logout(){
  session = null;
  localStorage.removeItem(SESSION_KEY);
  applySessionToUi();
}

function loadSessionFromStorage(){
  try{
    const raw = localStorage.getItem(SESSION_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(s?.userId && s?.username) session = s;
  }catch(_){}
}

function applySessionToUi(){
  if(session){
    authPill.textContent = `@${session.username}`;
    loginBtn.style.display = "none";
    registerBtn.style.display = "none";
    logoutBtn.style.display = "";
    browseRoomsBtn.style.display = "";
    // Helpful default display name
    if(!nameInput.value.trim()) nameInput.value = session.username;
    // Load last joined room
    loadLastJoinedRoom();
  }else{
    authPill.textContent = "Guest";
    loginBtn.style.display = "";
    registerBtn.style.display = "";
    logoutBtn.style.display = "none";
    browseRoomsBtn.style.display = "none";
  }
}

/* ============================================================
   === ROOM BROWSER & DISCOVERY ===
   ============================================================ */
const LAST_ROOM_KEY = "cp2p_last_room_v1";

function saveLastJoinedRoom(roomName){
  try{
    const data = { room: roomName, userId: session?.userId, timestamp: Date.now() };
    localStorage.setItem(LAST_ROOM_KEY, JSON.stringify(data));
  }catch(_){}
}

function loadLastJoinedRoom(){
  try{
    const raw = localStorage.getItem(LAST_ROOM_KEY);
    if(!raw) return null;
    const data = JSON.parse(raw);
    // Only use if same user and within last 7 days
    if(data.userId === session?.userId && (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000)){
      if(data.room && !roomInput.value.trim()){
        roomInput.value = data.room;
        roomInput.setAttribute('placeholder', `Last: ${data.room}`);
      }
      return data.room;
    }
  }catch(_){}
  return null;
}

async function discoverRooms(){
  try{
    // List all rooms from the rooms directory
    const listed = await ghListDir(ROOMS_DIR);
    if(!listed.ok) return [];
    
    const rooms = [];
    for(const item of listed.items){
      if(item.type !== 'file' || !item.name.endsWith('.json')) continue;
      const roomName = item.name.replace('.json', '');
      // Master files are now in master-rooms/ folder, so no need to skip them here
      
      // Get room manifest to check if it's V3
      const manifest = await readManifestSmart(roomName);
      if(manifest.ok && manifest.obj){
        rooms.push({
          name: roomName,
          totalMessages: manifest.obj.totalMessages || 0,
          updatedAt: manifest.obj.updatedAt || 0
        });
      }
    }
    
    return rooms;
  }catch(e){
    console.error('[discoverRooms ERROR]', e);
    return [];
  }
}

async function getRoomActiveUsers(roomName){
  try{
    const dir = await ghListDir(`${ROOMS_META_DIR}/${roomName}/presence`);
    if(!dir.ok) return { active: 0, recent: 0, users: [] };
    
    const now = Date.now();
    let active = 0;
    let recent = 0;
    const users = [];
    
    for(const item of dir.items){
      if(item.type !== 'file' || !item.name.endsWith('.json')) continue;
      
      const got = await ghGetJsonWithSha(`${ROOMS_META_DIR}/${roomName}/presence/${item.name}`);
      if(got.ok && got.obj){
        const p = got.obj;
        const lastActive = p.lastActiveAt || p.lastSeenAt || 0;
        
        if(now - lastActive < 30_000){ // 30 seconds = active
          active++;
          users.push({ username: p.username || p.userId, status: 'active' });
        }else if(now - lastActive < PRESENCE_RECENT_MS){ // 5 min = recent
          recent++;
          users.push({ username: p.username || p.userId, status: 'recent' });
        }
      }
    }
    
    return { active, recent, users };
  }catch(e){
    console.error('[getRoomActiveUsers ERROR]', e);
    return { active: 0, recent: 0, users: [] };
  }
}

async function openRoomBrowser(){
  ensureModalDom();
  const overlay = document.getElementById('modalOverlay');
  const titleEl = document.getElementById('modalTitle');
  const bodyEl = document.getElementById('modalBody');
  const okBtn = document.getElementById('modalOk');
  const cancelBtn = document.getElementById('modalCancel');
  
  titleEl.textContent = '\uD83D\uDCC1 Browse Rooms';
  bodyEl.innerHTML = '<div style="text-align:center;padding:20px;color:var(--muted)">Loading rooms...</div>';
  okBtn.style.display = 'none';
  cancelBtn.textContent = 'Close';
  overlay.classList.remove('modal-hidden');
  
  // Load rooms and presence data
  const rooms = await discoverRooms();
  const lastRoom = loadLastJoinedRoom();
  
  if(rooms.length === 0){
    bodyEl.innerHTML = '<div class="empty-rooms">\uD83C\uDF10 No rooms found.<br>Create one by joining a new room name!</div>';
    return;
  }
  
  // Get presence for each room (in parallel batches of 3)
  const roomsWithPresence = [];
  for(let i = 0; i < rooms.length; i += 3){
    const batch = rooms.slice(i, i + 3);
    const results = await Promise.all(
      batch.map(async room => ({
        ...room,
        presence: await getRoomActiveUsers(room.name)
      }))
    );
    roomsWithPresence.push(...results);
  }
  
  // Sort: last joined first, then by active users, then by recent activity
  roomsWithPresence.sort((a, b) => {
    if(a.name === lastRoom) return -1;
    if(b.name === lastRoom) return 1;
    if(a.presence.active !== b.presence.active) return b.presence.active - a.presence.active;
    if(a.presence.recent !== b.presence.recent) return b.presence.recent - a.presence.recent;
    return b.updatedAt - a.updatedAt;
  });
  
  // Render room list
  const listDiv = document.createElement('div');
  listDiv.className = 'room-list';
  
  for(const room of roomsWithPresence){
    const item = document.createElement('div');
    item.className = 'room-item';
    if(room.name === lastRoom) item.classList.add('last-joined');
    
    const info = document.createElement('div');
    info.className = 'room-info';
    
    const name = document.createElement('div');
    name.className = 'room-name';
    name.textContent = `#${room.name}`;
    
    const meta = document.createElement('div');
    meta.className = 'room-meta';
    const age = room.updatedAt ? formatTimeAgo(room.updatedAt) : 'unknown';
    meta.textContent = `${room.totalMessages || 0} messages \u00b7 ${age}`;
    
    info.appendChild(name);
    info.appendChild(meta);
    
    const status = document.createElement('div');
    status.className = 'room-status';
    if(room.presence.active > 0) status.classList.add('active');
    
    const count = document.createElement('span');
    count.className = 'user-count';
    const total = room.presence.active + room.presence.recent;
    count.innerHTML = `\uD83D\uDC65 ${total}`;
    if(room.presence.active > 0){
      count.title = `${room.presence.active} active, ${room.presence.recent} recent`;
    }
    
    status.appendChild(count);
    
    item.appendChild(info);
    item.appendChild(status);
    
    item.onclick = () => {
      roomInput.value = room.name;
      closeModal(false);
      // Auto-focus join button
      setTimeout(() => joinBtn.focus(), 100);
    };
    
    listDiv.appendChild(item);
  }
  
  bodyEl.innerHTML = '';
  bodyEl.appendChild(listDiv);
}

function formatTimeAgo(timestamp){
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  if(seconds < 60) return 'just now';
  if(seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if(seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  if(seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
  return `${Math.floor(seconds / 604800)}w ago`;
}

/* ============================================================
   === ACTIVITY TRACKER ===
   ============================================================ */
window._chat_lastInteraction = Date.now();
window._chat_activeUntil = Date.now() + ACTIVE_BURST_MS;
window._chat_lastMarkAt = 0;
window._chat_fastScrollingUntil = 0;

function markInteraction(kind="unknown"){
  const now = Date.now();
  if(now - window._chat_lastMarkAt < INTERACTION_THROTTLE_MS) return;
  window._chat_lastMarkAt = now;
  window._chat_lastInteraction = now;
  window._chat_activeUntil = now + ACTIVE_BURST_MS;

  // Presence: if we were idle, flip online=true once
  if(presenceState.inRoom && presenceState.isIdle){
    presenceSetOnline(true, "interaction");
  }
  
  // Trigger poll check on interaction (if in room and not already polling)
  if(running && currentRoom && !pollInFlight){
    clearTimeout(pollTimer);
    scheduleNextPoll(parseInt(pollInput.value||POLL_MS_INTERACTION,10));
  }
}

function isActiveNow(){
  const now = Date.now();
  return (now <= window._chat_activeUntil) || (now - window._chat_lastInteraction <= IDLE_THRESHOLD_MS);
}

function installInteractionListeners(){
  const opts = { passive:true };

  // Pointer / mouse / keyboard
  ["pointerdown","pointermove","pointerup","click","wheel","scroll","keydown"].forEach(ev=>{
    window.addEventListener(ev, ()=>markInteraction(ev), opts);
  });

  // Touch events (tap, swipe, drag)
  ["touchstart","touchmove","touchend","touchcancel"].forEach(ev=>{
    window.addEventListener(ev, ()=>markInteraction(ev), opts);
  });

  // Long-press/hold (>= 350ms)
  let holdTimer = null;
  window.addEventListener("touchstart", ()=>{
    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>markInteraction("long-press"), 350);
  }, opts);
  window.addEventListener("touchend", ()=>clearTimeout(holdTimer), opts);
  
  // Mobile gesture detection: swipe
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  
  window.addEventListener("touchstart", (e)=>{
    touchStartX = e.touches[0]?.clientX || 0;
    touchStartY = e.touches[0]?.clientY || 0;
    touchStartTime = Date.now();
  }, opts);
  
  window.addEventListener("touchend", (e)=>{
    const touchEndX = e.changedTouches[0]?.clientX || 0;
    const touchEndY = e.changedTouches[0]?.clientY || 0;
    const deltaX = Math.abs(touchEndX - touchStartX);
    const deltaY = Math.abs(touchEndY - touchStartY);
    const deltaTime = Date.now() - touchStartTime;
    
    // Detect swipe (fast gesture > 50px in < 500ms)
    if(deltaTime < 500 && (deltaX > 50 || deltaY > 50)){
      markInteraction("swipe");
    }
  }, opts);
  
  // Pinch/zoom gesture (indicates engagement)
  window.addEventListener("gesturestart", ()=>markInteraction("pinch"), opts);
  window.addEventListener("gesturechange", ()=>markInteraction("pinch"), opts);
  
  // Orientation change (user rotated device)
  window.addEventListener("orientationchange", ()=>{
    markInteraction("orientation");
    // Check messages after orientation change
    if(running && currentRoom && !pollInFlight){
      setTimeout(pollLoop, 200);
    }
  });
  
  // Focus events (keyboard opened/closed on mobile)
  msgInput.addEventListener("focus", ()=>{
    markInteraction("input-focus");
    startTypingMode();
  });
  
  msgInput.addEventListener("blur", ()=>{
    markInteraction("input-blur");
  });

  // Fast-scroll detector for read receipts
  let lastScrollTop = 0;
  let lastT = performance.now();
  messagesEl.addEventListener("scroll", ()=>{
    const now = performance.now();
    const dt = Math.max(1, now - lastT);
    const dy = Math.abs(messagesEl.scrollTop - lastScrollTop);
    const speed = (dy / dt) * 1000; // px/s
    lastScrollTop = messagesEl.scrollTop;
    lastT = now;
    if(speed > 1600){ // threshold
      window._chat_fastScrollingUntil = Date.now() + 300;
    }
  }, opts);
}

/* ============================================================
   ROOM STATE
   ============================================================ */
let currentRoom = null;
let running = false;

// Last known master state
let masterLastValue = false;

// Poll loop guards
let pollTimer = null;
let pollInFlight = false;
let isTypingMode = false;
let typingTimeout = null;
let lastTypingAt = 0;
let burstModeUntil = 0;  // Timestamp for burst mode end

// V3 loaded window
let loadedCellsMin = null;
let loadedCellsMax = null;
let loadedMessages = []; // currently displayed (newest last)
let roomIndex = null;    // rooms-cells/<room>/index.json (cached)
let roomIndexSha = null;

// Presence cache
let presenceCache = new Map(); // userId -> obj
let presenceDirSha = null;
let lastPresenceRefreshAt = 0;

// Read receipts throttling
let lastReadWriteAt = 0;

/* ============================================================
   === V3 AUTO MIGRATION ===
   ============================================================ */

function manifestPath(roomName){ return `${ROOMS_DIR}/${roomName}.json`; }
function masterPath(roomName){ return `${MASTER_ROOMS_DIR}/${roomName}.json`; }

function roomIndexPath(roomName){ return `${ROOMS_CELLS_BASE}/${roomName}/index.json`; }
function boxesIndexPath(roomName){ return `${ROOMS_CELLS_BASE}/${roomName}/boxes/boxes-index.json`; }
function boxPath(roomName, boxNum){ return `${ROOMS_CELLS_BASE}/${roomName}/boxes/box-${padBox(boxNum)}.json`; }
function cellPath(roomName, cellNum){ return `${ROOMS_CELLS_BASE}/${roomName}/cells/cell-${pad6(cellNum)}.json`; }

function presencePath(roomName, userId){ return `${ROOMS_META_DIR}/${roomName}/presence/${userId}.json`; }

async function readManifestSmart(roomName){
  // Prefer raw for low-rate reads; fallback to API for 404/errors
  const raw = await rawGetText(manifestPath(roomName));
  if(raw.ok){
    try{ return { ok:true, obj: JSON.parse(raw.text), source:"raw" }; }catch(e){}
  }
  const api = await ghGetJsonWithSha(manifestPath(roomName));
  if(api.ok && api.obj) return { ok:true, obj: api.obj, source:"api", sha: api.sha };
  return { ok:false, status: raw.status || api.status || 0 };
}

async function ensureRoomV3(roomName){
  // If missing -> create V3 manifest + initial indexes + first cell + first box
  const got = await ghGetJsonWithSha(manifestPath(roomName));
  if(got.status === 404){
    const now = Date.now();

    const manifest = {
      v: MANIFEST_VERSION_V3,
      room: roomName,
      createdAt: now,
      updatedAt: now,
      storage: {
        cellMaxMessages: CELL_MAX_MESSAGES,
        cellsPerBox: CELLS_PER_BOX
      },
      paths: {
        roomIndex: roomIndexPath(roomName),
        boxesIndex: boxesIndexPath(roomName),
        cellsDir: `${ROOMS_CELLS_BASE}/${roomName}/cells/`,
        boxesDir: `${ROOMS_CELLS_BASE}/${roomName}/boxes/`
      }
    };

    // init room index
    const idxObj = {
      v:3,
      room: roomName,
      latestCell: 1,
      totalMessages: 0,
      updatedAt: now
    };

    const boxesIdxObj = {
      v:3,
      room: roomName,
      boxes: [ { box: 1, startCell: 1, endCell: 1, updatedAt: now } ],
      updatedAt: now
    };

    const boxObj = { v:3, room: roomName, box:1, startCell:1, endCell:1, cellCount:1, updatedAt: now };

    // create files (order doesn't matter, but keep clean)
    await ghPutJson(roomIndexPath(roomName), idxObj, null, "init room index");
    await ghPutJson(boxesIndexPath(roomName), boxesIdxObj, null, "init boxes index");
    await ghPutJson(boxPath(roomName, 1), boxObj, null, "init box");
    await ghPutJson(cellPath(roomName, 1), [], null, "init cell");
    await ghPutJson(manifestPath(roomName), manifest, null, "init room manifest v3");

    // Ensure master file exists (false)
    await ensureMasterExists(roomName);

    log(`üÜï Room "${roomName}" created (V3).`);
    return { ok:true, manifest };
  }

  // If exists but not v3 -> migrate silently
  if(got.ok && got.obj && got.obj.v === 3){
    await ensureMasterExists(roomName);
    return { ok:true, manifest: got.obj };
  }

  // Migration path: we will attempt to load all messages and rebuild V3 structure
  log(`üîß Migrating room "${roomName}" to V3 (silent)‚Ä¶`, "INFO");
  const all = await loadAllMessagesAny(roomName, got.obj);
  await rebuildV3FromMessages(roomName, all);

  // Overwrite manifest to V3
  const now = Date.now();
  const manifest = {
    v: MANIFEST_VERSION_V3,
    room: roomName,
    createdAt: (got.obj?.createdAt || now),
    updatedAt: now,
    migratedFrom: (got.obj?.v || "legacy"),
    storage: { cellMaxMessages: CELL_MAX_MESSAGES, cellsPerBox: CELLS_PER_BOX },
    paths: {
      roomIndex: roomIndexPath(roomName),
      boxesIndex: boxesIndexPath(roomName),
      cellsDir: `${ROOMS_CELLS_BASE}/${roomName}/cells/`,
      boxesDir: `${ROOMS_CELLS_BASE}/${roomName}/boxes/`
    }
  };
  await ghPutJson(manifestPath(roomName), manifest, got.sha || null, "migrate manifest v3");
  await ensureMasterExists(roomName);

  log(`‚úÖ Migration done (${all.length} msgs).`, "INFO");
  return { ok:true, manifest };
}

async function loadAllMessagesAny(roomName, existingManifestObj){
  // 1) If rooms/<room>.json is an array (legacy), treat it as history
  if(Array.isArray(existingManifestObj)){
    return existingManifestObj.map(normalizeMessage).filter(Boolean).sort((a,b)=>a.ts-b.ts);
  }

  // 2) If manifest looks like V2 that stored messages in the manifest itself
  // (some earlier builds used rooms/<room>.json as an array)
  const got = await ghGetJsonWithSha(manifestPath(roomName));
  if(got.ok && Array.isArray(got.obj)){
    return got.obj.map(normalizeMessage).filter(Boolean).sort((a,b)=>a.ts-b.ts);
  }

  // 3) Try list cells directory (v2)
  const listed = await ghListDir(`${ROOMS_CELLS_BASE}/${roomName}/cells`);
  if(listed.ok){
    const cellFiles = listed.items
      .filter(it=>it.type==="file" && /^cell-\d{6}\.json$/.test(it.name))
      .sort((a,b)=>a.name.localeCompare(b.name));
    const out = [];
    for(const f of cellFiles){
      const gotCell = await ghGetJsonWithSha(`${ROOMS_CELLS_BASE}/${roomName}/cells/${f.name}`);
      if(gotCell.ok && Array.isArray(gotCell.obj)){
        for(const raw of gotCell.obj){
          const msg = normalizeMessage(raw);
          if(msg) out.push(msg);
        }
      }
    }
    out.sort((a,b)=>a.ts-b.ts);
    return out;
  }

  return [];
}

async function rebuildV3FromMessages(roomName, messages){
  const now = Date.now();
  // Split into cells of 4
  const cells = [];
  for(let i=0;i<messages.length;i+=CELL_MAX_MESSAGES){
    cells.push(messages.slice(i, i+CELL_MAX_MESSAGES));
  }
  const totalCells = Math.max(1, cells.length);

  // Write cells
  for(let c=1;c<=totalCells;c++){
    const arr = cells[c-1] || [];
    await ghPutJson(cellPath(roomName, c), arr, null, `migrate cell ${c}`);
  }

  // Build boxes: 100 cells per box
  const totalBoxes = Math.max(1, Math.ceil(totalCells / CELLS_PER_BOX));
  const boxesIndex = { v:3, room:roomName, boxes:[], updatedAt: now };

  for(let b=1;b<=totalBoxes;b++){
    const startCell = (b-1)*CELLS_PER_BOX + 1;
    const endCell = Math.min(totalCells, b*CELLS_PER_BOX);
    const boxObj = { v:3, room:roomName, box:b, startCell, endCell, cellCount:(endCell-startCell+1), updatedAt: now };
    await ghPutJson(boxPath(roomName,b), boxObj, null, `migrate box ${b}`);
    boxesIndex.boxes.push({ box:b, startCell, endCell, updatedAt: now });
  }
  await ghPutJson(boxesIndexPath(roomName), boxesIndex, null, "migrate boxes index");

  // Room index
  const idxObj = { v:3, room: roomName, latestCell: totalCells, totalMessages: messages.length, updatedAt: now };
  await ghPutJson(roomIndexPath(roomName), idxObj, null, "migrate room index");
}

/* ============================================================
   MESSAGE NORMALIZATION
   ============================================================ */
function normalizeMessage(raw){
  if(!raw || typeof raw !== "object") return null;
  const ts = (typeof raw.ts === "number") ? raw.ts : Date.now();
  return {
    id: raw.id || `m-${ts}-${Math.random().toString(36).slice(2,8)}`,
    room: raw.room || currentRoom || "unknown",
    sender: raw.sender || "Anon",
    userId: raw.userId || "legacy",
    ts,
    text: String(raw.text || ""),
    edited: !!raw.edited,
    editedAt: raw.editedAt || null,
    deleted: !!raw.deleted,
    createdAt: raw.createdAt || ts
  };
}

/* ============================================================
   V3 LOAD / APPEND
   ============================================================ */
async function loadRoomIndex(roomName){
  const got = await ghGetJsonWithSha(roomIndexPath(roomName));
  if(got.ok && got.obj){
    roomIndex = got.obj;
    roomIndexSha = got.sha;
    return roomIndex;
  }
  // If missing (shouldn't), rebuild from scratch empty
  const now = Date.now();
  roomIndex = { v:3, room:roomName, latestCell:1, totalMessages:0, updatedAt: now };
  const put = await ghPutJson(roomIndexPath(roomName), roomIndex, null, "repair room index");
  roomIndexSha = put.sha;
  return roomIndex;
}

async function saveRoomIndex(roomName){
  if(!roomIndex) return;
  roomIndex.updatedAt = Date.now();
  const put = await ghPutJson(roomIndexPath(roomName), roomIndex, roomIndexSha, "update room index");
  roomIndexSha = put.sha;
}

async function ensureCellExists(roomName, cellNum){
  const got = await ghGetJsonWithSha(cellPath(roomName, cellNum));
  if(got.status === 404){
    const put = await ghPutJson(cellPath(roomName, cellNum), [], null, `init cell ${cellNum}`);
    return { ok:true, arr:[], sha: put.sha || null };
  }
  if(!got.ok || !Array.isArray(got.obj)) return { ok:false, arr:[], sha:null };
  return { ok:true, arr:got.obj, sha: got.sha };
}

async function loadCellsRange(roomName, startCell, endCell){
  const out = [];
  for(let c=startCell;c<=endCell;c++){
    const got = await ghGetJsonWithSha(cellPath(roomName,c));
    if(got.ok && Array.isArray(got.obj)){
      for(const raw of got.obj){
        const msg = normalizeMessage(raw);
        if(msg) out.push(msg);
      }
    }
  }
  out.sort((a,b)=>a.ts-b.ts);
  return out;
}

async function loadLatestMessages(roomName, wantCount=50){
  await loadRoomIndex(roomName);
  const latestCell = roomIndex.latestCell || 1;
  const needCells = Math.max(1, Math.ceil(wantCount / CELL_MAX_MESSAGES));
  const startCell = Math.max(1, latestCell - needCells + 1);
  const msgs = await loadCellsRange(roomName, startCell, latestCell);
  loadedCellsMin = startCell;
  loadedCellsMax = latestCell;
  return msgs;
}

async function loadOlderByMessages(roomName, count){
  await loadRoomIndex(roomName);
  if(loadedCellsMin === null) return [];
  if(loadedCellsMin <= 1) return [];

  const needCells = Math.max(1, Math.ceil(count / CELL_MAX_MESSAGES));
  const newStart = Math.max(1, loadedCellsMin - needCells);
  const msgs = await loadCellsRange(roomName, newStart, loadedCellsMin-1);
  loadedCellsMin = newStart;
  return msgs;
}

async function appendMessageV3(roomName, msgObj){
  await loadRoomIndex(roomName);
  let cellNum = roomIndex.latestCell || 1;

  const cell = await ensureCellExists(roomName, cellNum);
  let arr = cell.arr || [];
  let sha = cell.sha;

  // If cell full -> next cell
  if(arr.length >= CELL_MAX_MESSAGES){
    cellNum += 1;
    arr = [];
    sha = null;
    roomIndex.latestCell = cellNum;

    // ensure new cell file exists
    await ghPutJson(cellPath(roomName, cellNum), [], null, `init cell ${cellNum}`);

    // update boxes structures when crossing box boundary
    await ensureBoxForCell(roomName, cellNum);
  }

  // write the cell index into the message for later edits
  msgObj.cell = cellNum;
  arr.push(msgObj);
  const put = await ghPutJson(cellPath(roomName, cellNum), arr, sha, `append msg cell ${cellNum}`);
  roomIndex.totalMessages = (roomIndex.totalMessages || 0) + 1;
  await saveRoomIndex(roomName);

  // notify master
  await saveMasterValue(roomName, true);

  return { cellNum, cellSha: put.sha };
}

async function ensureBoxForCell(roomName, cellNum){
  const boxNum = Math.max(1, Math.ceil(cellNum / CELLS_PER_BOX));
  const startCell = (boxNum-1)*CELLS_PER_BOX + 1;
  const endCell = cellNum;

  // boxes-index
  const gotIdx = await ghGetJsonWithSha(boxesIndexPath(roomName));
  let idxObj = gotIdx.ok && gotIdx.obj ? gotIdx.obj : { v:3, room:roomName, boxes:[], updatedAt: Date.now() };
  let idxSha = gotIdx.sha || null;
  if(!Array.isArray(idxObj.boxes)) idxObj.boxes = [];

  let entry = idxObj.boxes.find(b=>b.box===boxNum);
  if(!entry){
    entry = { box: boxNum, startCell, endCell, updatedAt: Date.now() };
    idxObj.boxes.push(entry);
    idxObj.boxes.sort((a,b)=>a.box-b.box);
  }else{
    entry.endCell = Math.max(entry.endCell||endCell, endCell);
    entry.updatedAt = Date.now();
  }
  idxObj.updatedAt = Date.now();
  const putIdx = await ghPutJson(boxesIndexPath(roomName), idxObj, idxSha, "update boxes-index");
  // box file
  const gotBox = await ghGetJsonWithSha(boxPath(roomName, boxNum));
  const boxObj = gotBox.ok && gotBox.obj ? gotBox.obj : { v:3, room:roomName, box:boxNum, startCell, endCell, cellCount:(endCell-startCell+1), updatedAt:Date.now() };
  boxObj.startCell = startCell;
  boxObj.endCell = Math.max(boxObj.endCell||endCell, endCell);
  boxObj.cellCount = (boxObj.endCell - boxObj.startCell + 1);
  boxObj.updatedAt = Date.now();
  await ghPutJson(boxPath(roomName, boxNum), boxObj, gotBox.sha||null, "update box");
}

/* ============================================================
   MASTER (raw read + API fallback) + POLL LOOP (activity/idle)
   ============================================================ */
async function ensureMasterExists(roomName){
  // Only use new path: master-rooms/<room>.json
  const path = masterPath(roomName);
  
  // Check if exists via raw read (fast)
  const raw = await rawGetText(path);
  if(raw.ok) return;
  
  // Create new master file if doesn't exist
  const got = await ghGetJsonWithSha(path);
  if(got.status === 404){
    await ghPutJson(path, false, null, "init master");
  }
}

async function readMasterValue(roomName){
  const path = masterPath(roomName);
  
  // 1) Try raw read (fast)
  const raw = await rawGetText(path);
  if(raw.ok){
    const t = raw.text.trim().toLowerCase();
    if(t==="true" || t==="false") return { ok:true, value: t==="true", source:"raw" };
    // Some builds store JSON "true"
    try{
      const v = JSON.parse(raw.text);
      return { ok:true, value: !!v, source:"raw-json" };
    }catch(_){}
  }

  // 2) Fallback to API
  try{
    const api = await ghGetJsonWithSha(path);
    if(api.ok){
      return { ok:true, value: !!api.obj, source:"api" };
    }
    return { ok:false, status: api.status, value:false, source:"api" };
  }catch(e){
    return { ok:false, status:0, value:false, source:"error" };
  }
}

async function saveMasterValue(roomName, value){
  const p = masterPath(roomName);
  const got = await ghGetJsonWithSha(p);
  const sha = got.ok ? got.sha : null;
  await ghPutJson(p, !!value, sha, "set master");
}

function scheduleNextPoll(ms){
  clearTimeout(pollTimer);
  pollTimer = setTimeout(pollLoop, ms);
}

// Typing mode: enable fast polling when user is typing
function startTypingMode(){
  const now = Date.now();
  lastTypingAt = now;
  
  if(!isTypingMode){
    isTypingMode = true;
    // Trigger immediate check when typing starts
    clearTimeout(pollTimer);
    setTimeout(pollLoop, 0);
  }
  
  // Auto-disable typing mode after 3 seconds of no typing
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    isTypingMode = false;
    // One final check when typing stops
    if(running && currentRoom) pollLoop();
  }, 3000);
}

function stopTypingMode(){
  clearTimeout(typingTimeout);
  isTypingMode = false;
}

async function pollLoop(){
  try{
    if(!running || !currentRoom) return;
    if(pollInFlight) return;

    const now = Date.now();
    const active = isActiveNow();
    
    // Handle idle state
    if(!active){
      if(presenceState.inRoom && !presenceState.isIdle){
        await presenceSetOnline(false, "idle");
      }
      // No more polling when idle - will resume on interaction
      return;
    }

    // Active: ensure presence online
    if(presenceState.inRoom && presenceState.isIdle){
      await presenceSetOnline(true, "active");
    }

    pollInFlight = true;

    // Read master flag (lightweight check)
    const master = await readMasterValue(currentRoom);
    if(!master.ok){
      pollInFlight = false;
      return;
    }

    // ONLY sync if master=true (someone sent a message)
    if(master.value){
      await syncLatestFromStorage();
      await sleep(100);
      await saveMasterValue(currentRoom, false);
      
      // Enter burst mode: check frequently for quick back-and-forth
      burstModeUntil = now + POLL_BURST_DURATION;
    }else{
      // No new messages, just refresh presence
      await maybeRefreshPresence();
    }

    // Smart scheduling:
    // - Burst mode (after message received): aggressive polling for 10s
    // - Typing mode: check while typing
    // - Otherwise: NO automatic polling (wait for interaction)
    
    const inBurstMode = now < burstModeUntil;
    
    if(inBurstMode || isTypingMode){
      // Continue polling during conversation
      const interval = inBurstMode ? POLL_MS_BURST : POLL_MS_INTERACTION;
      scheduleNextPoll(interval);
    }
    // else: stop polling, wait for next interaction
    
  }catch(e){
    console.error("[pollLoop ERROR]", e);
  }finally{
    pollInFlight = false;
  }
}

/* ============================================================
   RENDER + LAZY LOAD (gesture speed based)
   ============================================================ */
function renderAll(messages){
  messagesEl.innerHTML = "";
  loadedMessages = [];
  for(const m of messages) addMessageToDom(m, true);
  messagesEl.scrollTop = messagesEl.scrollHeight;
  setupReadObserver(); // attach read receipts to current DOM nodes
}

function addMessageToDom(m, silent=false, prepend=false){
  // Store to loaded list
  if(prepend) loadedMessages.unshift(m);
  else loadedMessages.push(m);

  const wrap = document.createElement("div");
  wrap.className = "msg" + ((session && m.userId===session.userId) ? " me" : "");
  wrap.dataset.msgId = m.id;
  if(m.cell) wrap.dataset.cell = String(m.cell);
  wrap.dataset.ts = String(m.ts);

  const text = document.createElement("div");
  text.className = "text";
  text.textContent = m.deleted ? "[deleted]" : m.text;

  const meta = document.createElement("div");
  meta.className = "meta";
  const d = new Date(m.ts);
  const hh = String(d.getHours()).padStart(2,"0");
  const mm = String(d.getMinutes()).padStart(2,"0");
  const timeText = document.createElement("span");
  timeText.textContent = `${hh}:${mm} ¬∑ ${m.sender}${m.edited ? " ¬∑ edited":""}`;
  meta.appendChild(timeText);

  // Message status indicator (for own messages only)
  if(session && m.userId === session.userId){
    const status = document.createElement("span");
    status.className = `msg-status status-${m.status || 'sending'}`;
    status.dataset.msgId = m.id;
    meta.appendChild(status);

    // Retry button for failed messages
    if(m.status === 'failed'){
      const retry = document.createElement("button");
      retry.className = "msg-retry";
      retry.textContent = "Retry";
      retry.onclick = (e) => { e.stopPropagation(); retryMessage(m); };
      meta.appendChild(retry);
      wrap.classList.add('msg-failed');
    }
  }

  const reads = document.createElement("div");
  reads.className = "reads";
  reads.textContent = ""; // filled by updateReadBadges()

  wrap.appendChild(text);
  wrap.appendChild(meta);
  wrap.appendChild(reads);

  // Actions (edit/delete) for my messages
  if(session && m.userId === session.userId){
    const actions = document.createElement('div');
    actions.className = 'msg-actions';

    const editBtn = document.createElement('button');
    editBtn.textContent = 'Edit';
    editBtn.addEventListener('click', (e)=>{ e.stopPropagation(); editMessageById(m.id); });

    const delBtn = document.createElement('button');
    delBtn.textContent = 'Delete';
    delBtn.className = 'danger';
    delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); deleteMessageById(m.id); });

    actions.appendChild(editBtn);
    actions.appendChild(delBtn);
    wrap.appendChild(actions);
  }

  if(prepend){
    messagesEl.insertBefore(wrap, messagesEl.firstChild);
  }else{
    messagesEl.appendChild(wrap);
    if(!silent) messagesEl.scrollTop = messagesEl.scrollHeight;
  }

  // Observe for read receipts
  if(readObserver) readObserver.observe(wrap);
}

function clearView(){
  messagesEl.innerHTML = "";
  loadedMessages = [];
  loadedCellsMin = null;
  loadedCellsMax = null;
  log("üßπ Cleared view (history still in GitHub).","INFO");
}

function pickLoadCountFromScrollSpeed(pxPerSec){
  // Mobile flick / fast wheel -> bigger batch
  if(pxPerSec >= 2400) return 100;
  if(pxPerSec >= 1200) return 50;
  return 20;
}

function installLazyLoader(){
  let lastTop = messagesEl.scrollTop;
  let lastT = performance.now();

  messagesEl.addEventListener("scroll", async ()=>{
    // If near top -> load older
    if(messagesEl.scrollTop > 90) return;

    const now = performance.now();
    const dt = Math.max(1, now-lastT);
    const dy = Math.abs(messagesEl.scrollTop-lastTop);
    const speed = (dy/dt)*1000; // px/s
    lastTop = messagesEl.scrollTop;
    lastT = now;

    const want = pickLoadCountFromScrollSpeed(speed);

    // Preserve current viewport anchor so content doesn't jump
    const prevHeight = messagesEl.scrollHeight;

    const older = await loadOlderByMessages(currentRoom, want);
    if(!older.length) return;

    // Prepend older
    for(let i=older.length-1;i>=0;i--){
      addMessageToDom(older[i], true, true);
    }
    // Keep scroll position steady (so user doesn't get yeeted)
    const newHeight = messagesEl.scrollHeight;
    messagesEl.scrollTop = newHeight - prevHeight;
    setupReadObserver();
    updateReadBadges();
  }, { passive:true });
}

/* ============================================================
   MESSAGE EDIT / DELETE helpers
   - editMessageById: allow owner to change text; write back to correct cell
   - deleteMessageById: mark deleted=true (delete for everyone)
 ============================================================ */

async function findMessageLocation(msgId){
  // Try loadedMessages first
  for(const m of loadedMessages){
    if(m.id === msgId){
      // If message has cell stored, return quickly
      if(m.cell) return { cell: m.cell, msg: m };
    }
  }

  // Fallback: scan last few cells from roomIndex.latestCell downwards
  await loadRoomIndex(currentRoom);
  const latest = roomIndex?.latestCell || 1;
  const scanCount = Math.min(6, latest); // scan up to last 6 cells
  for(let c = latest; c >= Math.max(1, latest - scanCount + 1); c--){
    try{
      const got = await ghGetJsonWithSha(cellPath(currentRoom, c));
      if(!got.ok || !Array.isArray(got.obj)) continue;
      for(const raw of got.obj){
        if(raw && raw.id === msgId){
          const msg = normalizeMessage(raw);
          msg.cell = c;
          return { cell: c, msg, cellArr: got.obj, cellSha: got.sha };
        }
      }
    }catch(_){/* ignore */}
  }
  return null;
}

/* =========================
   Modal UI (v3 style) ‚Äî openModal / closeModal / showEditModal / showConfirmModal
   These avoid alerts/prompts and use the DOM modal overlay.
   Requires elements with ids: modalOverlay, modalTitle, modalBody, modalOk, modalCancel, modalClose
   If not present, we create a minimal modal markup now.
========================= */

let _modalResolve = null;
function ensureModalDom(){
  if(document.getElementById('modalOverlay')) return;
  const html = `
  <div id="modalOverlay" class="modal-overlay modal-hidden" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-header">
        <div id="modalTitle" class="modal-title">Modal</div>
        <button id="modalClose" class="modal-close">‚úï</button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer">
        <button id="modalCancel" class="btn-ghost">Cancel</button>
        <button id="modalOk" class="primary">OK</button>
      </div>
    </div>
  </div>`;
  document.body.insertAdjacentHTML('beforeend', html);
  const mo = document.getElementById('modalOverlay');
  document.getElementById('modalClose').addEventListener('click', ()=> closeModal(false));
  document.getElementById('modalCancel').addEventListener('click', ()=> closeModal(false));
  document.getElementById('modalOk').addEventListener('click', ()=> closeModal(true));
}

function openModal({ title, bodyNode, okText='OK', cancelText='Cancel', showCancel=true }){
  ensureModalDom();
  const overlay = document.getElementById('modalOverlay');
  const titleEl = document.getElementById('modalTitle');
  const bodyEl = document.getElementById('modalBody');
  const okBtn = document.getElementById('modalOk');
  const cancelBtn = document.getElementById('modalCancel');

  titleEl.textContent = title || 'Modal';
  bodyEl.innerHTML = '';
  if(bodyNode) bodyEl.appendChild(bodyNode);
  okBtn.textContent = okText;
  cancelBtn.textContent = cancelText;
  cancelBtn.style.display = showCancel ? '' : 'none';
  overlay.classList.remove('modal-hidden');
  return new Promise((resolve)=>{ _modalResolve = resolve; });
}

function closeModal(result){
  const overlay = document.getElementById('modalOverlay');
  if(overlay) overlay.classList.add('modal-hidden');
  try{ if(_modalResolve) _modalResolve(result); }finally{ _modalResolve = null; }
}

async function showEditModal(oldText){
  const wrap = document.createElement('div');
  const p = document.createElement('p'); p.textContent = 'Edit your message:'; wrap.appendChild(p);
  const ta = document.createElement('textarea'); ta.value = oldText || ''; ta.style.width = '100%'; ta.style.minHeight = '120px';
  wrap.appendChild(ta);
  const ok = await openModal({ title:'Edit message', bodyNode: wrap, okText:'Save', cancelText:'Cancel', showCancel:true });
  if(!ok) return null;
  const val = (ta.value||'').trim();
  return val.length ? val : null;
}

async function showConfirmModal(text){
  const wrap = document.createElement('div');
  const p = document.createElement('p'); p.textContent = text || 'Confirm?'; wrap.appendChild(p);
  const ok = await openModal({ title:'Confirm', bodyNode: wrap, okText:'Yes', cancelText:'No', showCancel:true });
  return !!ok;
}

async function editMessageById(msgId){
  if(!currentRoom) return;
  // Find message in loadedMessages or storage
  const loc = await findMessageLocation(msgId);
  if(!loc) { log('Message not found','WARN'); return; }
  const orig = loc.msg;

  const userId = session?.userId || localGuest.userId;
  if(orig.userId !== userId){ log('You can only edit your own messages','WARN'); return; }

  const newText = await showEditModal(orig.text || '');
  if(!newText) return; // canceled or empty
  const trimmed = String(newText).trim();

  // Load the cell array if we don't have it
  let cellArr = loc.cellArr;
  let cellSha = loc.cellSha;
  if(!cellArr){
    const got = await ghGetJsonWithSha(cellPath(currentRoom, loc.cell));
    if(!got.ok || !Array.isArray(got.obj)){ showToast('Failed to read cell for edit', 'error'); return; }
    cellArr = got.obj;
    cellSha = got.sha;
  }

  // Find message inside cellArr
  const idx = cellArr.findIndex(x => x && x.id === msgId);
  if(idx === -1){ showToast('Message not found in storage', 'error'); return; }

  // Update fields
  cellArr[idx].text = trimmed;
  cellArr[idx].edited = true;
  cellArr[idx].editedAt = Date.now();
  cellArr[idx].editedBy = userId;

  // PUT back
  try{
    const put = await ghPutJson(cellPath(currentRoom, loc.cell), cellArr, cellSha, `edit msg ${msgId}`);
    // Update in-memory loadedMessages and DOM
    for(const m of loadedMessages){ if(m.id === msgId){ m.text = trimmed; m.edited = true; m.editedAt = cellArr[idx].editedAt; } }
    const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
    if(el){
      const textEl = el.querySelector('.text'); if(textEl) textEl.textContent = trimmed;
      const meta = el.querySelector('.meta'); if(meta){
        const d = new Date(cellArr[idx].ts||Date.now());
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        meta.textContent = `${hh}:${mm} ¬∑ ${cellArr[idx].sender} ¬∑ edited`;
      }
    }
    showToast('Message edited successfully', 'success');
  }catch(e){ console.error('[editMessage ERROR]', e); showToast('Edit failed: '+String(e), 'error'); }
}

async function deleteMessageById(msgId){
  if(!currentRoom) return;
  const loc = await findMessageLocation(msgId);
  if(!loc) { log('Message not found','WARN'); return; }
  const orig = loc.msg;
  const userId = session?.userId || localGuest.userId;
  if(orig.userId !== userId){ log('You can only delete your own messages','WARN'); return; }

  const ok = await showConfirmModal('Delete this message for everyone? This will mark it deleted.');
  if(!ok) return;

  let cellArr = loc.cellArr;
  let cellSha = loc.cellSha;
  if(!cellArr){
    const got = await ghGetJsonWithSha(cellPath(currentRoom, loc.cell));
    if(!got.ok || !Array.isArray(got.obj)){ showToast('Failed to read cell for delete', 'error'); return; }
    cellArr = got.obj;
    cellSha = got.sha;
  }

  const idx = cellArr.findIndex(x => x && x.id === msgId);
  if(idx === -1){ showToast('Message not found in storage', 'error'); return; }

  cellArr[idx].deleted = true;
  cellArr[idx].deletedAt = Date.now();
  cellArr[idx].deletedBy = userId;

  try{
    const put = await ghPutJson(cellPath(currentRoom, loc.cell), cellArr, cellSha, `delete msg ${msgId}`);
    // Update in-memory and DOM
    for(const m of loadedMessages){ if(m.id === msgId){ m.deleted = true; } }
    const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
    if(el){
      const textEl = el.querySelector('.text'); if(textEl) textEl.textContent = '[deleted]';
      const meta = el.querySelector('.meta'); if(meta){ meta.textContent = `deleted`; }
    }
    log('Message deleted','INFO');
    showToast('Message deleted successfully', 'success');
  }catch(e){ console.error('[deleteMessage ERROR]', e); log('Delete failed: '+String(e),'ERROR'); showToast('Delete failed: '+String(e), 'error'); }
}

/* ============================================================
   === PRESENCE ===
   ============================================================ */
const presenceState = {
  inRoom:false,
  isIdle:true,
  heartbeatTimer:null,
  lastOnlineWriteAt:0,
  lastPresenceWriteSha:null
};

async function presenceWrite(obj){
  if(!currentRoom) return;
  const p = presencePath(currentRoom, obj.userId);
  const got = await ghGetJsonWithSha(p);
  const sha = got.ok ? got.sha : null;
  await ghPutJson(p, obj, sha, "presence");
}

async function presenceSetOnline(online, reason=""){
  if(!currentRoom) return;

  const now = Date.now();
  const userId = session?.userId || localGuest.userId;
  const username = session?.username || localGuest.name || "Guest";

  const base = presenceCache.get(userId) || {
    v:1, room: currentRoom, userId, username,
    online:false,
    lastSeenAt: now,
    lastActiveAt: now,
    lastReadTs: 0,
    lastReadMsgId: null,
    device: { ua: navigator.userAgent, platform: navigator.platform || "" }
  };

  if(online){
    base.online = true;
    base.lastActiveAt = now;
    base.lastSeenAt = now;
    presenceState.isIdle = false;

    // Start heartbeat if not running
    if(!presenceState.heartbeatTimer){
      presenceState.heartbeatTimer = setInterval(async ()=>{
        if(!running || !currentRoom) return;
        if(!isActiveNow()){
          // Stop on idle
          await presenceSetOnline(false, "idle-heartbeat");
          return;
        }
        await presenceSetOnline(true, "heartbeat");
      }, PRESENCE_ACTIVE_HEARTBEAT_MS);
    }
  }else{
    base.online = false;
    base.lastSeenAt = now;
    presenceState.isIdle = true;

    // Stop heartbeat
    if(presenceState.heartbeatTimer){
      clearInterval(presenceState.heartbeatTimer);
      presenceState.heartbeatTimer = null;
    }
  }

  // Throttle "online/offline" writes so we don't spam
  if(now - presenceState.lastOnlineWriteAt < 700 && reason!=="heartbeat") return;
  presenceState.lastOnlineWriteAt = now;

  presenceCache.set(userId, base);
  await presenceWrite(base);
}

async function refreshPresence(){
  if(!currentRoom) return;

  const dir = await ghListDir(`${ROOMS_META_DIR}/${currentRoom}/presence`);
  if(!dir.ok) return;

  // Pull each presence file (small)
  const now = Date.now();
  const next = new Map();

  for(const it of dir.items){
    if(it.type!=="file" || !it.name.endsWith(".json")) continue;
    const got = await ghGetJsonWithSha(`${ROOMS_META_DIR}/${currentRoom}/presence/${it.name}`);
    if(got.ok && got.obj && got.obj.userId){
      next.set(got.obj.userId, got.obj);
    }
  }

  presenceCache = next;
  lastPresenceRefreshAt = now;
  renderPresenceSummary();
  updateReadBadges();
}

async function maybeRefreshPresence(){
  const now = Date.now();
  if(now - lastPresenceRefreshAt < 10_000) return; // at most every 10s active
  await refreshPresence();
}

function renderPresenceSummary(){
  if(!currentRoom) return;
  const now = Date.now();
  let active=0, recent=0;
  for(const p of presenceCache.values()){
    const lastActiveAt = p.lastActiveAt||0;
    const lastSeenAt = p.lastSeenAt||0;
    if(now - lastActiveAt < 10_000) active++;
    else if(now - lastSeenAt < PRESENCE_RECENT_MS) recent++;
  }
  presenceSummary.textContent = `presence: ${active} active ¬∑ ${recent} recent`;
}

/* ============================================================
   === READ RECEIPTS ===
   ============================================================ */
let readObserver = null;
let readHoldTimers = new Map(); // msgId -> timer

function setupReadObserver(){
  if(!messagesEl) return;
  if(readObserver) return; // install once

  readObserver = new IntersectionObserver((entries)=>{
    for(const ent of entries){
      const node = ent.target;
      const msgId = node.dataset.msgId;
      const ts = Number(node.dataset.ts||0);

      // Only consider if visible enough
      if(ent.intersectionRatio < 0.60){
        // cancel pending
        if(readHoldTimers.has(msgId)){
          clearTimeout(readHoldTimers.get(msgId));
          readHoldTimers.delete(msgId);
        }
        continue;
      }

      // If fast scrolling, ignore
      if(Date.now() < window._chat_fastScrollingUntil) continue;

      // Hold 250ms visible
      if(readHoldTimers.has(msgId)) continue;

      const t = setTimeout(async ()=>{
        readHoldTimers.delete(msgId);
        // Re-check visibility by bounding box within container
        if(Date.now() < window._chat_fastScrollingUntil) return;

        // Zone weighting (TOP/CENTER/BOTTOM) ‚Äì we only store monotonic lastReadTs
        const rect = node.getBoundingClientRect();
        const rootRect = messagesEl.getBoundingClientRect();
        const centerY = rect.top + rect.height/2;
        const rel = (centerY - rootRect.top) / Math.max(1, rootRect.height);
        // Zones: [0..0.33]=TOP, (0.33..0.66]=CENTER, (0.66..1]=BOTTOM
        const zone = (rel <= 0.33) ? "TOP" : (rel <= 0.66 ? "CENTER" : "BOTTOM");

        await markRead(ts, msgId, zone);
      }, 250);

      readHoldTimers.set(msgId, t);
    }
  }, { root: messagesEl, threshold: [0,0.6,1] });

  // Observe existing nodes
  for(const node of messagesEl.querySelectorAll(".msg")){
    readObserver.observe(node);
  }
}

async function markRead(ts, msgId, zone){
  if(!currentRoom) return;

  // If user is reading old messages (scrolled up), we still only store monotonic lastReadTs
  const userId = session?.userId || localGuest.userId;

  const p = presenceCache.get(userId);
  if(!p) return;

  const prev = p.lastReadTs || 0;
  const next = Math.max(prev, ts);

  if(next === prev) return; // no change

  p.lastReadTs = next;
  p.lastReadMsgId = msgId;
  p.lastSeenAt = Date.now();
  if(zone !== "TOP") p.lastActiveAt = Date.now(); // center/bottom implies more "engaged"

  presenceCache.set(userId, p);

  // Throttle writes
  const now = Date.now();
  if(now - lastReadWriteAt < 1500) return;
  lastReadWriteAt = now;

  await presenceWrite(p);
  updateReadBadges();
}

function updateReadBadges(){
  // Show "read by" if presence.lastReadTs >= msg.ts
  const nodes = messagesEl.querySelectorAll(".msg");
  const selfId = session?.userId || localGuest.userId;
  
  for(const node of nodes){
    const ts = Number(node.dataset.ts||0);
    const msgId = node.dataset.msgId;
    const readsEl = node.querySelector(".reads");
    if(!readsEl) continue;

    const readers = [];
    let hasOtherReaders = false;
    
    for(const p of presenceCache.values()){
      if(!p.userId) continue;
      if((p.lastReadTs||0) >= ts){
        // don't show self
        if(p.userId !== selfId){
          readers.push(p.username || p.userId);
          hasOtherReaders = true;
        }
      }
    }
    readsEl.textContent = readers.length ? `read by: ${readers.slice(0,3).join(", ")}${readers.length>3?"‚Ä¶":""}` : "";
    
    // Update own message status to 'read' if others have read it
    const statusEl = node.querySelector('.msg-status');
    if(statusEl && hasOtherReaders){
      const currentStatus = statusEl.className.match(/status-(\w+)/)?.[1];
      if(currentStatus && ['sent', 'delivered'].includes(currentStatus)){
        updateMessageStatus(msgId, 'read');
      }
    }
  }
}

/* ============================================================
   SENDING + SYNC
   ============================================================ */
async function sendMessage(){
  if(!running || !currentRoom) return;

  const text = (msgInput.value||"").trim();
  if(!text) return;

  const now = Date.now();
  const userId = session?.userId || localGuest.userId;
  const sender = (nameInput.value||"").trim() || session?.username || localGuest.name || "Anon";

  // attach rich metadata for provenance
  const ip = null; // IP tracking disabled
  const device = `${navigator.platform || 'unknown'} - ${navigator.userAgent.slice(0,50)}`;
  const sessionType = session?.userId ? 'registered' : (String(localGuest.userId||'').startsWith('g-') ? 'guest' : 'anon');

  const msg = {
    id: `m-${now}-${Math.random().toString(36).slice(2,8)}`,
    room: currentRoom,
    sender,
    userId,
    ts: now,
    text,
    edited:false,
    editedAt:null,
    deleted:false,
    createdAt: now,
    status: 'sending', // New status field
    meta: {
      sessionType,
      sessionUsername: session?.username || null,
      device,
      ip,
      ua: navigator.userAgent || null
    }
  };

  // OPTIMISTIC UI: Show message immediately
  addMessageToDom(msg);
  msgInput.value = "";
  markInteraction("send");

  // Send to GitHub in background
  try{
    await appendMessageV3(currentRoom, msg);
    
    // Update status to sent
    msg.status = 'sent';
    updateMessageStatus(msg.id, 'sent');
    
    // Enter burst mode: check frequently for responses
    burstModeUntil = Date.now() + POLL_BURST_DURATION;
    if(running && currentRoom){
      clearTimeout(pollTimer);
      scheduleNextPoll(POLL_MS_BURST);
    }
    
    // Presence update
    await presenceSetOnline(true, "send");
    
    // Refresh presence list occasionally
    await maybeRefreshPresence();
    
    // After a brief moment, update to delivered
    setTimeout(() => {
      msg.status = 'delivered';
      updateMessageStatus(msg.id, 'delivered');
    }, 500);
    
  }catch(e){
    console.error('[sendMessage ERROR]', e);
    msg.status = 'failed';
    updateMessageStatus(msg.id, 'failed');
    showToast('Failed to send message. Click retry to try again.', 'error', 6000);
  }
}

function updateMessageStatus(msgId, status){
  // Update in loadedMessages
  for(const m of loadedMessages){
    if(m.id === msgId){
      m.status = status;
      break;
    }
  }
  
  // Update DOM
  const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
  if(!el) return;
  
  const statusEl = el.querySelector('.msg-status');
  if(statusEl){
    statusEl.className = `msg-status status-${status}`;
  }
  
  // Handle failed state
  if(status === 'failed'){
    el.classList.add('msg-failed');
    // Add retry button if not exists
    if(!el.querySelector('.msg-retry')){
      const meta = el.querySelector('.meta');
      if(meta){
        const retry = document.createElement('button');
        retry.className = 'msg-retry';
        retry.textContent = 'Retry';
        const msg = loadedMessages.find(m => m.id === msgId);
        retry.onclick = (e) => { e.stopPropagation(); if(msg) retryMessage(msg); };
        meta.appendChild(retry);
      }
    }
  }else{
    el.classList.remove('msg-failed');
    const retry = el.querySelector('.msg-retry');
    if(retry) retry.remove();
  }
}

async function retryMessage(msg){
  if(!msg || !currentRoom) return;
  
  // Update status to sending
  updateMessageStatus(msg.id, 'sending');
  
  try{
    await appendMessageV3(currentRoom, msg);
    updateMessageStatus(msg.id, 'sent');
    showToast('Message sent successfully', 'success');
    
    setTimeout(() => {
      updateMessageStatus(msg.id, 'delivered');
    }, 500);
    
  }catch(e){
    console.error('[retryMessage ERROR]', e);
    updateMessageStatus(msg.id, 'failed');
    showToast('Retry failed. Please try again.', 'error');
  }
}

async function syncLatestFromStorage(){
  // Load newest messages since loadedCellsMax
  await loadRoomIndex(currentRoom);

  const latestCell = roomIndex.latestCell || 1;

  // If nothing loaded yet -> load latest
  if(loadedCellsMax === null){
    const msgs = await loadLatestMessages(currentRoom, 50);
    renderAll(msgs);
    updateReadBadges();
    return;
  }

  if(latestCell <= loadedCellsMax){
    // still refresh presence sometimes
    await maybeRefreshPresence();
    return;
  }

  // Load new cells
  const newMsgs = await loadCellsRange(currentRoom, loadedCellsMax+1, latestCell);
  loadedCellsMax = latestCell;

  for(const m of newMsgs){
    addMessageToDom(m, true);
  }
  messagesEl.scrollTop = messagesEl.scrollHeight;
  setupReadObserver();
  await maybeRefreshPresence();
  updateReadBadges();
}

/* ============================================================
   LOCAL GUEST IDENTITY (used if not logged in)
   ============================================================ */
const localGuest = {
  userId: null,
  name: "Guest"
};

function initGuestIdentity(){
  try{
    const k="cp2p_guest_v1";
    const raw = localStorage.getItem(k);
    if(raw){
      const obj = JSON.parse(raw);
      if(obj?.userId){
        localGuest.userId = obj.userId;
        localGuest.name = obj.name || "Guest";
        return;
      }
    }
    const now = Date.now();
    const rand = Math.random().toString(36).slice(2,10);
    localGuest.userId = `g-${now}-${rand}`;
    localGuest.name = "Guest";
    localStorage.setItem(k, JSON.stringify(localGuest));
  }catch(_){
    localGuest.userId = `g-${Date.now()}-${Math.random().toString(36).slice(2,10)}`;
  }
}

/* ============================================================
   UI: AUTH MODAL + ROOM JOIN/LEAVE
   ============================================================ */
let authMode = "login"; // "login" | "register"

function openAuth(mode){
  authMode = mode;
  authModalTitle.textContent = mode === "login" ? "Login" : "Register";
  authActionBtn.textContent  = mode === "login" ? "Login" : "Register";
  authMsg.textContent = "";
  authModalBack.style.display = "flex";
  authUserInput.focus();
}

function closeAuth(){
  authModalBack.style.display = "none";
  authUserInput.value = "";
  authPassInput.value = "";
  authMsg.textContent = "";
}

loginBtn.onclick = ()=>openAuth("login");
registerBtn.onclick = ()=>openAuth("register");
logoutBtn.onclick = ()=>logout();
browseRoomsBtn.onclick = ()=>openRoomBrowser();

authCloseBtn.onclick = closeAuth;
authModalBack.addEventListener("click", (e)=>{ if(e.target===authModalBack) closeAuth(); });

authActionBtn.onclick = async ()=>{
  try{
    authMsg.style.color = "var(--muted)";
    authMsg.textContent = "Working‚Ä¶";
    const u = authUserInput.value.trim();
    const p = authPassInput.value;

    if(authMode==="register"){
      await registerUser(u, p);
      authMsg.style.color = "rgba(34,197,94,.95)";
      authMsg.textContent = "Registered ‚úÖ";
      closeAuth();
    }else{
      await loginUser(u, p);
      authMsg.style.color = "rgba(34,197,94,.95)";
      authMsg.textContent = "Logged in ‚úÖ";
      closeAuth();
    }

    // If inside room, presence file path changes from guest->user. Write online once.
    if(running && currentRoom){
      await presenceSetOnline(true, "auth");
      await refreshPresence();
    }
  }catch(e){
    authMsg.style.color = "rgba(239,68,68,.95)";
    authMsg.textContent = String(e?.message || e);
  }
};

joinBtn.onclick = async ()=>{
  try{
    const r = roomInput.value.trim();
    if(!r){ log("Room required.","WARN"); return; }

    const displayName = nameInput.value.trim() || session?.username || "Anon";
    if(!nameInput.value.trim()) nameInput.value = displayName;

    currentRoom = r;
    running = true;

    // Save last joined room for logged-in users
    if(session && session.userId){
      saveLastJoinedRoom(r);
    }

    // Ensure storage (V3) + master file
    setNet("ok","joining‚Ä¶");
    await ensureRoomV3(currentRoom);

    // UI
    chatPanel.style.display = "flex";
    roomTitle.textContent = `#${currentRoom}`;
    roomSub.textContent = `storage: V3 ¬∑ cell=${CELL_MAX_MESSAGES} ¬∑ box=${CELLS_PER_BOX} cells`;

    // Presence: join => online=true
    presenceState.inRoom = true;
    await presenceSetOnline(true, "join");

    // Load latest
    const msgs = await loadLatestMessages(currentRoom, 50);
    renderAll(msgs);

    // Lazy load + observers
    installLazyLoader();
    setupReadObserver();

    // Kick poll loop
    clearTimeout(pollTimer);
    scheduleNextPoll(50);

    // Pull presence list
    await refreshPresence();

    log(`‚ú® Joined "${currentRoom}" as ${displayName}.`, "INFO");
  }catch(e){
    console.error("[Join ERROR]", e);
    setNet("bad","join error");
    log("Join failed. Check token / permissions / network.","ERROR");
  }
};

leaveBtn.onclick = async ()=>{
  try{
    if(!running) return;

    // Presence offline once
    await presenceSetOnline(false, "leave");
    presenceState.inRoom = false;

    running = false;
    currentRoom = null;
    clearTimeout(pollTimer);
    pollTimer = null;

    if(presenceState.heartbeatTimer){
      clearInterval(presenceState.heartbeatTimer);
      presenceState.heartbeatTimer = null;
    }

    chatPanel.style.display = "none";
    clearView();
    log("Left room.","INFO");
  }catch(e){
    console.error("[Leave ERROR]", e);
  }
};

sendBtn.onclick = ()=>sendMessage();
clearBtn.onclick = ()=>clearView();

roomInput.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){
    e.preventDefault();
    joinBtn.click();
  }
});

msgInput.addEventListener("input", (e)=>{
  // Trigger typing mode for fast polling
  if(currentRoom && running){
    startTypingMode();
  }
});

msgInput.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){
    // Shift+Enter -> newline, Enter (alone) -> send. Ctrl/Cmd+Enter also sends.
    if(e.shiftKey) return;
    e.preventDefault();
    stopTypingMode(); // Stop fast polling when sending
    sendMessage();
  }
});

/* ============================================================
   BOOT
   ============================================================ */
window.addEventListener("load", async ()=>{
  try{
    setNet("bad","booting‚Ä¶");
    initGuestIdentity();
    loadSessionFromStorage();
    applySessionToUi();

    installInteractionListeners();
    
    // Tab visibility: check for messages when tab becomes visible
    document.addEventListener("visibilitychange", ()=>{
      if(!document.hidden && running && currentRoom && !pollInFlight){
        // Tab became visible - check for new messages
        clearTimeout(pollTimer);
        setTimeout(pollLoop, 100);
      }
    });

    log("‚è≥ Loading token‚Ä¶","INFO");
    await ensureGhToken();

    log("‚è≥ Loading password dictionary (READ ONLY)‚Ä¶","INFO");
    await loadPasswordDictionary();

    if(PWD_DICT_READY){
      log("‚úÖ Dictionary ready.","INFO");
    }else{
      log("‚ùå Dictionary missing. Login/Register disabled.","ERROR");
    }

    setNet("ok","ready");
    log("Ready. Join a room.","INFO");
  }catch(e){
    console.error("[BOOT ERROR]", e);
    setNet("bad","boot error");
    log("Boot error: check network/token.","ERROR");
  }
});
</script>
<!-- Compatibility wrappers for Cp2pv3 API (aliases / helpers) -->
<script>
// These wrappers restore several Cp2pv3 function names expected by older modules.
// They are safe no-ops or thin adapters to Cp2pv4 implementations.
(function(){
  if(typeof b64 === 'undefined' && typeof b64EncodeUtf8 === 'function'){
    window.b64 = function(s){ return b64EncodeUtf8(String(s)); };
  }

  if(typeof ghRawUrl === 'undefined' && typeof rawUrl === 'function'){
    window.ghRawUrl = function(p){ return rawUrl(p); };
  }

  if(typeof makeMsgId === 'undefined'){
    window.makeMsgId = function(){ return `m-${Date.now()}-${Math.random().toString(36).slice(2,10)}`; };
  }

  if(typeof enforceDomCap === 'undefined'){
    window.enforceDomCap = function(){
      try{
        if(!window.messagesEl) return;
        while(messagesEl.children.length > (window.DOM_MAX_MESSAGES || 200)){
          messagesEl.removeChild(messagesEl.firstChild);
        }
      }catch(e){/* ignore */}
    };
  }

  if(typeof scrollToBottomSoon === 'undefined'){
    window.scrollToBottomSoon = function(){ requestAnimationFrame(()=>{ if(window.messagesEl) messagesEl.scrollTop = messagesEl.scrollHeight; }); };
  }

  // ghGetCellWithSha / ghGetManifestWithSha adapters (V3 names -> V4 helpers)
  if(typeof ghGetCellWithSha === 'undefined'){
    window.ghGetCellWithSha = async function(roomName, cellNumber){
      const p = cellPath(roomName, cellNumber);
      const got = await ghGetJsonWithSha(p);
      const arr = Array.isArray(got.obj) ? got.obj : [];
      return { path: p, sha: got.sha || null, arr };
    };
  }

  if(typeof ghGetManifestWithSha === 'undefined'){
    window.ghGetManifestWithSha = async function(roomName){
      const p = manifestPath(roomName);
      const got = await ghGetJsonWithSha(p);
      const obj = (got.obj && typeof got.obj === 'object') ? got.obj : null;
      return { path: p, sha: got.sha || null, obj };
    };
  }

  // appendMessageToCells compatibility -> appendMessageV3
  if(typeof appendMessageToCells === 'undefined' && typeof appendMessageV3 === 'function'){
    window.appendMessageToCells = async function(roomName, msg){
      return await appendMessageV3(roomName, msg);
    };
  }

  // bumpMaster / readMasterStampRaw aliases
  if(typeof bumpMaster === 'undefined' && typeof saveMasterValue === 'function'){
    window.bumpMaster = async function(roomName){
      await saveMasterValue(roomName, Date.now());
    };
  }

  if(typeof readMasterStampRaw === 'undefined' && typeof readMasterValue === 'function'){
    window.readMasterStampRaw = async function(roomName){
      const r = await readMasterValue(roomName);
      return { unchanged: false, stamp: r.ok ? (r.value ? Date.now() : 0) : 0 };
    };
  }

  // ghPutJson older signature compatibility: already implemented in file, keep alias
  if(typeof ghPutJsonCompat === 'undefined'){
    window.ghPutJsonCompat = function(path,obj,sha,commitMsg){ return ghPutJson(path,obj,sha,commitMsg); };
  }

})();
</script>
</body>
</html>
