<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,viewport-fit=cover,user-scalable=yes"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <meta name="theme-color" content="#0b0f17"/>
  <link rel="icon" type="image/x-icon" href="/Chat-p2p/favicon.ico"/>
  
  <!-- Primary Meta Tags -->
  <title>Chat P2P - Serverless </title>
  <meta name="title" content="Chat P2P - Serverless Real-Time"/>
  <meta name="description" content="Open-source peer-to-peer chat app with no backend. Send messages, voice notes, images & files using GitHub as storage. Mobile-first, secure, and completely free."/>
  <meta name="keywords" content="p2p chat, serverless chat, github storage, jamstack chat, real-time messaging, peer-to-peer, no backend, open source chat"/>
  <meta name="author" content="Sotravil"/>
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website"/>
  <meta property="og:url" content="https://sotravil.github.io/Chat-p2p/"/>
  <meta property="og:title" content="Chat P2P - Serverless Real-Time Chat"/>
  <meta property="og:description" content="Open-source peer-to-peer chat app with no backend. Send messages, voice notes, images & files using GitHub as storage. Mobile-first, secure, and completely free."/>
  <meta property="og:image" content="https://sotravil.github.io/Chat-p2p/preview.png"/>
  <meta property="og:image:width" content="1200"/>
  <meta property="og:image:height" content="630"/>
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image"/>
  <meta property="twitter:url" content="https://sotravil.github.io/Chat-p2p/"/>
  <meta property="twitter:title" content="Chat P2P - Serverless Real-Time Chat"/>
  <meta property="twitter:description" content="Open-source peer-to-peer chat with GitHub storage. No server needed. Send messages, voice, images & files."/>
  <meta property="twitter:image" content="https://sotravil.github.io/Chat-p2p/preview.png"/>
  <style>
    :root{
      --bg:#0b0f17;
      --panel:#0f172a;
      --panel2:#111c36;
      --txt:#e5e7eb;
      --muted:#94a3b8;
      --ok:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --border:rgba(255,255,255,.08);
      --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
      --pad:14px;
      --mono:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      --accent-primary: #38bdf8;
      --accent-secondary: #a855f7;
    }
    *{box-sizing:border-box}
    html,body{
      height:100%;
      /* Hide body scrollbar */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    html::-webkit-scrollbar, body::-webkit-scrollbar {
      display: none;
    }
    body{
      margin:0;
      display:flex;
      flex-direction:column;
      /* Safe area insets for notched devices */
      padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      background:radial-gradient(1200px 700px at 40% -10%, rgba(56,189,248,.15), transparent 60%),
                 radial-gradient(900px 500px at 120% 20%, rgba(168,85,247,.12), transparent 55%),
                 radial-gradient(600px 400px at 80% 100%, rgba(34,197,94,.08), transparent 50%),
                 var(--bg);
      color:var(--txt);
      font-family:var(--sans);
      -webkit-font-smoothing:antialiased;
      -webkit-tap-highlight-color:transparent; /* Remove tap highlight on mobile */
      touch-action:pan-y; /* Allow vertical scrolling */
      overflow-y:auto;
      overflow-x:hidden;
    }
    header{
      flex-shrink:0;
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 18px;
      border-bottom:1px solid var(--border);
      background:rgba(15,23,42,.85);
      backdrop-filter: blur(12px);
      box-shadow: 0 2px 8px rgba(0,0,0,.15);
    }
    header .left{display:flex; align-items:center; gap:10px}
    header h1{font-size:14px; margin:0; letter-spacing:.2px; opacity:.95}
    header .status{
      display:inline-flex; align-items:center; gap:8px;
      font-size:12px; color:var(--muted);
      padding:6px 10px; border:1px solid var(--border); border-radius:999px;
      background:rgba(255,255,255,.03);
    }
    .dot{width:10px;height:10px;border-radius:99px;background:var(--warn)}
    .dot.ok{background:var(--ok)}
    .dot.bad{background:var(--bad)}

    header .right{display:flex; align-items:center; gap:8px}
    button{
      border:1px solid var(--border);
      background:rgba(255,255,255,.05);
      color:var(--txt);
      padding:9px 14px;
      border-radius:11px;
      font-size:12px;
      font-weight:500;
      cursor:pointer;
      box-shadow:0 2px 4px rgba(0,0,0,.1);
      transition:all .2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    button:hover:not(:disabled){
      background:rgba(255,255,255,.08);
      transform:translateY(-1px);
      box-shadow:0 4px 8px rgba(0,0,0,.2);
    }
    button:active:not(:disabled){
      transform:translateY(0px);
      box-shadow:0 1px 2px rgba(0,0,0,.15);
    }
    button.primary{
      background:linear-gradient(135deg, rgba(34,197,94,.18), rgba(34,197,94,.12));
      border-color:rgba(34,197,94,.4);
      color:#22c55e;
    }
    button.primary:hover:not(:disabled){
      background:linear-gradient(135deg, rgba(34,197,94,.25), rgba(34,197,94,.18));
      border-color:rgba(34,197,94,.5);
    }
    button.danger{
      background:linear-gradient(135deg, rgba(239,68,68,.18), rgba(239,68,68,.12));
      border-color:rgba(239,68,68,.4);
      color:#ef4444;
    }
    button.danger:hover:not(:disabled){
      background:linear-gradient(135deg, rgba(239,68,68,.25), rgba(239,68,68,.18));
      border-color:rgba(239,68,68,.5);
    }
    button:disabled{opacity:.4; cursor:not-allowed}

    main{
      height:calc(100% - 50px);
      display:grid;
      grid-template-rows:auto 1fr auto;
      gap:10px;
      padding:12px;
    }
    .panel{
      flex:1;
      min-height:0;
      background:linear-gradient(180deg, rgba(17,28,54,.98), rgba(15,23,42,.95));
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      box-shadow:0 12px 40px rgba(0,0,0,.4), 0 0 1px rgba(255,255,255,.1);
      overflow:hidden;
      position:relative;
      display:flex;
      flex-direction:column;
    }
    .panel::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:18px;
      padding:1px;
      background:linear-gradient(135deg, rgba(56,189,248,.2), transparent 40%, rgba(168,85,247,.15));
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite:exclude;
      pointer-events:none;
      opacity:.5;
    }
    .join{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .field{display:flex; flex-direction:column; gap:6px; flex:1; min-width:140px}
    label{font-size:11px; color:var(--muted)}
    input{
      width:100%;
      padding:11px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      transition:all .2s ease;
    }
    input:focus{
      border-color:rgba(56,189,248,.5);
      background:rgba(0,0,0,.35);
      box-shadow:0 0 0 3px rgba(56,189,248,.1);
    }
    .hint{font-size:11px;color:var(--muted); line-height:1.25}
    .chat{
      display:flex;
      flex-direction:column;
      min-height:0;
      flex:1;
    }
    .chatHeader{
      flex-shrink:0;
      padding:10px 12px;
      border-bottom:1px solid var(--border);
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
    }
    .chatHeader .meta{display:flex; flex-direction:column; gap:2px; min-width:0}
    .chatHeader .meta .room{font-size:13px; font-weight:650; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .chatHeader .meta .sub{font-size:11px;color:var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; display:flex; align-items:center; gap:8px}
    .chatHeader .people{font-size:11px;color:var(--muted); white-space:nowrap; display:flex; align-items:center; gap:8px}
    .badge{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      min-width:20px;
      height:20px;
      padding:0 6px;
      background:var(--bad);
      color:#fff;
      border-radius:10px;
      font-size:10px;
      font-weight:700;
      letter-spacing:.2px;
      box-shadow:0 2px 6px rgba(239,68,68,.4);
    }
    .badge.mention-badge{
      background:linear-gradient(135deg, rgba(245,158,11,.9), rgba(245,158,11,.75));
      box-shadow:0 2px 6px rgba(245,158,11,.5);
    }
    .badge.mention-badge::before{
      content:'@';
      margin-right:2px;
    }
    .badge:empty{
      display:none;
    }
    .cell-indicator{
      display:inline-flex;
      align-items:center;
      gap:5px;
      padding:3px 8px;
      background:linear-gradient(135deg, rgba(56,189,248,.15), rgba(168,85,247,.1));
      border:1px solid rgba(56,189,248,.3);
      border-radius:8px;
      font-size:10px;
      font-weight:600;
      color:var(--accent-primary);
      letter-spacing:.3px;
      transition:all .3s ease;
    }
    .cell-indicator.synced{
      border-color:rgba(34,197,94,.4);
      background:linear-gradient(135deg, rgba(34,197,94,.15), rgba(56,189,248,.08));
      color:var(--ok);
    }
    .cell-indicator.behind{
      border-color:rgba(245,158,11,.4);
      background:linear-gradient(135deg, rgba(245,158,11,.15), rgba(239,68,68,.08));
      color:var(--warn);
      animation:pulse 2s ease-in-out infinite;
    }
    @keyframes pulse{
      0%, 100% { opacity:1; transform:scale(1); }
      50% { opacity:.85; transform:scale(1.02); }
    }
    .msgs{
      flex:1;
      padding:12px;
      overflow-y:auto;
      overflow-x:hidden;
      scroll-behavior:smooth;
      -webkit-overflow-scrolling:touch;
      min-height:0;
      /* Hide scrollbar but keep functionality */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }
    .msgs::-webkit-scrollbar {
      display: none; /* Chrome/Safari/Opera */
    }
    .msg{
      max-width:85%;
      padding:11px 13px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(255,255,255,.06);
      margin:10px 0;
      word-wrap:break-word;
      transition:all .2s ease;
      box-shadow:0 2px 8px rgba(0,0,0,.15);
    }
    .msg:hover{
      border-color:rgba(255,255,255,.12);
      box-shadow:0 4px 12px rgba(0,0,0,.25);
      transform:translateY(-1px);
    }
    .msg.me{
      margin-left:auto;
      background:linear-gradient(135deg, rgba(56,189,248,.15), rgba(56,189,248,.08));
      border-color:rgba(56,189,248,.3);
    }
    .msg.me:hover{
      background:linear-gradient(135deg, rgba(56,189,248,.2), rgba(56,189,248,.12));
      border-color:rgba(56,189,248,.4);
    }
    .msg .text{font-size:13px; line-height:1.35}
    .msg .meta{font-size:10px; color:var(--muted); margin-top:6px; display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .msg .reads{font-size:10px;color:rgba(34,197,94,.85)}
    .msg-status{
      font-size:11px;
      color:var(--muted);
      display:inline-flex;
      align-items:center;
      gap:4px;
      margin-left:auto;
    }
    .msg-status.status-sending{
      color:rgba(245,158,11,.85);
    }
    .msg-status.status-sending::before{
      content:'\23F3';
      animation:statusPulse 1.5s ease-in-out infinite;
    }
    .msg-status.status-sent{
      color:var(--muted);
    }
    .msg-status.status-sent::before{
      content:'\2713';
    }
    .msg-status.status-delivered{
      color:rgba(56,189,248,.75);
    }
    .msg-status.status-delivered::before{
      content:'\2713\2713';
    }
    .msg-status.status-read{
      color:rgba(34,197,94,.85);
    }
    .msg-status.status-read::before{
      content:'\2713\2713';
    }
    .msg-status.status-failed{
      color:rgba(239,68,68,.85);
      cursor:pointer;
    }
    .msg-status.status-failed::before{
      content:'\26A0';
    }
    .msg-retry{
      display:none;
      font-size:10px;
      padding:3px 8px;
      margin-left:6px;
      border-radius:6px;
      background:rgba(239,68,68,.15);
      border:1px solid rgba(239,68,68,.35);
      color:#ef4444;
      cursor:pointer;
      transition:all .2s ease;
    }
    .msg-retry:hover{
      background:rgba(239,68,68,.25);
      border-color:rgba(239,68,68,.5);
    }
    .msg.msg-failed .msg-retry{
      display:inline-block;
    }
    .msg.msg-failed{
      opacity:.85;
      border-color:rgba(239,68,68,.3);
    }
    @keyframes statusPulse{
      0%, 100%{opacity:.5}
      50%{opacity:1}
    }
    
    /* Reply System */
    .msg-reply{
      padding:6px 9px;
      margin-bottom:6px;
      background:rgba(0,0,0,.3);
      border-left:3px solid rgba(56,189,248,.6);
      border-radius:6px;
      font-size:11px;
      color:var(--muted);
      cursor:pointer;
      transition:all .2s ease;
      max-width:100%;
      overflow:hidden;
    }
    .msg-reply:hover{
      background:rgba(0,0,0,.4);
      border-left-color:rgba(56,189,248,.85);
    }
    .msg-reply-author{
      color:var(--accent-primary);
      font-weight:600;
      margin-bottom:2px;
    }
    .msg-reply-text{
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      opacity:.85;
    }
    .msg-actions{
      margin-top:8px;
      display:flex;
      gap:6px;
      opacity:0;
      transition:opacity .2s ease;
    }
    .msg:hover .msg-actions{
      opacity:1;
    }
    .msg-actions button{
      padding:4px 9px;
      font-size:10px;
      border-radius:6px;
      background:rgba(255,255,255,.05);
      border:1px solid var(--border);
      color:var(--muted);
      cursor:pointer;
      transition:all .2s ease;
    }
    .msg-actions button:hover{
      background:rgba(255,255,255,.1);
      color:var(--txt);
      border-color:rgba(56,189,248,.4);
    }
    
    /* Highlight Animation */
    .msg-highlight{
      animation:messageHighlight 2s ease-out;
    }
    @keyframes messageHighlight{
      0%, 100%{
        background:rgba(255,255,255,.06);
        box-shadow:0 2px 8px rgba(0,0,0,.15);
      }
      10%, 30%, 50%{
        background:rgba(245,158,11,.25);
        box-shadow:0 0 20px rgba(245,158,11,.4);
        transform:scale(1.02);
      }
      20%, 40%{
        background:rgba(245,158,11,.15);
        box-shadow:0 0 15px rgba(245,158,11,.3);
      }
    }
    .msg.me.msg-highlight{
      animation:messageHighlightMe 2s ease-out;
    }
    @keyframes messageHighlightMe{
      0%, 100%{
        background:linear-gradient(135deg, rgba(56,189,248,.15), rgba(56,189,248,.08));
      }
      10%, 30%, 50%{
        background:linear-gradient(135deg, rgba(245,158,11,.3), rgba(245,158,11,.2));
        box-shadow:0 0 20px rgba(245,158,11,.4);
        transform:scale(1.02);
      }
      20%, 40%{
        background:linear-gradient(135deg, rgba(245,158,11,.2), rgba(245,158,11,.12));
      }
    }
    
    /* Mention Highlighting */
    .mention{
      color:var(--accent-primary);
      background:rgba(56,189,248,.15);
      padding:1px 4px;
      border-radius:4px;
      font-weight:600;
    }
    .mention.mention-me{
      color:var(--warn);
      background:rgba(245,158,11,.2);
      border:1px solid rgba(245,158,11,.3);
    }
    
    .composer{
      flex-shrink:0;
      display:flex;
      flex-direction:column;
      gap:8px;
      padding:12px;
      border-top:1px solid var(--border);
    }
    
    /* Reply Preview in Composer */
    .reply-preview{
      display:none;
      padding:8px 10px;
      background:rgba(56,189,248,.1);
      border-left:3px solid var(--accent-primary);
      border-radius:8px;
      font-size:11px;
      position:relative;
    }
    .reply-preview.active{
      display:block;
    }
    .reply-preview-header{
      color:var(--accent-primary);
      font-weight:600;
      margin-bottom:3px;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .reply-preview-text{
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .reply-preview-close{
      background:rgba(255,255,255,.1);
      border:1px solid var(--border);
      border-radius:50%;
      width:18px;
      height:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      font-size:12px;
      color:var(--muted);
      transition:all .2s ease;
    }
    .reply-preview-close:hover{
      background:rgba(239,68,68,.2);
      border-color:rgba(239,68,68,.4);
      color:var(--bad);
    }
    
    .composer-main{
      display:flex;
      gap:10px;
      align-items:flex-end;
    }
    .composer textarea{
      flex:1;
      min-height:44px;
      max-height:120px;
      resize:none;
      padding:11px 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      font-family:var(--sans);
      transition:all .2s ease;
      /* Hide scrollbar */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .composer textarea::-webkit-scrollbar {
      display: none;
    }
    .composer textarea:focus{
      border-color:rgba(56,189,248,.5);
      background:rgba(0,0,0,.35);
      box-shadow:0 0 0 3px rgba(56,189,248,.1);
    }
    
    /* Audio Recording Controls */
    .audio-record-btn{
      width:44px;
      height:44px;
      border-radius:50%;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      background:linear-gradient(135deg, rgba(56,189,248,.15), rgba(168,85,247,.15));
      border:1px solid var(--border);
      transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size:20px;
      position:relative;
    }
    .audio-record-btn:hover{
      background:linear-gradient(135deg, rgba(56,189,248,.25), rgba(168,85,247,.25));
      transform:scale(1.05);
      box-shadow:0 4px 12px rgba(56,189,248,.2);
    }
    .audio-record-btn.recording{
      background:linear-gradient(135deg, rgba(239,68,68,.2), rgba(220,38,38,.2));
      border-color:rgba(239,68,68,.5);
      animation:pulse-record 1.5s ease-in-out infinite;
    }
    @keyframes pulse-record{
      0%, 100%{box-shadow:0 0 0 0 rgba(239,68,68,.7);}
      50%{box-shadow:0 0 0 10px rgba(239,68,68,0);}
    }
    
    /* Audio Recording Modal */
    .audio-modal{
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,.85);
      backdrop-filter:blur(8px);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:10000;
      padding:20px;
    }
    .audio-modal.active{
      display:flex;
    }
    .audio-modal-content{
      background:var(--panel);
      border-radius:var(--radius);
      padding:30px;
      max-width:400px;
      width:100%;
      box-shadow:var(--shadow);
      border:1px solid var(--border);
    }
    .audio-modal-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:20px;
    }
    .audio-modal-title{
      font-size:18px;
      font-weight:600;
    }
    .audio-close-btn{
      background:transparent;
      border:none;
      color:var(--muted);
      font-size:24px;
      cursor:pointer;
      padding:0;
      width:32px;
      height:32px;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      transition:all .2s ease;
    }
    .audio-close-btn:hover{
      background:rgba(239,68,68,.1);
      color:var(--bad);
    }
    .audio-visualizer{
      width:100%;
      height:80px;
      background:rgba(0,0,0,.3);
      border-radius:12px;
      margin:20px 0;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:3px;
      padding:0 15px;
      overflow:hidden;
    }
    .audio-bar{
      width:4px;
      background:linear-gradient(to top, var(--accent-primary), var(--accent-secondary));
      border-radius:2px;
      transition:height .1s ease;
      min-height:4px;
    }
    .audio-timer{
      text-align:center;
      font-size:24px;
      font-weight:600;
      color:var(--txt);
      margin:15px 0;
      font-variant-numeric:tabular-nums;
    }
    .audio-controls{
      display:flex;
      gap:10px;
      justify-content:center;
      margin-top:20px;
    }
    .audio-control-btn{
      padding:12px 20px;
      border-radius:12px;
      font-size:14px;
      font-weight:500;
      display:flex;
      align-items:center;
      gap:8px;
      transition:all .2s ease;
    }
    .audio-control-btn.record{
      background:linear-gradient(135deg, rgba(239,68,68,.2), rgba(220,38,38,.2));
      border-color:rgba(239,68,68,.5);
      color:var(--bad);
    }
    .audio-control-btn.pause{
      background:linear-gradient(135deg, rgba(251,191,36,.2), rgba(245,158,11,.2));
      border-color:rgba(251,191,36,.5);
      color:var(--warn);
    }
    .audio-control-btn.send{
      background:linear-gradient(135deg, rgba(34,197,94,.2), rgba(22,163,74,.2));
      border-color:rgba(34,197,94,.5);
      color:var(--ok);
    }
    .audio-lock-indicator{
      position:absolute;
      bottom:-40px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(251,191,36,.15);
      border:1px solid rgba(251,191,36,.3);
      border-radius:20px;
      padding:8px 16px;
      font-size:12px;
      color:var(--warn);
      white-space:nowrap;
      pointer-events:none;
      opacity:0;
      transition:opacity .3s ease;
    }
    .audio-lock-indicator.show{
      opacity:1;
    }
    
    /* Mobile Gesture Indicators */
    .gesture-hint{
      position:fixed;
      display:none;
      z-index:10001;
      pointer-events:none;
    }
    .gesture-hint.active{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:10px;
    }
    .gesture-lock{
      position:absolute;
      top:-100px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(34,197,94,.2);
      border:2px solid rgba(34,197,94,.5);
      border-radius:50%;
      width:60px;
      height:60px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:28px;
      transition:all .2s ease;
    }
    .gesture-lock.highlight{
      background:rgba(34,197,94,.4);
      transform:translateX(-50%) scale(1.2);
    }
    .gesture-cancel{
      position:absolute;
      left:-120px;
      top:50%;
      transform:translateY(-50%);
      background:rgba(239,68,68,.2);
      border:2px solid rgba(239,68,68,.5);
      border-radius:50%;
      width:60px;
      height:60px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:28px;
      transition:all .2s ease;
    }
    .gesture-cancel.highlight{
      background:rgba(239,68,68,.4);
      transform:translateY(-50%) scale(1.2);
    }
    .gesture-text{
      position:absolute;
      bottom:-50px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(0,0,0,.8);
      padding:8px 16px;
      border-radius:20px;
      font-size:12px;
      white-space:nowrap;
      color:var(--txt);
    }
    .recording-overlay{
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,.5);
      z-index:10000;
      display:none;
      backdrop-filter:blur(4px);
    }
    .recording-overlay.active{
      display:block;
    }
    
    /* Audio Message Bubbles */
    .msg-audio{
      background:linear-gradient(135deg, rgba(56,189,248,.12), rgba(168,85,247,.08));
      border-radius:12px;
      padding:12px;
      margin-top:8px;
      display:flex;
      align-items:center;
      gap:12px;
      min-width:280px;
      max-width:350px;
    }
    .audio-play-btn{
      width:42px;
      height:42px;
      min-width:42px;
      border-radius:50%;
      background:linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      border:none;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      transition:all .2s ease;
      color:#fff;
      font-size:16px;
    }
    .audio-play-btn:hover{
      transform:scale(1.05);
      box-shadow:0 4px 12px rgba(56,189,248,.3);
    }
    .audio-waveform{
      flex:1;
      height:40px;
      display:flex;
      align-items:center;
      gap:2px;
      cursor:pointer;
      padding:0 4px;
      transition:gap .2s ease;
    }
    .audio-waveform:hover{
      gap:3px;
    }
    .audio-wave-bar{
      width:3px;
      background:rgba(56,189,248,.3);
      border-radius:2px;
      opacity:.6;
      transition:all .1s cubic-bezier(0.4, 0, 0.2, 1);
      position:relative;
      transform-origin:center;
    }
    .audio-wave-bar:hover{
      opacity:.8;
      transform:scaleY(1.1);
    }
    .audio-wave-bar.active{
      opacity:1;
      background:linear-gradient(to top, var(--accent-primary), var(--accent-secondary));
      box-shadow:0 0 6px rgba(56,189,248,.6), 0 0 12px rgba(56,189,248,.3);
      transform:scaleY(1.05);
      animation:pulse-bar .6s ease-in-out infinite;
    }
    @keyframes pulse-bar{
      0%, 100%{ transform:scaleY(1.05); }
      50%{ transform:scaleY(1.15); }
    }
    .audio-wave-bar.active::after{
      content:'';
      position:absolute;
      top:0;
      left:-1px;
      right:-1px;
      bottom:0;
      background:linear-gradient(to top, rgba(56,189,248,.4), rgba(168,85,247,.4));
      filter:blur(3px);
      z-index:-1;
      border-radius:2px;
    }
    .audio-duration{
      font-size:12px;
      color:var(--muted);
      font-variant-numeric:tabular-nums;
      min-width:80px;
      text-align:right;
      line-height:1.4;
    }
    .audio-play-btn[disabled]{
      opacity:0.6;
      cursor:not-allowed;
      transform:scale(1);
    }
    .audio-play-btn[disabled]:hover{
      transform:scale(1);
      box-shadow:none;
    }

    /* ============================================================
       MEDIA MESSAGING STYLES
       ============================================================ */
    
    /* Media Attach Button */
    .media-attach-btn{
      width:46px; height:46px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.05);
      color:var(--txt);
      font-size:20px;
      cursor:pointer;
      transition:all .2s;
      display:flex; align-items:center; justify-content:center;
      flex-shrink:0;
    }
    .media-attach-btn:hover{
      background:rgba(255,255,255,.08);
      transform:scale(1.05);
    }
    .media-attach-btn:active{
      transform:scale(0.95);
    }
    
    /* Paste Clipboard Button */
    .paste-clipboard-btn{
      width:46px; height:46px;
      border-radius:12px;
      border:1px solid rgba(168,85,247,.3);
      background:linear-gradient(135deg, rgba(168,85,247,.12), rgba(147,51,234,.12));
      color:rgba(168,85,247,1);
      font-size:20px;
      cursor:pointer;
      transition:all .2s;
      display:flex; align-items:center; justify-content:center;
      flex-shrink:0;
    }
    .paste-clipboard-btn:hover{
      background:linear-gradient(135deg, rgba(168,85,247,.2), rgba(147,51,234,.2));
      transform:scale(1.05);
      border-color:rgba(168,85,247,.5);
    }
    .paste-clipboard-btn:active{
      transform:scale(0.95);
    }

    /* Image Grid (max 4 tiles, 2x2) */
    .msg-media-grid{
      display:grid;
      grid-template-columns:repeat(2, 1fr);
      gap:6px;
      margin:8px 0;
      max-width:320px;
    }
    .msg-media-grid.single{
      grid-template-columns:1fr;
      max-width:260px;
    }
    .media-image-tile{
      position:relative;
      aspect-ratio:1;
      border-radius:12px;
      overflow:hidden;
      cursor:pointer;
      background:rgba(255,255,255,.03);
    }
    .media-image-tile img{
      width:100%; height:100%;
      object-fit:cover;
      filter:blur(4px);
      transition:filter .3s;
    }
    .media-image-tile.loaded img{
      filter:blur(0);
    }
    .media-image-tile:hover{
      opacity:0.9;
    }
    .media-image-overlay{
      position:absolute;
      inset:0;
      display:flex; align-items:center; justify-content:center;
      background:rgba(0,0,0,.5);
      color:white;
      font-size:24px;
      font-weight:600;
      backdrop-filter:blur(8px);
    }

    /* Video Card */
    .msg-video{
      position:relative;
      max-width:420px;
      margin:12px 0;
      border-radius:20px;
      overflow:hidden;
      background:linear-gradient(145deg, rgba(15,15,20,.95), rgba(25,25,35,.95));
      box-shadow:0 8px 32px rgba(0,0,0,.4), 0 0 0 1px rgba(255,255,255,.05);
      transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .msg-video:hover{
      transform:translateY(-2px);
      box-shadow:0 12px 40px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.1);
    }
    .msg-video-poster{
      position:relative;
      width:100%;
      aspect-ratio:16/9;
      cursor:pointer;
      background:linear-gradient(135deg, rgba(30,30,40,.9), rgba(20,20,30,.9));
      overflow:hidden;
    }
    .msg-video-poster img{
      width:100%; height:100%;
      object-fit:cover;
      filter:blur(8px) brightness(0.7);
      transition:filter .4s ease;
    }
    .msg-video-poster.loaded img{
      filter:blur(0) brightness(1);
    }
    .msg-video-play-btn{
      position:absolute;
      top:50%; left:50%;
      transform:translate(-50%, -50%);
      width:80px; height:80px;
      border-radius:50%;
      background:linear-gradient(135deg, rgba(56,189,248,.95), rgba(59,130,246,.95));
      color:#fff;
      border:none;
      font-size:32px;
      display:flex; align-items:center; justify-content:center;
      padding-left:6px; /* Ajustar icono de play al centro visual */
      cursor:pointer;
      transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow:0 8px 24px rgba(56,189,248,.4), 0 0 0 4px rgba(255,255,255,.1);
      backdrop-filter:blur(8px);
    }
    .msg-video-play-btn::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:50%;
      background:linear-gradient(135deg, transparent, rgba(255,255,255,.2));
      opacity:0;
      transition:opacity .3s;
    }
    .msg-video-play-btn:hover{
      transform:translate(-50%, -50%) scale(1.15);
      box-shadow:0 12px 32px rgba(56,189,248,.6), 0 0 0 6px rgba(255,255,255,.15), 0 0 60px rgba(56,189,248,.3);
    }
    .msg-video-play-btn:hover::before{
      opacity:1;
    }
    .msg-video-play-btn:active{
      transform:translate(-50%, -50%) scale(1.05);
    }
    .msg-video-close-btn{
      position:absolute;
      top:12px; right:12px;
      width:36px; height:36px;
      border-radius:50%;
      background:rgba(0,0,0,.7);
      color:#fff;
      border:none;
      font-size:20px;
      display:flex; align-items:center; justify-content:center;
      cursor:pointer;
      z-index:10;
      transition:all .2s ease;
      backdrop-filter:blur(8px);
      opacity:0;
      pointer-events:none;
    }
    .msg-video-poster.playing .msg-video-close-btn{
      opacity:1;
      pointer-events:auto;
    }
    .msg-video-close-btn:hover{
      background:rgba(239,68,68,.9);
      transform:scale(1.1);
    }
    .msg-video-info{
      padding:12px 16px;
      display:flex; align-items:center; justify-content:space-between;
      font-size:11px;
      color:rgba(255,255,255,.6);
      background:rgba(0,0,0,.2);
      backdrop-filter:blur(10px);
    }
    .msg-video-preview-overlay{
      position:absolute;
      inset:0;
      display:none;
      background:rgba(0,0,0,.8);
      align-items:center;
      justify-content:center;
    }
    .msg-video-preview-overlay.active{
      display:flex;
    }
    .msg-video-preview-overlay video{
      width:100%;
      height:100%;
      object-fit:contain;
    }

    /* Document/File Chip */
    .msg-file{
      display:flex; align-items:center; gap:12px;
      padding:12px 14px;
      max-width:320px;
      margin:8px 0;
      border-radius:14px;
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
    }
    .msg-file-icon{
      width:44px; height:44px;
      border-radius:10px;
      display:flex; align-items:center; justify-content:center;
      background:rgba(255,255,255,.08);
      font-size:24px;
      flex-shrink:0;
    }
    .msg-file-info{
      flex:1;
      min-width:0;
    }
    .msg-file-name{
      font-size:13px;
      font-weight:500;
      color:var(--txt);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .msg-file-size{
      font-size:11px;
      color:var(--muted);
      margin-top:2px;
    }
    .msg-file-download{
      padding:8px 14px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.05);
      color:var(--txt);
      font-size:12px;
      cursor:pointer;
      white-space:nowrap;
      transition:all .2s;
    }
    .msg-file-download:hover{
      background:rgba(255,255,255,.1);
      transform:translateY(-1px);
    }

    /* Full-Screen Image Viewer */
    .image-viewer{
      display:none;
      position:fixed;
      inset:0;
      z-index:10000;
      background:rgba(0,0,0,.95);
      backdrop-filter:blur(8px);
    }
    .image-viewer.active{
      display:flex;
      flex-direction:column;
    }
    .image-viewer-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:14px 18px;
      background:rgba(0,0,0,.5);
    }
    .image-viewer-counter{
      color:white;
      font-size:14px;
      font-weight:500;
    }
    .image-viewer-actions{
      display:flex;
      gap:8px;
    }
    .image-viewer-btn{
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.1);
      color:white;
      font-size:13px;
      cursor:pointer;
      transition:all .2s;
    }
    .image-viewer-btn:hover{
      background:rgba(255,255,255,.2);
    }
    .image-viewer-content{
      flex:1;
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .image-viewer-img{
      max-width:90%;
      max-height:90%;
      object-fit:contain;
      user-select:none;
      -webkit-user-select:none;
    }
    .image-viewer-nav{
      position:absolute;
      top:50%;
      transform:translateY(-50%);
      width:48px; height:48px;
      border-radius:50%;
      border:none;
      background:rgba(255,255,255,.9);
      color:#000;
      font-size:20px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:all .2s;
      box-shadow:0 4px 12px rgba(0,0,0,.3);
    }
    .image-viewer-nav:hover{
      background:white;
      transform:translateY(-50%) scale(1.1);
    }
    .image-viewer-nav.prev{
      left:20px;
    }
    .image-viewer-nav.next{
      right:20px;
    }

    /* Gallery Drawer (vertical list) */
    .gallery-drawer{
      display:none;
      position:fixed;
      inset:0;
      z-index:10001;
      background:rgba(0,0,0,.9);
      backdrop-filter:blur(8px);
    }
    .gallery-drawer.active{
      display:flex;
      flex-direction:column;
    }
    .gallery-drawer-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:14px 18px;
      border-bottom:1px solid rgba(255,255,255,.1);
    }
    .gallery-drawer-title{
      color:white;
      font-size:16px;
      font-weight:600;
    }
    .gallery-drawer-close{
      width:36px; height:36px;
      border-radius:8px;
      border:none;
      background:rgba(255,255,255,.1);
      color:white;
      font-size:20px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:all .2s;
    }
    .gallery-drawer-close:hover{
      background:rgba(255,255,255,.2);
    }
    .gallery-drawer-content{
      flex:1;
      overflow-y:auto;
      padding:12px;
    }
    .gallery-item{
      display:flex;
      gap:12px;
      padding:12px;
      margin-bottom:8px;
      border-radius:12px;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      cursor:pointer;
      transition:all .2s;
    }
    .gallery-item:hover{
      background:rgba(255,255,255,.08);
    }
    .gallery-item-thumb{
      width:80px; height:80px;
      border-radius:8px;
      overflow:hidden;
      background:rgba(0,0,0,.3);
      flex-shrink:0;
    }
    .gallery-item-thumb img{
      width:100%; height:100%;
      object-fit:cover;
    }
    .gallery-item-info{
      flex:1;
      min-width:0;
      display:flex;
      flex-direction:column;
      justify-content:center;
    }
    .gallery-item-name{
      color:white;
      font-size:13px;
      font-weight:500;
      margin-bottom:4px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .gallery-item-size{
      color:rgba(255,255,255,.6);
      font-size:11px;
    }
    .gallery-item-download{
      padding:8px 12px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.2);
      background:rgba(255,255,255,.1);
      color:white;
      font-size:12px;
      cursor:pointer;
      white-space:nowrap;
      align-self:center;
    }
    .gallery-item-download:hover{
      background:rgba(255,255,255,.2);
    }

    /* Media Upload Progress */
    .media-upload-progress{
      position:fixed;
      bottom:80px;
      right:20px;
      padding:14px 18px;
      border-radius:12px;
      background:rgba(15,23,42,.95);
      border:1px solid var(--border);
      box-shadow:var(--shadow);
      min-width:240px;
      z-index:1000;
    }
    .media-upload-progress-text{
      font-size:13px;
      color:var(--txt);
      margin-bottom:8px;
    }
    .media-upload-progress-bar{
      width:100%;
      height:4px;
      background:rgba(255,255,255,.1);
      border-radius:2px;
      overflow:hidden;
    }
    .media-upload-progress-fill{
      height:100%;
      background:var(--accent-primary);
      transition:width .3s;
    }

    .log{
      padding:10px 12px;
      font-family:var(--mono);
      font-size:11px;
      color:var(--muted);
      max-height:110px;
      overflow:auto;
      border-top:1px solid var(--border);
      background:rgba(0,0,0,.12);
      /* Hide scrollbar */
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    .log::-webkit-scrollbar {
      display: none;
    }
    .pill{
      display:inline-flex; align-items:center; gap:6px;
      padding:6px 10px; border-radius:999px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.03);
      font-size:11px; color:var(--muted);
    }
    .modalBackdrop{
      position:fixed; inset:0;
      display:none;
      align-items:center; justify-content:center;
      padding:18px;
      background:rgba(0,0,0,.55);
      z-index:50;
    }
    .modal{
      width:min(420px, 100%);
      background:linear-gradient(180deg, rgba(17,28,54,.98), rgba(15,23,42,.98));
      border:1px solid rgba(255,255,255,.15);
      border-radius:20px;
      box-shadow:0 20px 60px rgba(0,0,0,.6), 0 0 1px rgba(255,255,255,.2);
      overflow:hidden;
      animation:modalSlideIn .25s cubic-bezier(0.4, 0, 0.2, 1);
    }
    @keyframes modalSlideIn {
      from {
        opacity:0;
        transform:translateY(-20px) scale(0.95);
      }
      to {
        opacity:1;
        transform:translateY(0) scale(1);
      }
    }
    .modal .top{padding:12px 14px; border-bottom:1px solid var(--border); display:flex; align-items:center; justify-content:space-between}
    .modal .top b{font-size:13px}
    .modal .body{padding:14px; display:flex; flex-direction:column; gap:10px}
    .modal .footer{padding:12px 14px; border-top:1px solid var(--border); display:flex; gap:10px; justify-content:flex-end}

    /* Modal overlay styles for edit/delete confirmations */
    .modal-overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:18px;
      background:rgba(0,0,0,.65);
      z-index:100;
      backdrop-filter:blur(4px);
    }
    .modal-overlay.modal-hidden{
      display:none !important;
    }
    .modal-overlay:not(.modal-hidden){
      display:flex;
    }
    .modal-header{
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .modal-title{
      font-size:15px;
      font-weight:600;
    }
    .modal-close{
      width:28px;
      height:28px;
      border:none;
      background:rgba(255,255,255,.05);
      color:var(--txt);
      border-radius:8px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:16px;
      transition:all .2s ease;
    }
    .modal-close:hover{
      background:rgba(255,255,255,.1);
    }
    .modal-body{
      padding:18px 16px;
    }
    .modal-body p{
      margin:0 0 12px 0;
      line-height:1.5;
    }
    .modal-body textarea{
      width:100%;
      min-height:120px;
      padding:10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      font-family:var(--sans);
      resize:vertical;
      transition:all .2s ease;
    }
    .modal-body textarea:focus{
      border-color:rgba(56,189,248,.5);
      background:rgba(0,0,0,.35);
      box-shadow:0 0 0 3px rgba(56,189,248,.1);
    }
    .modal-footer{
      padding:12px 16px;
      border-top:1px solid var(--border);
      display:flex;
      gap:10px;
      justify-content:flex-end;
    }
    .btn-ghost{
      background:rgba(255,255,255,.03);
      border:1px solid var(--border);
    }
    .btn-ghost:hover:not(:disabled){
      background:rgba(255,255,255,.08);
    }

    /* ============================================================
       MEDIA PREVIEW MODAL (WhatsApp-style)
       ============================================================ */
    .media-preview-modal{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.95);
      z-index:200;
      display:none;
      flex-direction:column;
    }
    .media-preview-modal.active{
      display:flex;
    }
    .media-preview-header{
      padding:16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      background:rgba(15,23,42,.8);
      backdrop-filter:blur(10px);
      border-bottom:1px solid rgba(255,255,255,.1);
    }
    .media-preview-title{
      font-size:16px;
      font-weight:600;
      color:var(--txt);
    }
    .media-preview-close{
      width:36px;
      height:36px;
      border:none;
      background:rgba(255,255,255,.1);
      color:var(--txt);
      border-radius:8px;
      cursor:pointer;
      font-size:20px;
      transition:all .2s ease;
    }
    .media-preview-close:hover{
      background:rgba(255,255,255,.2);
      transform:scale(1.05);
    }
    .media-preview-content{
      flex:1;
      overflow-y:auto;
      padding:20px;
      display:flex;
      flex-direction:column;
      gap:16px;
      align-items:center;
    }
    .media-preview-item{
      width:100%;
      max-width:500px;
      background:var(--panel);
      border-radius:16px;
      overflow:hidden;
      border:1px solid var(--border);
    }
    .media-preview-image-container{
      width:100%;
      aspect-ratio:1;
      background:rgba(0,0,0,.3);
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .media-preview-image-container img{
      max-width:100%;
      max-height:100%;
      object-fit:contain;
    }
    .media-preview-video-container{
      width:100%;
      background:rgba(0,0,0,.3);
      position:relative;
    }
    .media-preview-video-container video{
      width:100%;
      max-height:400px;
    }
    .media-preview-file-info{
      padding:16px;
      display:flex;
      align-items:center;
      gap:12px;
      background:rgba(0,0,0,.2);
    }
    .media-preview-file-icon{
      width:48px;
      height:48px;
      border-radius:12px;
      background:rgba(56,189,248,.15);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:24px;
    }
    .media-preview-file-details{
      flex:1;
      min-width:0;
    }
    .media-preview-file-name{
      font-size:14px;
      font-weight:500;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .media-preview-file-size{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
    }
    .media-preview-caption-input{
      padding:16px;
      border-top:1px solid var(--border);
    }
    .media-preview-caption-input textarea{
      width:100%;
      min-height:80px;
      padding:12px;
      border-radius:12px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.25);
      color:var(--txt);
      outline:none;
      font-family:var(--sans);
      font-size:14px;
      resize:none;
      transition:all .2s ease;
    }
    .media-preview-caption-input textarea::placeholder{
      color:var(--muted);
    }
    .media-preview-caption-input textarea:focus{
      border-color:rgba(56,189,248,.5);
      background:rgba(0,0,0,.35);
      box-shadow:0 0 0 3px rgba(56,189,248,.1);
    }
    .media-preview-footer{
      padding:16px;
      background:rgba(15,23,42,.8);
      backdrop-filter:blur(10px);
      border-top:1px solid rgba(255,255,255,.1);
      display:flex;
      gap:12px;
      justify-content:flex-end;
    }
    .media-preview-counter{
      flex:1;
      display:flex;
      align-items:center;
      gap:8px;
      color:var(--muted);
      font-size:14px;
    }
    .media-preview-send-btn{
      min-width:120px;
    }

    /* Message action buttons (edit/delete) */
    .msg-actions{
      margin-top:8px;
      display:flex;
      gap:6px;
      opacity:.6;
      transition:opacity .2s ease;
    }
    .msg:hover .msg-actions{
      opacity:1;
    }
    .msg-actions button{
      padding:5px 10px;
      font-size:11px;
      border-radius:8px;
    }

    /* Toast Notifications */
    .toast-container{
      position:fixed;
      top:20px;
      right:20px;
      z-index:200;
      display:flex;
      flex-direction:column;
      gap:10px;
      pointer-events:none;
    }
    .toast{
      min-width:280px;
      max-width:420px;
      padding:14px 16px;
      background:linear-gradient(135deg, rgba(17,28,54,.98), rgba(15,23,42,.95));
      border:1px solid rgba(255,255,255,.15);
      border-radius:14px;
      box-shadow:0 8px 24px rgba(0,0,0,.5), 0 0 1px rgba(255,255,255,.2);
      color:var(--txt);
      font-size:13px;
      line-height:1.4;
      pointer-events:auto;
      animation:toastSlideIn .3s cubic-bezier(0.4, 0, 0.2, 1);
      backdrop-filter:blur(10px);
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .toast.toast-success{
      border-color:rgba(34,197,94,.4);
      background:linear-gradient(135deg, rgba(34,197,94,.15), rgba(17,28,54,.95));
    }
    .toast.toast-error{
      border-color:rgba(239,68,68,.4);
      background:linear-gradient(135deg, rgba(239,68,68,.15), rgba(17,28,54,.95));
    }
    .toast.toast-warning{
      border-color:rgba(245,158,11,.4);
      background:linear-gradient(135deg, rgba(245,158,11,.15), rgba(17,28,54,.95));
    }
    .toast.toast-info{
      border-color:rgba(56,189,248,.4);
      background:linear-gradient(135deg, rgba(56,189,248,.15), rgba(17,28,54,.95));
    }
    .toast-icon{
      font-size:18px;
      flex-shrink:0;
      margin-top:1px;
    }
    .toast-success .toast-icon{color:#22c55e}
    .toast-error .toast-icon{color:#ef4444}
    .toast-warning .toast-icon{color:#f59e0b}
    .toast-info .toast-icon{color:#38bdf8}
    .toast-message{
      flex:1;
      word-wrap:break-word;
    }
    .toast-close{
      width:20px;
      height:20px;
      border:none;
      background:rgba(255,255,255,.08);
      color:var(--muted);
      border-radius:6px;
      cursor:pointer;
      font-size:14px;
      display:flex;
      align-items:center;
      justify-content:center;
      flex-shrink:0;
      transition:all .2s ease;
    }
    .toast-close:hover{
      background:rgba(255,255,255,.15);
      color:var(--txt);
    }
    .toast.toast-out{
      animation:toastSlideOut .25s cubic-bezier(0.4, 0, 0.2, 1) forwards;
    }
    @keyframes toastSlideIn{
      from{
        opacity:0;
        transform:translateX(100%) scale(0.9);
      }
      to{
        opacity:1;
        transform:translateX(0) scale(1);
      }
    }
    @keyframes toastSlideOut{
      from{
        opacity:1;
        transform:translateX(0) scale(1);
      }
      to{
        opacity:0;
        transform:translateX(120%) scale(0.9);
      }
    }

    /* Pull to Refresh Indicator */
    .pull-refresh-indicator{
      position:absolute;
      top:50px;
      left:50%;
      transform:translateX(-50%) scale(0);
      padding:12px 20px;
      background:linear-gradient(135deg, rgba(56,189,248,.25), rgba(168,85,247,.18));
      border:1px solid rgba(56,189,248,.4);
      border-radius:24px;
      color:var(--txt);
      font-size:13px;
      font-weight:600;
      letter-spacing:.3px;
      box-shadow:0 8px 24px rgba(0,0,0,.4);
      backdrop-filter:blur(12px);
      z-index:150;
      pointer-events:none;
      opacity:0;
      transition:all .3s cubic-bezier(0.4, 0, 0.2, 1);
      display:flex;
      align-items:center;
      gap:10px;
    }
    .pull-refresh-indicator.active{
      transform:translateX(-50%) scale(1);
      opacity:1;
    }
    .pull-refresh-indicator.syncing{
      border-color:rgba(34,197,94,.5);
      background:linear-gradient(135deg, rgba(34,197,94,.25), rgba(56,189,248,.15));
    }
    .pull-refresh-indicator .icon{
      font-size:16px;
      animation:spin 1s linear infinite;
    }
    .pull-refresh-indicator.syncing .icon{
      animation:spin .6s linear infinite;
    }
    @keyframes spin{
      from{transform:rotate(0deg)}
      to{transform:rotate(360deg)}
    }

    /* Room Browser */
    .room-list{
      display:flex;
      flex-direction:column;
      gap:10px;
      max-height:400px;
      overflow-y:auto;
      scrollbar-width:none;
      -ms-overflow-style:none;
    }
    .room-list::-webkit-scrollbar{
      display:none;
    }
    .room-item{
      padding:12px 14px;
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      border-radius:12px;
      cursor:pointer;
      transition:all .2s ease;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .room-item:hover{
      background:rgba(255,255,255,.08);
      border-color:rgba(56,189,248,.35);
      transform:translateX(4px);
    }
    .room-item.last-joined{
      border-color:rgba(34,197,94,.4);
      background:linear-gradient(135deg, rgba(34,197,94,.12), rgba(255,255,255,.04));
    }
    .room-item.last-joined::before{
      content:'\2B50';
      margin-right:8px;
    }
    .room-info{
      flex:1;
      min-width:0;
    }
    .room-name{
      font-size:14px;
      font-weight:600;
      color:var(--txt);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .room-meta{
      font-size:11px;
      color:var(--muted);
      margin-top:2px;
    }
    .room-status{
      display:flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color:var(--muted);
      flex-shrink:0;
    }
    .room-status.active{
      color:rgba(34,197,94,.85);
    }
    .room-status .user-count{
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:4px 8px;
      background:rgba(56,189,248,.12);
      border:1px solid rgba(56,189,248,.3);
      border-radius:8px;
      font-weight:600;
    }
    .room-status.active .user-count{
      background:rgba(34,197,94,.12);
      border-color:rgba(34,197,94,.3);
      color:rgba(34,197,94,.95);
    }
    .empty-rooms{
      padding:40px 20px;
      text-align:center;
      color:var(--muted);
      font-size:13px;
    }
    .browse-btn{
      margin-left:8px;
    }

    /* Fullscreen chat mode */
    .fullscreen-toggle{
      position:absolute;
      right:12px;
      top:50%;
      transform:translateY(-50%);
      width:36px;
      height:36px;
      padding:0;
      border-radius:10px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:18px;
      background:rgba(56,189,248,.12);
      border:1px solid rgba(56,189,248,.3);
      color:var(--txt);
      cursor:pointer;
      transition:all .2s ease;
      z-index:10;
    }
    .fullscreen-toggle:hover{
      background:rgba(56,189,248,.2);
      border-color:rgba(56,189,248,.5);
      transform:translateY(-50%) scale(1.05);
    }
    body.chat-fullscreen header,
    body.chat-fullscreen .join,
    body.chat-fullscreen .log{
      display:none !important;
    }
    body.chat-fullscreen main{
      height:100%;
      padding:0;
      gap:0;
    }
    body.chat-fullscreen .chat{
      height:100%;
      border-radius:0;
      border:none;
    }
    body.chat-fullscreen .chatHeader{
      position:relative;
      border-radius:0;
    }
    body.chat-fullscreen .msgs{
      height:calc(100vh - 130px);
    }
    body.chat-fullscreen .fullscreen-toggle{
      background:rgba(239,68,68,.12);
      border-color:rgba(239,68,68,.3);
    }
    body.chat-fullscreen .fullscreen-toggle:hover{
      background:rgba(239,68,68,.2);
      border-color:rgba(239,68,68,.5);
    }

    /* ================================================
       MOBILE-FIRST RESPONSIVE DESIGN
       Base styles = Mobile (320px+)
       Progressive enhancement for tablets/desktop
       ================================================ */
    
    /* Mobile: Adjust header for small screens */
    @media (max-width: 640px){
      header{
        padding:10px 12px;
        flex-wrap:wrap;
      }
      header h1{
        font-size:13px;
      }
      header .status{
        font-size:10px;
        padding:4px 8px;
      }
      header .right{
        width:100%;
        justify-content:flex-end;
        margin-top:6px;
      }
      button{
        padding:8px 12px;
        font-size:11px;
      }
    }

    /* Mobile: Stack form fields */
    @media (max-width: 640px){
      .row{
        flex-direction:column;
      }
      .field{
        min-width:100%;
      }
    }

    /* Mobile: Optimize message display */
    @media (max-width: 640px){
      .msg{
        max-width:88%;
        padding:12px 14px;
        font-size:15px;
        margin:8px 0;
      }
      .msg .text{
        font-size:15px;
        line-height:1.45;
        word-break:break-word;
      }
      .msg .meta{
        font-size:11px;
      }
      .msgs{
        flex:1;
        padding:10px;
        overflow-y:auto !important;
        overflow-x:hidden;
        -webkit-overflow-scrolling:touch;
        height:auto;
        min-height:0;
      }
      .chat{
        display:flex;
        flex-direction:column;
        height:100%;
        min-height:0;
      }
    }

    /* Mobile: Optimize composer */
    @media (max-width: 640px){
      .composer{
        padding:10px;
        gap:8px;
      }
      .composer textarea{
        font-size:14px;
        min-height:48px;
        padding:12px;
      }
      button{
        min-height:48px; /* Larger touch targets */
      }
    }

    /* Mobile: Adjust chat header */
    @media (max-width: 640px){
      .chatHeader{
        padding:10px;
        flex-wrap:wrap;
      }
      .chatHeader .meta .room{
        font-size:14px;
      }
      .chatHeader .meta .sub{
        font-size:10px;
      }
      .chatHeader .people{
        width:100%;
        margin-top:4px;
      }
    }

    /* Mobile: Toast positioning */
    @media (max-width: 640px){
      .toast-container{
        top:10px;
        right:10px;
        left:10px;
      }
      .toast{
        min-width:auto;
        width:100%;
      }
    }

    /* Mobile: Modal optimization */
    @media (max-width: 640px){
      .modalBackdrop, .modal-overlay{
        padding:12px;
      }
      .modal{
        width:100%;
        max-width:100%;
      }
      .modal .top, .modal-header{
        padding:10px 12px;
      }
      .modal .body, .modal-body{
        padding:12px;
      }
    }

    /* Mobile: Room browser */
    @media (max-width: 640px){
      .room-list{
        max-height:60vh;
      }
      .room-item{
        flex-direction:column;
        align-items:flex-start;
        padding:10px 12px;
      }
      .room-status{
        width:100%;
        justify-content:space-between;
        margin-top:6px;
      }
    }

    /* Mobile: Input fields larger for touch */
    @media (max-width: 640px){
      input, textarea{
        font-size:16px; /* Prevents zoom on iOS */
        padding:12px;
      }
    }

    /* Mobile: Adjust main grid */
    @media (max-width: 640px){
      main{
        padding:8px;
        gap:8px;
        height:calc(100% - 50px);
      }
      .panel{
        border-radius:14px;
      }
    }

    /* Mobile: Log panel */
    @media (max-width: 640px){
      .log{
        font-size:10px;
        max-height:80px;
        padding:8px 10px;
      }
      
      /* Audio controls for mobile */
      .audio-record-btn{
        width:48px;
        height:48px;
        font-size:22px;
      }
      
      .audio-modal-content{
        max-width:90%;
        padding:20px;
      }
      
      .audio-visualizer{
        height:60px;
      }
      
      .audio-timer{
        font-size:20px;
      }
      
      .audio-controls{
        flex-direction:column;
      }
      
      .audio-control-btn{
        width:100%;
        justify-content:center;
      }
      
      .msg-audio{
        min-width:240px;
        max-width:90%;
      }
      
      .audio-play-btn{
        width:38px;
        height:38px;
        min-width:38px;
        font-size:14px;
      }
    }

    /* Tablet: 641px - 1024px */
    @media (min-width: 641px) and (max-width: 1024px){
      main{
        max-width:768px;
        margin:0 auto;
      }
      .msg{
        max-width:75%;
      }
    }

    /* Desktop: 1025px+ */
    @media (min-width: 1025px){
      main{
        max-width:980px;
        margin:0 auto;
      }
      .row{
        flex-wrap:nowrap;
      }
      .msg{
        max-width:70%;
      }
    }

    /* Landscape mobile optimization */
    @media (max-width: 896px) and (orientation: landscape){
      main{
        height:calc(100% - 45px);
      }
      header{
        padding:8px 12px;
      }
      .chatHeader{
        padding:8px 10px;
      }
      .msgs{
        flex:1;
        height:auto;
        min-height:200px;
        max-height:none;
        overflow-y:auto !important;
      }
      .chat{
        min-height:calc(100vh - 80px);
        height:auto;
      }
      body{
        overflow-y:auto;
        overflow-x:hidden;
        height:auto;
        min-height:100vh;
      }
      .panel{
        min-height:calc(100vh - 80px);
      }
    }

    /* High DPI screens */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi){
      .panel::before{
        opacity:.7;
      }
    }

    /* Reduce motion for accessibility */
    @media (prefers-reduced-motion: reduce){
      *{
        animation-duration:0.01ms !important;
        animation-iteration-count:1 !important;
        transition-duration:0.01ms !important;
      }
    }

    /* Dark mode support (respects system preference) */
    @media (prefers-color-scheme: light){
      /* User can add light mode overrides here if needed */
    }

    /* ============================================================
       WELCOME SCREEN STYLES
       ============================================================ */
    .welcome-screen{
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:linear-gradient(135deg, rgba(15,23,42,.98), rgba(11,15,23,.95));
      z-index:99999;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
      overflow-y:auto;
      animation:fadeIn .6s ease-out;
      backdrop-filter:blur(20px);
    }
    .welcome-screen.hide{
      animation:fadeOut .5s ease-in forwards;
      pointer-events:none;
    }
    @keyframes fadeIn{
      from{ opacity:0; }
      to{ opacity:1; }
    }
    @keyframes fadeOut{
      from{ opacity:1; }
      to{ opacity:0; }
    }
    .welcome-container{
      max-width:650px;
      max-height:90vh;
      width:100%;
      background:linear-gradient(180deg, rgba(17,28,54,.95), rgba(15,23,42,.9));
      border:1px solid rgba(255,255,255,.15);
      border-radius:24px;
      padding:32px 28px;
      box-shadow:0 20px 60px rgba(0,0,0,.5), 0 0 1px rgba(255,255,255,.2);
      position:relative;
      overflow-y:auto;
      overflow-x:hidden;
      animation:slideUp .6s ease-out;
      /* Custom scrollbar */
      scrollbar-width:thin;
      scrollbar-color:rgba(56,189,248,.3) transparent;
    }
    .welcome-container::-webkit-scrollbar{
      width:8px;
    }
    .welcome-container::-webkit-scrollbar-track{
      background:transparent;
    }
    .welcome-container::-webkit-scrollbar-thumb{
      background:rgba(56,189,248,.3);
      border-radius:4px;
    }
    .welcome-container::-webkit-scrollbar-thumb:hover{
      background:rgba(56,189,248,.5);
    }
    @keyframes slideUp{
      from{ opacity:0; transform:translateY(30px); }
      to{ opacity:1; transform:translateY(0); }
    }
    .welcome-container::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:24px;
      padding:1px;
      background:linear-gradient(135deg, rgba(56,189,248,.3), transparent 40%, rgba(168,85,247,.25));
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite:exclude;
      pointer-events:none;
      opacity:.6;
    }
    .welcome-header{
      text-align:center;
      margin-bottom:24px;
      position:relative;
    }
    .welcome-logo{
      font-size:48px;
      margin-bottom:8px;
      display:inline-block;
      animation:float 3s ease-in-out infinite;
    }
    @keyframes float{
      0%, 100%{ transform:translateY(0px); }
      50%{ transform:translateY(-10px); }
    }
    .welcome-title{
      font-size:28px;
      font-weight:700;
      margin:0 0 8px 0;
      background:linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
    }
    .welcome-subtitle{
      font-size:15px;
      color:var(--muted);
      margin:0;
      line-height:1.5;
    }
    .welcome-features{
      display:grid;
      grid-template-columns:repeat(auto-fit, minmax(180px, 1fr));
      gap:12px;
      margin:20px 0;
    }
    .feature-card{
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.1);
      border-radius:14px;
      padding:16px;
      transition:all .3s ease;
      position:relative;
      overflow:hidden;
    }
    .feature-card::before{
      content:'';
      position:absolute;
      top:0; left:0; right:0;
      height:3px;
      background:linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
      transform:scaleX(0);
      transition:transform .3s ease;
    }
    .feature-card:hover{
      background:rgba(255,255,255,.06);
      border-color:rgba(56,189,248,.3);
      transform:translateY(-4px);
      box-shadow:0 8px 24px rgba(0,0,0,.3);
    }
    .feature-card:hover::before{
      transform:scaleX(1);
    }
    .feature-icon{
      font-size:28px;
      margin-bottom:8px;
      display:block;
    }
    .feature-title{
      font-size:14px;
      font-weight:650;
      margin:0 0 4px 0;
      color:var(--txt);
    }
    .feature-desc{
      font-size:12px;
      color:var(--muted);
      margin:0;
      line-height:1.4;
    }
    .welcome-actions{
      display:flex;
      gap:10px;
      margin-top:24px;
      justify-content:center;
      flex-wrap:wrap;
    }
    .welcome-btn{
      padding:12px 24px;
      border-radius:10px;
      border:1px solid var(--border);
      background:linear-gradient(135deg, rgba(56,189,248,.18), rgba(56,189,248,.12));
      border-color:rgba(56,189,248,.4);
      color:var(--accent-primary);
      font-size:14px;
      font-weight:600;
      cursor:pointer;
      transition:all .3s ease;
      box-shadow:0 4px 12px rgba(56,189,248,.2);
      position:relative;
      overflow:hidden;
    }
    .welcome-btn::before{
      content:'';
      position:absolute;
      top:50%; left:50%;
      width:0; height:0;
      border-radius:50%;
      background:rgba(255,255,255,.2);
      transform:translate(-50%, -50%);
      transition:width .5s, height .5s;
    }
    .welcome-btn:hover::before{
      width:300px;
      height:300px;
    }
    .welcome-btn:hover{
      transform:translateY(-2px);
      box-shadow:0 8px 24px rgba(56,189,248,.35);
      border-color:rgba(56,189,248,.6);
    }
    .welcome-btn.secondary{
      background:rgba(255,255,255,.05);
      border-color:rgba(255,255,255,.2);
      color:var(--txt);
      box-shadow:0 4px 12px rgba(0,0,0,.2);
    }
    .welcome-btn.secondary:hover{
      background:rgba(255,255,255,.08);
      box-shadow:0 8px 24px rgba(0,0,0,.3);
      border-color:rgba(255,255,255,.3);
    }
    .welcome-footer{
      text-align:center;
      margin-top:20px;
      padding-top:20px;
      border-top:1px solid rgba(255,255,255,.08);
    }
    .welcome-footer-text{
      font-size:12px;
      color:var(--muted);
      margin:0;
    }
    .welcome-skip{
      color:var(--accent-primary);
      text-decoration:none;
      cursor:pointer;
      transition:all .2s ease;
      position:relative;
    }
    .welcome-skip::after{
      content:'';
      position:absolute;
      bottom:-2px;
      left:0;
      right:0;
      height:1px;
      background:var(--accent-primary);
      transform:scaleX(0);
      transition:transform .2s ease;
    }
    .welcome-skip:hover{
      color:var(--accent-secondary);
    }
    .welcome-skip:hover::after{
      transform:scaleX(1);
    }
    /* Tablet adjustments */
    @media (max-width: 768px){
      .welcome-container{
        max-width:90%;
        max-height:85vh;
        padding:24px 20px;
      }
      .welcome-logo{
        font-size:42px;
      }
      .welcome-title{
        font-size:24px;
      }
      .welcome-subtitle{
        font-size:14px;
      }
      .welcome-features{
        grid-template-columns:repeat(2, 1fr);
        gap:10px;
      }
      .feature-card{
        padding:14px;
      }
      .feature-icon{
        font-size:24px;
      }
      .feature-title{
        font-size:13px;
      }
      .feature-desc{
        font-size:11px;
      }
    }
    /* Mobile adjustments */
    @media (max-width: 640px){
      .welcome-screen{
        padding:12px;
      }
      .welcome-container{
        max-width:100%;
        max-height:90vh;
        padding:20px 16px;
        border-radius:20px;
      }
      .welcome-header{
        margin-bottom:18px;
      }
      .welcome-logo{
        font-size:40px;
        margin-bottom:6px;
      }
      .welcome-title{
        font-size:22px;
      }
      .welcome-subtitle{
        font-size:13px;
      }
      .welcome-features{
        grid-template-columns:1fr;
        gap:10px;
        margin:16px 0;
      }
      .feature-card{
        padding:12px;
      }
      .feature-icon{
        font-size:24px;
        margin-bottom:6px;
      }
      .feature-title{
        font-size:13px;
        margin-bottom:3px;
      }
      .feature-desc{
        font-size:11px;
        line-height:1.35;
      }
      .welcome-actions{
        flex-direction:column;
        margin-top:18px;
        gap:8px;
      }
      .welcome-btn{
        width:100%;
        padding:11px 20px;
        font-size:14px;
      }
      .welcome-footer{
        margin-top:16px;
        padding-top:16px;
      }
    }
    /* Small mobile devices */
    @media (max-width: 375px){
      .welcome-container{
        padding:16px 12px;
      }
      .welcome-logo{
        font-size:36px;
      }
      .welcome-title{
        font-size:20px;
      }
      .welcome-subtitle{
        font-size:12px;
      }
      .feature-card{
        padding:10px;
      }
      .feature-icon{
        font-size:22px;
      }
      .feature-title{
        font-size:12px;
      }
      .feature-desc{
        font-size:10px;
      }
    }

    /* ============================================================
       TUTORIAL/LEARN MORE MODAL STYLES
       ============================================================ */
    .tutorial-modal{
      position:fixed;
      top:0; left:0; right:0; bottom:0;
      background:rgba(0,0,0,.85);
      backdrop-filter:blur(10px);
      z-index:100000;
      display:none;
      align-items:center;
      justify-content:center;
      padding:20px;
      animation:fadeIn .4s ease-out;
    }
    .tutorial-modal.show{
      display:flex;
    }
    .tutorial-container{
      max-width:750px;
      max-height:88vh;
      width:100%;
      background:linear-gradient(180deg, rgba(17,28,54,.98), rgba(15,23,42,.95));
      border:1px solid rgba(255,255,255,.15);
      border-radius:20px;
      overflow:hidden;
      box-shadow:0 25px 70px rgba(0,0,0,.6), 0 0 1px rgba(255,255,255,.2);
      display:flex;
      flex-direction:column;
      position:relative;
      animation:slideUp .5s ease-out;
    }
    .tutorial-container::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:20px;
      padding:1px;
      background:linear-gradient(135deg, rgba(56,189,248,.35), transparent 40%, rgba(168,85,247,.3));
      -webkit-mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      -webkit-mask-composite:xor;
      mask:linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
      mask-composite:exclude;
      pointer-events:none;
      opacity:.7;
    }
    .tutorial-header{
      padding:20px 24px;
      border-bottom:1px solid rgba(255,255,255,.1);
      display:flex;
      align-items:center;
      justify-content:space-between;
      background:rgba(0,0,0,.2);
      position:relative;
      z-index:1;
    }
    .tutorial-header-left{
      display:flex;
      align-items:center;
      gap:12px;
    }
    .tutorial-icon{
      font-size:28px;
    }
    .tutorial-header-text{
      display:flex;
      flex-direction:column;
      gap:2px;
    }
    .tutorial-title{
      font-size:18px;
      font-weight:700;
      margin:0;
      color:var(--txt);
    }
    .tutorial-subtitle{
      font-size:12px;
      color:var(--muted);
      margin:0;
    }
    .tutorial-close{
      width:36px;
      height:36px;
      border-radius:8px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.05);
      color:var(--txt);
      font-size:20px;
      cursor:pointer;
      transition:all .2s ease;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .tutorial-close:hover{
      background:rgba(255,255,255,.1);
      border-color:rgba(239,68,68,.4);
      color:var(--bad);
      transform:scale(1.05);
    }
    .tutorial-content{
      flex:1;
      overflow-y:auto;
      overflow-x:hidden;
      padding:24px;
      position:relative;
      z-index:1;
      scrollbar-width:thin;
      scrollbar-color:rgba(56,189,248,.3) transparent;
    }
    .tutorial-content::-webkit-scrollbar{
      width:8px;
    }
    .tutorial-content::-webkit-scrollbar-track{
      background:transparent;
    }
    .tutorial-content::-webkit-scrollbar-thumb{
      background:rgba(56,189,248,.3);
      border-radius:4px;
    }
    .tutorial-content::-webkit-scrollbar-thumb:hover{
      background:rgba(56,189,248,.5);
    }
    .tutorial-step{
      display:none;
      animation:fadeIn .4s ease-out;
    }
    .tutorial-step.active{
      display:block;
    }
    .tutorial-step-title{
      font-size:22px;
      font-weight:700;
      margin:0 0 14px 0;
      color:var(--txt);
      display:flex;
      align-items:center;
      gap:12px;
    }
    .tutorial-step-icon{
      font-size:30px;
    }
    .tutorial-step-desc{
      font-size:14px;
      color:var(--muted);
      line-height:1.6;
      margin:0 0 18px 0;
    }
    .tutorial-points{
      display:flex;
      flex-direction:column;
      gap:12px;
      margin:18px 0;
    }
    .tutorial-point{
      display:flex;
      gap:12px;
      align-items:flex-start;
      background:rgba(255,255,255,.04);
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      padding:13px;
      transition:all .2s ease;
    }
    .tutorial-point:hover{
      background:rgba(255,255,255,.06);
      border-color:rgba(56,189,248,.2);
      transform:translateX(4px);
    }
    .tutorial-point-icon{
      font-size:24px;
      flex-shrink:0;
      margin-top:2px;
    }
    .tutorial-point-content{
      flex:1;
    }
    .tutorial-point-title{
      font-size:14px;
      font-weight:650;
      margin:0 0 4px 0;
      color:var(--txt);
    }
    .tutorial-point-desc{
      font-size:13px;
      color:var(--muted);
      margin:0;
      line-height:1.55;
    }
    .tutorial-code{
      display:inline-block;
      background:rgba(56,189,248,.15);
      border:1px solid rgba(56,189,248,.3);
      padding:2px 8px;
      border-radius:6px;
      font-family:var(--mono);
      font-size:12px;
      color:var(--accent-primary);
    }
    .tutorial-highlight{
      color:var(--accent-primary);
      font-weight:600;
    }
    .tutorial-footer{
      padding:18px 24px;
      border-top:1px solid rgba(255,255,255,.1);
      background:rgba(0,0,0,.2);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      position:relative;
      z-index:1;
    }
    .tutorial-progress{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .tutorial-dot{
      width:10px;
      height:10px;
      border-radius:50%;
      background:rgba(255,255,255,.2);
      cursor:pointer;
      transition:all .3s ease;
    }
    .tutorial-dot.active{
      background:linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
      width:24px;
      border-radius:5px;
      box-shadow:0 0 12px rgba(56,189,248,.5);
    }
    .tutorial-dot:hover{
      background:rgba(255,255,255,.4);
      transform:scale(1.2);
    }
    .tutorial-nav{
      display:flex;
      gap:10px;
    }
    .tutorial-nav-btn{
      padding:10px 20px;
      border-radius:10px;
      border:1px solid var(--border);
      background:rgba(255,255,255,.05);
      color:var(--txt);
      font-size:14px;
      font-weight:600;
      cursor:pointer;
      transition:all .2s ease;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .tutorial-nav-btn:hover{
      background:rgba(255,255,255,.1);
      border-color:rgba(56,189,248,.4);
      transform:translateY(-1px);
    }
    .tutorial-nav-btn.primary{
      background:linear-gradient(135deg, rgba(56,189,248,.2), rgba(56,189,248,.15));
      border-color:rgba(56,189,248,.4);
      color:var(--accent-primary);
    }
    .tutorial-nav-btn.primary:hover{
      background:linear-gradient(135deg, rgba(56,189,248,.3), rgba(56,189,248,.2));
      border-color:rgba(56,189,248,.5);
      box-shadow:0 4px 12px rgba(56,189,248,.3);
    }
    .tutorial-nav-btn:disabled{
      opacity:.4;
      cursor:not-allowed;
      pointer-events:none;
    }
    /* Tablet landscape (769px-1024px) */
    @media (min-width: 769px) and (max-width: 1024px){
      .tutorial-container{
        max-width:90%;
        max-height:85vh;
      }
      .tutorial-content{
        padding:20px;
      }
    }
    /* Tablet portrait (641px-768px) */
    @media (max-width: 768px) and (min-width: 641px){
      .tutorial-container{
        max-width:92%;
        max-height:88vh;
      }
      .tutorial-header{
        padding:16px 18px;
      }
      .tutorial-title{
        font-size:17px;
      }
      .tutorial-icon{
        font-size:24px;
      }
      .tutorial-content{
        padding:18px;
      }
      .tutorial-step-title{
        font-size:19px;
      }
      .tutorial-step-icon{
        font-size:26px;
      }
      .tutorial-step-desc{
        font-size:13px;
      }
      .tutorial-point{
        padding:12px;
      }
      .tutorial-point-title{
        font-size:13px;
      }
      .tutorial-point-desc{
        font-size:12px;
      }
    }
    /* Mobile devices - Android & iOS (640px and below) */
    @media (max-width: 640px){
      .tutorial-modal{
        padding:10px;
      }
      .tutorial-container{
        max-width:100%;
        max-height:92vh;
        border-radius:18px;
      }
      .tutorial-header{
        padding:14px 16px;
      }
      .tutorial-title{
        font-size:16px;
      }
      .tutorial-subtitle{
        font-size:11px;
      }
      .tutorial-icon{
        font-size:22px;
      }
      .tutorial-content{
        padding:16px;
      }
      .tutorial-step-title{
        font-size:17px;
        flex-direction:row;
        align-items:center;
        gap:10px;
      }
      .tutorial-step-icon{
        font-size:24px;
      }
      .tutorial-step-desc{
        font-size:13px;
        line-height:1.55;
        margin:0 0 14px 0;
      }
      .tutorial-points{
        gap:10px;
        margin:14px 0;
      }
      .tutorial-point{
        padding:11px;
        gap:10px;
      }
      .tutorial-point-icon{
        font-size:20px;
      }
      .tutorial-point-title{
        font-size:13px;
      }
      .tutorial-point-desc{
        font-size:12px;
        line-height:1.5;
      }
      .tutorial-code{
        font-size:11px;
        padding:2px 6px;
      }
      .tutorial-footer{
        padding:12px 14px;
        flex-wrap:wrap;
        gap:10px;
      }
      .tutorial-progress{
        order:2;
        width:100%;
        justify-content:center;
      }
      .tutorial-nav{
        order:1;
        width:100%;
        justify-content:space-between;
      }
      .tutorial-nav-btn{
        flex:1;
        padding:10px 16px;
        font-size:13px;
      }
    }
    /* Small mobile devices (480px and below) */
    @media (max-width: 480px){
      .tutorial-modal{
        padding:8px;
      }
      .tutorial-container{
        max-height:94vh;
        border-radius:16px;
      }
      .tutorial-header{
        padding:12px 14px;
      }
      .tutorial-title{
        font-size:15px;
      }
      .tutorial-subtitle{
        font-size:10px;
      }
      .tutorial-icon{
        font-size:20px;
      }
      .tutorial-close{
        width:32px;
        height:32px;
        font-size:18px;
      }
      .tutorial-content{
        padding:14px;
      }
      .tutorial-step-title{
        font-size:16px;
        gap:8px;
      }
      .tutorial-step-icon{
        font-size:22px;
      }
      .tutorial-step-desc{
        font-size:12px;
        margin:0 0 12px 0;
      }
      .tutorial-points{
        gap:9px;
        margin:12px 0;
      }
      .tutorial-point{
        padding:10px;
        gap:9px;
        border-radius:10px;
      }
      .tutorial-point-icon{
        font-size:18px;
      }
      .tutorial-point-title{
        font-size:12px;
        margin:0 0 3px 0;
      }
      .tutorial-point-desc{
        font-size:11px;
        line-height:1.45;
      }
      .tutorial-code{
        font-size:10px;
        padding:1px 5px;
      }
      .tutorial-footer{
        padding:10px 12px;
      }
      .tutorial-dot{
        width:8px;
        height:8px;
      }
      .tutorial-dot.active{
        width:20px;
      }
      .tutorial-nav-btn{
        padding:9px 14px;
        font-size:12px;
      }
    }
    /* Extra small devices - Small Android phones (375px and below) */
    @media (max-width: 375px){
      .tutorial-container{
        max-height:95vh;
      }
      .tutorial-header{
        padding:10px 12px;
      }
      .tutorial-title{
        font-size:14px;
      }
      .tutorial-content{
        padding:12px;
      }
      .tutorial-step-title{
        font-size:15px;
      }
      .tutorial-step-icon{
        font-size:20px;
      }
      .tutorial-step-desc{
        font-size:11px;
      }
      .tutorial-point{
        padding:9px;
      }
      .tutorial-point-title{
        font-size:11px;
      }
      .tutorial-point-desc{
        font-size:10px;
      }
    }
    /* iOS safe area support for notched devices */
    @supports (padding: max(0px)){
      @media (max-width: 640px){
        .tutorial-modal{
          padding:max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right)) max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
        }
      }
    }
    /* Mobile landscape optimization (Android/iOS) */
    @media (max-width: 896px) and (orientation: landscape){
      .tutorial-modal{
        padding:8px;
      }
      .tutorial-container{
        max-height:96vh;
        max-width:95%;
      }
      .tutorial-header{
        padding:10px 14px;
      }
      .tutorial-title{
        font-size:15px;
      }
      .tutorial-subtitle{
        display:none; /* Hide subtitle in landscape to save space */
      }
      .tutorial-content{
        padding:14px 16px;
      }
      .tutorial-step-title{
        font-size:16px;
        margin-bottom:10px;
      }
      .tutorial-step-desc{
        font-size:12px;
        margin-bottom:12px;
      }
      .tutorial-points{
        gap:8px;
        margin:12px 0;
      }
      .tutorial-point{
        padding:9px;
      }
      .tutorial-point-title{
        font-size:12px;
      }
      .tutorial-point-desc{
        font-size:11px;
        line-height:1.4;
      }
      .tutorial-footer{
        padding:8px 12px;
      }
    }
  </style>
</head>
<body>
<!-- WELCOME SCREEN -->
<div class="welcome-screen" id="welcomeScreen">
  <div class="welcome-container">
    <div class="welcome-header">
      <div class="welcome-logo"></div>
      <h1 class="welcome-title">Chat P2P</h1>
      <p class="welcome-subtitle">Modern, real-time messaging - Connect instantly with anyone, anywhere</p>
    </div>

    <div class="welcome-features">
      <div class="feature-card">
        <span class="feature-icon"></span>
        <h3 class="feature-title">Instant Messaging</h3>
        <p class="feature-desc">Send text messages, emojis, and reactions in real-time</p>
      </div>
      <div class="feature-card">
        <span class="feature-icon"></span>
        <h3 class="feature-title">Voice Messages</h3>
        <p class="feature-desc">Record and share voice notes with one tap</p>
      </div>
      <div class="feature-card">
        <span class="feature-icon"></span>
        <h3 class="feature-title">Media Sharing</h3>
        <p class="feature-desc">Share photos, videos, and files effortlessly</p>
      </div>
      <div class="feature-card">
        <span class="feature-icon"></span>
        <h3 class="feature-title">Secure & Private</h3>
        <p class="feature-desc">Your conversations stay safe with modern security</p>
      </div>
      <div class="feature-card">
        <span class="feature-icon"></span>
        <h3 class="feature-title">Group Rooms</h3>
        <p class="feature-desc">Create or join rooms to chat with multiple people</p>
      </div>
      <div class="feature-card">
        <span class="feature-icon"></span>
        <h3 class="feature-title">Works Everywhere</h3>
        <p class="feature-desc">No downloads needed - works on any device with a browser</p>
      </div>
    </div>

    <div class="welcome-actions">
      <button class="welcome-btn" id="welcomeGetStarted">Get Started</button>
      <button class="welcome-btn secondary" id="welcomeLearnMore">Learn More</button>
    </div>

    <div class="welcome-footer">
      <p class="welcome-footer-text">
        <a class="welcome-skip" id="welcomeSkip">Skip intro</a>
      </p>
    </div>
  </div>
</div>

<!-- TUTORIAL/LEARN MORE MODAL -->
<div class="tutorial-modal" id="tutorialModal">
  <div class="tutorial-container">
    <div class="tutorial-header">
      <div class="tutorial-header-left">
        <span class="tutorial-icon"></span>
        <div class="tutorial-header-text">
          <h2 class="tutorial-title">How to Use Chat P2P</h2>
          <p class="tutorial-subtitle">Quick guide to get you started</p>
        </div>
      </div>
      <button class="tutorial-close" id="tutorialClose"></button>
    </div>
    
    <div class="tutorial-content" id="tutorialContent">
      <!-- Step 1: Getting Started -->
      <div class="tutorial-step active" data-step="1">
        <h3 class="tutorial-step-title">
          <span class="tutorial-step-icon"></span>
          <span>Getting Started</span>
        </h3>
        <p class="tutorial-step-desc">
          Welcome! Chat P2P is a modern messaging platform that lets you connect with anyone instantly. Here's how to begin your journey.
        </p>
        <div class="tutorial-points">
          <div class="tutorial-point">
            <span class="tutorial-point-icon">1</span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Choose a Room Name</h4>
              <p class="tutorial-point-desc">
                Enter any room name (e.g., <span class="tutorial-code">general</span>, <span class="tutorial-code">friends</span>, <span class="tutorial-code">team-project</span>). Anyone with the same room name can join the conversation.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon">2</span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Pick Your Display Name</h4>
              <p class="tutorial-point-desc">
                Choose a name that others will see. You can use your real name or a fun nickname. Make it memorable!
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon">3</span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Hit Join</h4>
              <p class="tutorial-point-desc">
                Click the <span class="tutorial-highlight">Join</span> button and you're in! Start chatting immediately.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Pro Tip: Browse Rooms</h4>
              <p class="tutorial-point-desc">
                After logging in, click <span class="tutorial-highlight">Browse Rooms</span> to discover active conversations and see who's online.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 2: Messaging Basics -->
      <div class="tutorial-step" data-step="2">
        <h3 class="tutorial-step-title">
          <span class="tutorial-step-icon"></span>
          <span>Messaging Basics</span>
        </h3>
        <p class="tutorial-step-desc">
          Master the art of messaging with these essential features and shortcuts.
        </p>
        <div class="tutorial-points">
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Send Messages</h4>
              <p class="tutorial-point-desc">
                Type your message and press <span class="tutorial-code">Enter</span> to send. Use <span class="tutorial-code">Shift + Enter</span> for a new line without sending.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon">@</span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Mention Someone</h4>
              <p class="tutorial-point-desc">
                Type <span class="tutorial-code">@username</span> to notify a specific person. They'll see a badge counter and the message will be highlighted.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Reply to Messages</h4>
              <p class="tutorial-point-desc">
                Hover over any message and click <span class="tutorial-highlight">Reply</span>. Your response will be linked to the original message.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Use Emojis</h4>
              <p class="tutorial-point-desc">
                Express yourself with emojis! They work in all messages and are displayed beautifully.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 3: Voice & Media -->
      <div class="tutorial-step" data-step="3">
        <h3 class="tutorial-step-title">
          <span class="tutorial-step-icon"></span>
          <span>Voice & Media Sharing</span>
        </h3>
        <p class="tutorial-step-desc">
          Go beyond text with rich media features including voice notes, images, and videos.
        </p>
        <div class="tutorial-points">
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Record Voice Messages</h4>
              <p class="tutorial-point-desc">
                Click the <span class="tutorial-highlight">microphone button</span> to record audio. On mobile, hold to record, slide up to lock, or slide left to cancel.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Share Photos & Videos</h4>
              <p class="tutorial-point-desc">
                Click the <span class="tutorial-highlight"> attachment button</span> to upload images and videos. You can send multiple files at once!
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Send Files</h4>
              <p class="tutorial-point-desc">
                Share documents (PDF, DOC, TXT) and compressed files (ZIP, RAR) with your team.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">View Media Gallery</h4>
              <p class="tutorial-point-desc">
                Click any image or video to open the viewer. Navigate between media items with arrow buttons.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 4: Advanced Features -->
      <div class="tutorial-step" data-step="4">
        <h3 class="tutorial-step-title">
          <span class="tutorial-step-icon"></span>
          <span>Advanced Features</span>
        </h3>
        <p class="tutorial-step-desc">
          Unlock the full potential of Chat P2P with these powerful features.
        </p>
        <div class="tutorial-points">
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Read Receipts</h4>
              <p class="tutorial-point-desc">
                See when your messages are <span class="tutorial-highlight">delivered</span> and <span class="tutorial-highlight">read</span>. Check marks show message status.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Unread & Mention Badges</h4>
              <p class="tutorial-point-desc">
                Never miss important messages! Badges show unread count and mentions with <span class="tutorial-highlight">@</span> symbol.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Fullscreen Mode</h4>
              <p class="tutorial-point-desc">
                Click the <span class="tutorial-highlight">fullscreen button</span> to focus on your conversation without distractions.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Pull to Refresh</h4>
              <p class="tutorial-point-desc">
                On mobile, pull down to manually refresh and check for new messages.
              </p>
            </div>
          </div>
        </div>
      </div>

      <!-- Step 5: Tips & Tricks -->
      <div class="tutorial-step" data-step="5">
        <h3 class="tutorial-step-title">
          <span class="tutorial-step-icon"></span>
          <span>Tips & Best Practices</span>
        </h3>
        <p class="tutorial-step-desc">
          Get the most out of Chat P2P with these helpful tips and tricks.
        </p>
        <div class="tutorial-points">
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Privacy First</h4>
              <p class="tutorial-point-desc">
                Your conversations are secure. Only people who know the room name can join. Choose unique room names for private chats.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Automatic Sync</h4>
              <p class="tutorial-point-desc">
                Messages sync automatically when you're active. The app is smart about network usage to save your data.
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Mobile Friendly</h4>
              <p class="tutorial-point-desc">
                Works perfectly on phones, tablets, and computers. No app download needed - just open in your browser!
              </p>
            </div>
          </div>
          <div class="tutorial-point">
            <span class="tutorial-point-icon"></span>
            <div class="tutorial-point-content">
              <h4 class="tutorial-point-title">Share Room Names</h4>
              <p class="tutorial-point-desc">
                Invite friends by sharing the room name and a link. Everyone with the room name can join the conversation.
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <div class="tutorial-footer">
      <div class="tutorial-progress" id="tutorialProgress">
        <span class="tutorial-dot active" data-step="1"></span>
        <span class="tutorial-dot" data-step="2"></span>
        <span class="tutorial-dot" data-step="3"></span>
        <span class="tutorial-dot" data-step="4"></span>
        <span class="tutorial-dot" data-step="5"></span>
      </div>
      <div class="tutorial-nav">
        <button class="tutorial-nav-btn" id="tutorialPrev" disabled> Previous</button>
        <button class="tutorial-nav-btn primary" id="tutorialNext">Next </button>
      </div>
    </div>
  </div>
</div>

<!-- Pull to Refresh Indicator -->
<div class="pull-refresh-indicator" id="pullRefreshIndicator">
  <span class="icon"></span>
  <span id="pullRefreshText">Pull to refresh</span>
</div>

<header>
  <div class="left">
    <h1>Chatp2p V6</h1>
    <span class="status"><span id="netDot" class="dot"></span><span id="netText">booting</span></span>
  </div>
  <div class="right">
    <span class="pill" id="authPill">Guest</span>
    <button id="browseRoomsBtn" class="browse-btn" style="display:none"> Browse Rooms</button>
    <button id="loginBtn">Login</button>
    <button id="registerBtn" class="primary">Register</button>
    <button id="logoutBtn" class="danger" style="display:none">Logout</button>
  </div>
</header>

<main>
  <section class="panel join">
    <div class="row">
      <div class="field">
        <label>Room</label>
        <input id="roomInput" placeholder="e.g. general" autocomplete="off"/>
      </div>
      <div class="field">
        <label>Display name</label>
        <input id="nameInput" placeholder="e.g. Sotravil" autocomplete="off"/>
      </div>
      <div class="field" style="max-width:170px">
        <label>Poll ms (on interaction)</label>
        <input id="pollInput" type="number" value="2000" min="500" step="100"/>
      </div>
    </div>
    <div class="row" style="align-items:center; justify-content:space-between">
      <div class="hint">
        No backend: <b>Writes</b> via GitHub Contents API, <b>Reads</b> via raw + ETag cache with API fallback.
        Idle = zero network. Active = fast sync.
      </div>
      <div style="display:flex; gap:10px">
        <button id="joinBtn" class="primary">Join</button>
        <button id="leaveBtn">Leave</button>
        <button id="syncBtn" style="display:none"> Check Messages</button>
      </div>
    </div>
  </section>

  <section class="panel chat" id="chatPanel" style="display:none">
    <div class="chatHeader">
      <div class="meta">
        <div class="room" id="roomTitle"></div>
        <div class="sub" id="roomSub">
          <span id="roomSubText"></span>
          <span class="cell-indicator" id="cellIndicator" title="Current viewing cell">
            <span id="cellViewingNum"></span>/<span id="cellTotalNum"></span>
          </span>
        </div>
      </div>
      <div class="people" id="presenceSummary">
        <span id="presenceText">presence: </span>
        <span class="badge" id="unreadBadge"></span>
        <span class="badge mention-badge" id="mentionBadge"></span>
      </div>
      <button id="fullscreenBtn" class="fullscreen-toggle" title="Fullscreen chat"></button>
    </div>

    <div class="msgs" id="messages"></div>

    <div class="composer">
      <div class="reply-preview" id="replyPreview">
        <div class="reply-preview-header">
          <span>Replying to <span id="replyToUser"></span></span>
          <button class="reply-preview-close" id="cancelReply" title="Cancel reply"></button>
        </div>
        <div class="reply-preview-text" id="replyToText"></div>
      </div>
      <div class="composer-main">
        <button id="mediaAttachBtn" class="media-attach-btn" title="Attach image, video, or file"></button>
        <button id="pasteClipboardBtn" class="paste-clipboard-btn" title="Paste image from clipboard"></button>
        <input type="file" id="mediaFileInput" style="display:none" multiple accept="image/*,video/*,.pdf,.doc,.docx,.txt,.zip,.rar" />
        <button id="audioRecordBtn" class="audio-record-btn" title="Record audio message"></button>
        <textarea id="msgInput" placeholder="Type (Enter to send  Shift+Enter for newline)"></textarea>
        <button id="sendBtn" class="primary">Send</button>
        <button id="clearBtn">Clear view</button>
      </div>
    </div>

    <!-- Audio Recording Modal -->
    <div class="audio-modal" id="audioModal">
      <div class="audio-modal-content">
        <div class="audio-modal-header">
          <span class="audio-modal-title"> Recording Audio</span>
          <button class="audio-close-btn" id="audioCloseBtn"></button>
        </div>
        <div class="audio-visualizer" id="audioVisualizer">
          <!-- Waveform bars will be generated here -->
        </div>
        <div class="audio-timer" id="audioTimer">0:00</div>
        <div class="audio-controls">
          <button class="audio-control-btn record" id="audioStopBtn"> Stop</button>
          <button class="audio-control-btn pause" id="audioPauseBtn"> Pause</button>
          <button class="audio-control-btn send" id="audioSendBtn" style="display:none;"> Send</button>
        </div>
      </div>
    </div>

    <!-- Mobile Gesture Hints -->
    <div class="recording-overlay" id="recordingOverlay"></div>
    <div class="gesture-hint" id="gestureHint">
      <div class="gesture-lock" id="gestureLock"></div>
      <div class="gesture-cancel" id="gestureCancel"></div>
      <div class="gesture-text" id="gestureText">Hold to record</div>
    </div>

    <!-- Image Viewer Modal -->
    <div class="image-viewer" id="imageViewer">
      <div class="image-viewer-header">
        <div class="image-viewer-counter" id="imageViewerCounter">1 / 1</div>
        <div class="image-viewer-actions">
          <button class="image-viewer-btn" id="imageViewerDownload"> Download</button>
          <button class="image-viewer-btn" id="imageViewerClose"> Close</button>
        </div>
      </div>
      <div class="image-viewer-content" id="imageViewerContent">
        <img class="image-viewer-img" id="imageViewerImg" src="" alt="" />
        <button class="image-viewer-nav prev" id="imageViewerPrev"></button>
        <button class="image-viewer-nav next" id="imageViewerNext"></button>
      </div>
    </div>

    <!-- Gallery Drawer Modal -->
    <div class="gallery-drawer" id="galleryDrawer">
      <div class="gallery-drawer-header">
        <div class="gallery-drawer-title" id="galleryDrawerTitle">All Images</div>
        <button class="gallery-drawer-close" id="galleryDrawerClose"></button>
      </div>
      <div class="gallery-drawer-content" id="galleryDrawerContent">
        <!-- Gallery items will be dynamically added here -->
      </div>
    </div>

    <!-- Media Upload Progress -->
    <div class="media-upload-progress" id="mediaUploadProgress" style="display:none">
      <div class="media-upload-progress-text" id="mediaUploadProgressText">Uploading...</div>
      <div class="media-upload-progress-bar">
        <div class="media-upload-progress-fill" id="mediaUploadProgressFill" style="width:0%"></div>
      </div>
    </div>

    <!-- Media Preview Modal (WhatsApp-style) -->
    <div class="media-preview-modal" id="mediaPreviewModal">
      <div class="media-preview-header">
        <div class="media-preview-title" id="mediaPreviewTitle">Send Media</div>
        <button class="media-preview-close" id="mediaPreviewClose"></button>
      </div>
      <div class="media-preview-content" id="mediaPreviewContent">
        <!-- Media items with caption inputs will be dynamically added here -->
      </div>
      <div class="media-preview-footer">
        <div class="media-preview-counter" id="mediaPreviewCounter">
          <!-- Shows count like "3 files" -->
        </div>
        <button class="btn btn-ghost" id="mediaPreviewCancel">Cancel</button>
        <button class="btn primary media-preview-send-btn" id="mediaPreviewSend">Send</button>
      </div>
    </div>

    <div class="log" id="log"></div>
  </section>
</main>

<!-- AUTH MODAL -->
<div class="modalBackdrop" id="authModalBack">
  <div class="modal">
    <div class="top">
      <b id="authModalTitle">Auth</b>
      <button id="authCloseBtn"></button>
    </div>
    <div class="body">
      <div class="field">
        <label>Username (global)</label>
        <input id="authUserInput" placeholder="username" autocomplete="username"/>
      </div>
      <div class="field">
        <label>Password (dictionaryvalidated)</label>
        <input id="authPassInput" type="password" placeholder="password" autocomplete="current-password"/>
        <div class="hint" id="dictHint">Loading password dictionary</div>
      </div>
      <div class="hint" id="authMsg"></div>
    </div>
    <div class="footer">
      <button id="authActionBtn" class="primary">OK</button>
    </div>
  </div>
</div>

<script>
/* ============================================================
   CONFIG
   ============================================================ */

// Repo target (your "backend")
const GH_OWNER  = "Sotravil";
const GH_REPO   = "chat-db";
const GH_BRANCH = "main";

// Token from paste.rs (read-only) via CORS proxy
const TOKEN_PASTE_URL = "https://paste.rs/4UElW.txt";
const CORS_PROXY      = "https://corsproxy.io/?";

// Read receipts / presence
const PRESENCE_ACTIVE_HEARTBEAT_MS = 10_000;   // 10s while ACTIVE
const PRESENCE_RECENT_MS           = 5 * 60_000; // 5 min "recent"

// === ACTIVITY TRACKER ===
const POLL_MS_BURST          = 300;     //  300ms - Ultra rpido durante conversacin activa
const POLL_MS_INTERACTION    = 2000;    // Check after interaction
const POLL_BURST_DURATION    = 10_000;  // 10s burst after sending message
const POLL_MS_IDLE           = 90_000;  // 90s (for presence only)
const IDLE_THRESHOLD_MS      = 2_000;   // 2s since last interaction => idle
const ACTIVE_BURST_MS        = 2_000;   // keep active for 2s after last interaction
const INTERACTION_THROTTLE_MS= 150;     // update timestamps at most every 150ms

// === V3 STORAGE ===
const MANIFEST_VERSION_V3 = 3;

// micro-segmentation
const CELL_MAX_MESSAGES = 4;         // 4 messages per cell (you requested)
const BOX_MAX_CELLS     = 100;       // 100 cells per box (you requested)
const CELLS_PER_BOX     = BOX_MAX_CELLS;

// Paths
const ROOMS_DIR        = "rooms";
const ROOMS_META_DIR   = "rooms-meta";
const ROOMS_CELLS_BASE = "rooms-cells"; // V3 base
const MASTER_ROOMS_DIR = "master-rooms"; // Master sync files

// Password dictionary (immutable / READ ONLY)
const PASSWORD_DICTIONARY_PATH = "config/password_dictionary_v1.json";

/* ============================================================
   DOM
   ============================================================ */
const el = (id)=>document.getElementById(id);
const netDot = el("netDot");
const netText= el("netText");

const authPill   = el("authPill");
const loginBtn   = el("loginBtn");
const registerBtn= el("registerBtn");
const logoutBtn  = el("logoutBtn");
const browseRoomsBtn = el("browseRoomsBtn");

const authModalBack = el("authModalBack");
const authModalTitle= el("authModalTitle");
const authCloseBtn  = el("authCloseBtn");
const authActionBtn = el("authActionBtn");
const authUserInput = el("authUserInput");
const authPassInput = el("authPassInput");
const dictHint      = el("dictHint");
const authMsg       = el("authMsg");

const roomInput  = el("roomInput");
const nameInput  = el("nameInput");
const pollInput  = el("pollInput");
const joinBtn    = el("joinBtn");
const leaveBtn   = el("leaveBtn");
const syncBtn    = el("syncBtn");
const fullscreenBtn = el("fullscreenBtn");

const chatPanel  = el("chatPanel");
const roomTitle  = el("roomTitle");
const roomSub    = el("roomSub");
const roomSubText = el("roomSubText");
const cellIndicator = el("cellIndicator");
const cellViewingNum = el("cellViewingNum");
const cellTotalNum = el("cellTotalNum");
const presenceSummary = el("presenceSummary");
const presenceText = el("presenceText");
const unreadBadge = el("unreadBadge");
const mentionBadge = el("mentionBadge");

const messagesEl = el("messages");
const msgInput   = el("msgInput");
const sendBtn    = el("sendBtn");
const audioRecordBtn = el("audioRecordBtn");
const audioModal = el("audioModal");
const audioCloseBtn = el("audioCloseBtn");
const audioVisualizer = el("audioVisualizer");
const audioTimer = el("audioTimer");
const audioStopBtn = el("audioStopBtn");
const audioPauseBtn = el("audioPauseBtn");
const audioSendBtn = el("audioSendBtn");
const recordingOverlay = el("recordingOverlay");
const gestureHint = el("gestureHint");
const gestureLock = el("gestureLock");
const gestureCancel = el("gestureCancel");
const gestureText = el("gestureText");
const clearBtn   = el("clearBtn");
const replyPreview = el("replyPreview");
const replyToUser = el("replyToUser");
const replyToText = el("replyToText");
const cancelReply = el("cancelReply");
const logEl      = el("log");
const pullRefreshIndicator = el("pullRefreshIndicator");
const pullRefreshText = el("pullRefreshText");

// Media DOM elements
const mediaAttachBtn = el("mediaAttachBtn");
const pasteClipboardBtn = el("pasteClipboardBtn");
const mediaFileInput = el("mediaFileInput");
const imageViewer = el("imageViewer");
const imageViewerImg = el("imageViewerImg");
const imageViewerCounter = el("imageViewerCounter");
const imageViewerPrev = el("imageViewerPrev");
const imageViewerNext = el("imageViewerNext");
const imageViewerClose = el("imageViewerClose");
const imageViewerDownload = el("imageViewerDownload");
const imageViewerContent = el("imageViewerContent");
const galleryDrawer = el("galleryDrawer");
const galleryDrawerTitle = el("galleryDrawerTitle");
const galleryDrawerClose = el("galleryDrawerClose");
const galleryDrawerContent = el("galleryDrawerContent");
const mediaUploadProgress = el("mediaUploadProgress");
const mediaUploadProgressText = el("mediaUploadProgressText");
const mediaUploadProgressFill = el("mediaUploadProgressFill");

// Welcome Screen DOM elements
const welcomeScreen = el("welcomeScreen");
const welcomeGetStarted = el("welcomeGetStarted");
const welcomeLearnMore = el("welcomeLearnMore");
const welcomeSkip = el("welcomeSkip");

/* ============================================================
   WELCOME SCREEN LOGIC
   ============================================================ */
// Check if user has seen the welcome screen before
const WELCOME_SEEN_KEY = "chatP2P_welcomeSeen";

// === TESTING/DEBUG MODE ===
// Check URL parameters for testing mode
const urlParams = new URLSearchParams(window.location.search);
const forceWelcome = urlParams.has('welcome') || urlParams.has('test') || urlParams.has('debug');

// Check localStorage (can be overridden by URL params)
let hasSeenWelcome = !forceWelcome && localStorage.getItem(WELCOME_SEEN_KEY) === "true";

// Global functions for testing (accessible from console)
window.resetWelcome = function(){
  localStorage.removeItem(WELCOME_SEEN_KEY);
  return "Reload the page to see the welcome screen";
};

window.showWelcome = function(){
  welcomeScreen.style.display = "flex";
  welcomeScreen.classList.remove("hide");
};

window.showTutorial = function(){
  showTutorialModal();
};

// Hide welcome screen and show main app
function hideWelcomeScreen(){
  welcomeScreen.classList.add("hide");
  setTimeout(()=>{
    welcomeScreen.style.display = "none";
  }, 500); // Match animation duration
  localStorage.setItem(WELCOME_SEEN_KEY, "true");
  hasSeenWelcome = true;
}

// Show welcome screen on first visit
function initWelcomeScreen(){
  if(hasSeenWelcome){
    welcomeScreen.style.display = "none";
  }else{
    welcomeScreen.style.display = "flex";
  }
  
  // Get Started button - scroll to join section
  welcomeGetStarted.addEventListener("click", ()=>{
    hideWelcomeScreen();
    // Focus on room input for better UX
    setTimeout(()=>{
      roomInput.focus();
    }, 600);
  });
  
  // Learn More button - expand features and focus on room
  welcomeLearnMore.addEventListener("click", ()=>{
    hideWelcomeScreen();
    // Show tutorial modal after welcome screen fades out
    setTimeout(()=>{
      showTutorialModal();
    }, 600);
  });
  
  // Skip link
  welcomeSkip.addEventListener("click", (e)=>{
    e.preventDefault();
    hideWelcomeScreen();
  });
  
  // Keyboard shortcut for testing: Ctrl+Shift+W
  document.addEventListener("keydown", (e)=>{
    if(e.ctrlKey && e.shiftKey && e.key === 'W'){
      e.preventDefault();
      if(welcomeScreen.style.display === "none" || welcomeScreen.classList.contains("hide")){
        window.showWelcome();
      }else{
        hideWelcomeScreen();
      }
    }
  });
}

// Initialize welcome screen on page load
initWelcomeScreen();

/* ============================================================
   TUTORIAL MODAL LOGIC
   ============================================================ */
const tutorialModal = el("tutorialModal");
const tutorialClose = el("tutorialClose");
const tutorialContent = el("tutorialContent");
const tutorialPrev = el("tutorialPrev");
const tutorialNext = el("tutorialNext");
const tutorialProgress = el("tutorialProgress");

let currentTutorialStep = 1;
const totalTutorialSteps = 5;

function showTutorialModal(){
  tutorialModal.classList.add("show");
  currentTutorialStep = 1;
  updateTutorialStep();
}

function hideTutorialModal(){
  tutorialModal.classList.remove("show");
}

function updateTutorialStep(){
  // Update step visibility
  const steps = tutorialContent.querySelectorAll(".tutorial-step");
  steps.forEach((step, index) => {
    step.classList.toggle("active", (index + 1) === currentTutorialStep);
  });
  
  // Update progress dots
  const dots = tutorialProgress.querySelectorAll(".tutorial-dot");
  dots.forEach((dot, index) => {
    dot.classList.toggle("active", (index + 1) === currentTutorialStep);
  });
  
  // Update navigation buttons
  tutorialPrev.disabled = currentTutorialStep === 1;
  
  if(currentTutorialStep === totalTutorialSteps){
    tutorialNext.textContent = "Get Started! ";
  }else{
    tutorialNext.textContent = "Next ";
  }
  
  // Scroll to top of content
  tutorialContent.scrollTop = 0;
}

function nextTutorialStep(){
  if(currentTutorialStep < totalTutorialSteps){
    currentTutorialStep++;
    updateTutorialStep();
  }else{
    // Last step - close tutorial and hide welcome
    hideTutorialModal();
    hideWelcomeScreen();
    setTimeout(()=>{
      roomInput.focus();
    }, 600);
  }
}

function prevTutorialStep(){
  if(currentTutorialStep > 1){
    currentTutorialStep--;
    updateTutorialStep();
  }
}

function goToTutorialStep(step){
  if(step >= 1 && step <= totalTutorialSteps){
    currentTutorialStep = step;
    updateTutorialStep();
  }
}

// Tutorial event listeners
tutorialClose.addEventListener("click", hideTutorialModal);
tutorialNext.addEventListener("click", nextTutorialStep);
tutorialPrev.addEventListener("click", prevTutorialStep);

// Progress dot navigation
tutorialProgress.addEventListener("click", (e)=>{
  if(e.target.classList.contains("tutorial-dot")){
    const step = parseInt(e.target.dataset.step);
    goToTutorialStep(step);
  }
});

// Close on backdrop click
tutorialModal.addEventListener("click", (e)=>{
  if(e.target === tutorialModal){
    hideTutorialModal();
  }
});

// Keyboard navigation for tutorial
document.addEventListener("keydown", (e)=>{
  if(tutorialModal.classList.contains("show")){
    if(e.key === "Escape"){
      hideTutorialModal();
    }else if(e.key === "ArrowRight" || e.key === "ArrowDown"){
      e.preventDefault();
      nextTutorialStep();
    }else if(e.key === "ArrowLeft" || e.key === "ArrowUp"){
      e.preventDefault();
      prevTutorialStep();
    }
  }
});

/* ============================================================
   UTIL
   ============================================================ */
function log(msg, level="INFO"){
  const now = new Date();
  const hh = String(now.getHours()).padStart(2,"0");
  const mm = String(now.getMinutes()).padStart(2,"0");
  const ss = String(now.getSeconds()).padStart(2,"0");
  const line = document.createElement("div");
  line.textContent = `[${hh}:${mm}:${ss}] [${level}] ${msg}`;
  logEl.appendChild(line);
  logEl.scrollTop = logEl.scrollHeight;
}
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function pad6(n){ return String(n).padStart(6,"0"); }
function padBox(n){ return String(n).padStart(6,"0"); }
function b64EncodeUtf8(str){ return btoa(unescape(encodeURIComponent(str))); }
function b64DecodeUtf8(b64){ return decodeURIComponent(escape(atob(b64))); }
function buildProxyUrl(url){
  // Supports urls that arrive already URL-encoded
  let target=url;
  try{
    const decoded = decodeURIComponent(url);
    if(decoded.startsWith("http://") || decoded.startsWith("https://")) target = decoded;
  }catch(_){}
  return `${CORS_PROXY}${target}`;
}
function ghFileUrl(path){
  const encoded = encodeURIComponent(path).replace(/%2F/g,"/");
  return `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${encoded}`;
}
function rawUrl(path){
  const clean = path.replace(/^\/+/,"");
  return `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${clean}`;
}
function setNet(state, text){
  netText.textContent = text;
  netDot.classList.remove("ok","bad");
  if(state==="ok"){ netDot.classList.add("ok"); }
  if(state==="bad"){ netDot.classList.add("bad"); }
}

/* ============================================================
   TOAST NOTIFICATIONS
   ============================================================ */
let toastContainer = null;

function ensureToastContainer(){
  if(!toastContainer){
    toastContainer = document.createElement('div');
    toastContainer.className = 'toast-container';
    document.body.appendChild(toastContainer);
  }
  return toastContainer;
}

function showToast(message, type='info', duration=4000){
  const container = ensureToastContainer();
  
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  
  const icon = document.createElement('div');
  icon.className = 'toast-icon';
  const icons = {
    success: '',
    error: '',
    warning: '',
    info: ''
  };
  icon.textContent = icons[type] || icons.info;
  
  const msg = document.createElement('div');
  msg.className = 'toast-message';
  msg.textContent = message;
  
  const closeBtn = document.createElement('button');
  closeBtn.className = 'toast-close';
  closeBtn.textContent = '';
  closeBtn.onclick = () => removeToast(toast);
  
  toast.appendChild(icon);
  toast.appendChild(msg);
  toast.appendChild(closeBtn);
  
  container.appendChild(toast);
  
  // Auto remove after duration
  if(duration > 0){
    setTimeout(() => removeToast(toast), duration);
  }
  
  return toast;
}

function removeToast(toast){
  if(!toast || !toast.parentElement) return;
  toast.classList.add('toast-out');
  setTimeout(() => {
    if(toast.parentElement) toast.parentElement.removeChild(toast);
  }, 250);
}

/* ============================================================
   TOKEN LOADER (paste.rs -> extract github_pat_ from HTML)
   ============================================================ */
let GH_TOKEN = null;
let ghTokenReady = false;
let ghTokenPromise = null;

async function loadGhTokenFromPaste(){
  const url = buildProxyUrl(TOKEN_PASTE_URL);
  const res = await fetch(url, { headers:{ "Accept":"text/plain" }});
  if(!res.ok) throw new Error(`Token paste read failed status=${res.status}`);
  let html = await res.text();
  html = html.replace(/\r\n/g,"\n");
  const patRegex = /github_pat_[^<\s"]+/;
  const match = html.match(patRegex);
  if(!match) throw new Error("No github_pat_ found in paste HTML.");
  GH_TOKEN = match[0].trim();
  ghTokenReady = true;
  // Safe log (no token leakage)
  log(" GitHub token loaded (safe).","INFO");
  setNet("ok","token ok");
}

async function ensureGhToken(){
  if(ghTokenReady && GH_TOKEN) return;
  if(ghTokenPromise){ await ghTokenPromise; return; }
  ghTokenPromise = loadGhTokenFromPaste();
  await ghTokenPromise;
}

/* ============================================================
   GITHUB HELPERS (ETag raw read + Contents API fallback)
   ============================================================ */

// In-memory ETag cache per raw URL
const RAW_ETAG = new Map(); // key: rawUrl -> {etag, text}

// In-memory SHA cache to avoid CORS preflight requests
const SHA_CACHE = new Map(); // key: path -> {sha, timestamp}
const SHA_CACHE_TTL = 15000; // 15 seconds cache validity (reduced to minimize conflicts)

// Get cached SHA if valid
function getCachedSha(path){
  const cached = SHA_CACHE.get(path);
  if(!cached) return null;
  
  // Check if cache expired
  if(Date.now() - cached.timestamp > SHA_CACHE_TTL){
    SHA_CACHE.delete(path);
    return null;
  }
  
  return cached.sha;
}

// Cache SHA after successful operations
function cacheSha(path, sha){
  if(!sha || typeof sha !== 'string') return;
  SHA_CACHE.set(path, {
    sha,
    timestamp: Date.now()
  });
}

// Clear cached SHA (useful for retry scenarios)
function clearCachedSha(path){
  SHA_CACHE.delete(path);
  console.log(`[clearCachedSha] Cleared cached SHA for ${path}`);
}

// Fetch with timeout wrapper
async function fetchWithTimeout(url, options = {}, timeoutMs = 25000) {
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(url, {
      ...options,
      signal: controller.signal
    });
    clearTimeout(timeoutId);
    return response;
  } catch (error) {
    clearTimeout(timeoutId);
    if (error.name === 'AbortError') {
      throw new Error(`Request timeout after ${timeoutMs}ms`);
    }
    throw error;
  }
}

// Retry wrapper with exponential backoff
async function fetchWithRetry(url, options = {}, retries = 2, timeoutMs = 25000) {
  let lastError;
  
  for (let attempt = 0; attempt <= retries; attempt++) {
    try {
      return await fetchWithTimeout(url, options, timeoutMs);
    } catch (error) {
      lastError = error;
      
      if (attempt < retries) {
        const delay = Math.min(1000 * Math.pow(2, attempt), 5000); // 1s, 2s, 4s max
        console.warn(`[Retry ${attempt + 1}/${retries}] ${error.message} - waiting ${delay}ms`);
        await sleep(delay);
      }
    }
  }
  
  throw lastError;
}

async function rawGetText(path){
  const url = rawUrl(path);
  const headers = {};
  const cached = RAW_ETAG.get(url);
  if(cached?.etag) headers["If-None-Match"] = cached.etag;

  try {
    const res = await fetchWithRetry(url, { method:"GET", headers }, 1, 15000); // 15s timeout, 1 retry
    if(res.status === 304 && cached) return { ok:true, status:304, text: cached.text, etag: cached.etag };
    if(!res.ok) return { ok:false, status:res.status, text:"", etag:null };
    const etag = res.headers.get("etag");
    const text = await res.text();
    if(etag) RAW_ETAG.set(url, { etag, text });
    return { ok:true, status:res.status, text, etag };
  } catch (error) {
    console.error('[rawGetText] Failed:', error.message);
    return { ok:false, status:0, text:"", etag:null, error: error.message };
  }
}

// Contents GET JSON + sha
// forceApi: true = usa API (instantneo, consume rate limit), false = usa Raw (cach 5min, ahorra rate limit)
async function ghGetJsonWithSha(path, forceApi = false){
  // MODO HBRIDO:
  // - forceApi=false: Raw primero (para historial, media, datos viejos) - Cach 5 min pero ahorra rate limit
  // - forceApi=true: API directa (para master flag, ltima celda, ndice) - Instantneo pero consume rate limit
  
  if(!forceApi){
    // Modo Raw: Rpido pero con cach de 5 minutos (perfecto para historial)
    const rawResult = await rawGetText(path);
    if(rawResult.ok){
      try{
        const obj = JSON.parse(rawResult.text);
        console.log(` [Raw] ${path.split('/').pop()} (cached, fast)`);
        return {ok:true, obj, sha:null, status:200, source:'raw-cached', rawText:rawResult.text};
      }catch(e){
        console.warn('[ghGetJsonWithSha] Raw parse failed:', e.message);
      }
    }
  }
  
  // Modo API: Instantneo, siempre datos frescos (para tiempo real)
  await ensureGhToken();
  
  try {
    // Cache busting: timestamp + random para evitar CUALQUIER cach
    const antiCache = forceApi ? `?t=${Date.now()}&r=${Math.random().toString(36).slice(2)}` : '';
    const res = await fetchWithRetry(ghFileUrl(path) + antiCache, {
      method:"GET",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`
      },
      cache: 'no-store'
    }, 1, 40000);

    if(res.status===404) return { ok:false, status:404, obj:null, sha:null, rawText:null };
    const rawText = await res.text();
    if(!res.ok) return { ok:false, status:res.status, obj:null, sha:null, rawText };
    const data = JSON.parse(rawText);
    const contentB64 = (data.content||"").replace(/\n/g,"");
    const jsonText = contentB64 ? b64DecodeUtf8(contentB64) : "";
    const obj = jsonText.trim() ? JSON.parse(jsonText) : null;
    console.log(` [API] ${path.split('/').pop()} (fresh, instant)${forceApi ? ' [FORCED]' : ''}`);
    return { ok:true, status:res.status, obj, sha:data.sha||null, rawText, source:'api' };
  } catch (error) {
    console.error('[ghGetJsonWithSha] API fallback failed:', path, error.message);
    return { ok:false, status:0, obj:null, sha:null, rawText:null, error: error.message };
  }
}

// Fetch ONLY the SHA from GitHub API (for updates)
async function ghGetSha(path){
  await ensureGhToken();
  try {
    const res = await fetchWithRetry(ghFileUrl(path), {
      method:"GET",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`
      },
      cache: 'no-store'
    }, 1, 40000);

    if(res.status===404) return null; // File doesn't exist
    if(!res.ok) return null;
    const data = await res.json();
    return data.sha || null;
  } catch (error) {
    console.error('[ghGetSha] Failed:', path, error.message);
    return null;
  }
}

// Contents PUT File (for binary data like audio)
async function ghPutFile(path, base64Content, sha=null, message="upload file"){
  await ensureGhToken();
  const body = {
    message: `${message} ${new Date().toISOString()}`,
    content: base64Content,
    branch: GH_BRANCH
  };
  // CRITICAL: Only add sha if it's a valid string. undefined = omit property entirely
  if(sha !== undefined && sha !== null && typeof sha === 'string' && sha.length > 0){
    body.sha = sha;
  }
  // If sha is undefined/null/empty = new file creation (no sha property in body)

  // Try PUT, and on 422/409 attempt one retry by fetching current sha
  const doPut = async (putBody) => {
    const res = await fetchWithRetry(ghFileUrl(path), {
      method:"PUT",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`,
        "Content-Type":"application/json"
      },
      body: JSON.stringify(putBody)
    }, 1, 60000); // 60s timeout for PUT (GitHub is very slow), 1 retry
    const raw = await res.text();
    return { res, raw };
  };

  let attempt = 0;
  let lastErr = null;
  while(attempt < 2){
    try {
      const { res, raw } = await doPut(body);
      if(res.ok){
        const data = JSON.parse(raw || '{}');
        return { ok:true, status: res.status, sha: data?.content?.sha || null, url: data?.content?.download_url || null };
      }

      // If GitHub complains about missing sha or conflict, try to GET current sha and retry once
      if((res.status === 422 || res.status === 409) && attempt === 0){
        try{
          const got = await ghGetJsonWithSha(path);
          if(got.sha) body.sha = got.sha;
          else body.sha = null;
          attempt++;
          continue;
        }catch(e){
          lastErr = e;
          break;
        }
      }

      // Other failures: capture and throw
      console.error("[ghPutFile ERROR]", {path, status: res.status, raw});
      lastErr = new Error(`ghPutFile failed status=${res.status} path=${path}`);
      break;
    } catch (error) {
      console.error("[ghPutFile EXCEPTION]", {path, error: error.message});
      lastErr = error;
      if (attempt === 0 && error.message.includes('timeout')) {
        attempt++;
        await sleep(2000);
        continue;
      }
      break;
    }
  }

  throw lastErr || new Error(`ghPutFile failed for ${path}`);
}

// Contents PUT JSON
async function ghPutJson(path, obj, sha=null, message="update"){
  await ensureGhToken();
  const jsonText = JSON.stringify(obj, null, 2);
  const body = {
    message: `${message} ${new Date().toISOString()}`,
    content: b64EncodeUtf8(jsonText),
    branch: GH_BRANCH
  };
  
  // Try to use cached SHA first if no SHA provided
  if(!sha){
    const cachedSha = getCachedSha(path);
    if(cachedSha){
      sha = cachedSha;
      console.log('[ghPutJson] Using cached SHA for', path);
    }
  }
  
  // CRITICAL: Only add sha if it's a valid string. undefined = omit property entirely
  if(sha !== undefined && sha !== null && typeof sha === 'string' && sha.length > 0){
    body.sha = sha;
  }
  // If sha is undefined/null/empty = new file creation (no sha property in body)

  // Try PUT, and on 422/409 attempt one retry by fetching current sha.
  const doPut = async (putBody) => {
    const res = await fetchWithRetry(ghFileUrl(path), {
      method:"PUT",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`,
        "Content-Type":"application/json"
      },
      body: JSON.stringify(putBody)
    }, 1, 60000); // 60s timeout for PUT (GitHub API very slow), 1 retry
    const raw = await res.text();
    return { res, raw };
  };

  let attempt = 0;
  let lastErr = null;
  const MAX_RETRIES = 4; // Increased from 2 to handle concurrent updates
  
  while(attempt < MAX_RETRIES){
    try {
      const { res, raw } = await doPut(body);
    if(res.ok){
      const data = JSON.parse(raw || '{}');
      const newSha = data?.content?.sha || null;
      
      // Cache the new SHA for future updates
      if(newSha){
        cacheSha(path, newSha);
      }
      
      return { ok:true, status: res.status, sha: newSha };
    }

    // If GitHub complains about missing sha or conflict, fetch fresh SHA and retry
    if((res.status === 422 || res.status === 409) && attempt < MAX_RETRIES - 1){
      const fileName = path.split('/').pop();
      // Use console.log instead of warn - this is expected behavior, not an error
      if(attempt === 0){
        console.log(`[ghPutJson] ${res.status} conflict on ${fileName}, auto-retrying...`);
      }
      try{
        // Exponential backoff: 100ms, 200ms, 400ms, 800ms
        const delayMs = 100 * Math.pow(2, attempt);
        await sleep(delayMs);
        
        const freshSha = await ghGetSha(path);
        if(freshSha){
          body.sha = freshSha;
          cacheSha(path, freshSha); // Cache it for next time
          console.log(`[ghPutJson] Fresh SHA obtained, retrying after ${delayMs}ms delay...`);
        }else{
          // File might not exist yet, remove SHA for creation
          delete body.sha;
          console.log(`[ghPutJson] No SHA found, attempting file creation...`);
        }
        attempt++;
        continue;
      }catch(e){
        console.warn(`[ghPutJson] Failed to fetch fresh SHA:`, e.message);
        lastErr = e;
        attempt++;
        if(attempt < MAX_RETRIES){
          await sleep(200 * attempt); // Wait before next attempt
          continue;
        }
        break;
      }
    }

    // Other failures: capture and throw
    console.error("[ghPutJson ERROR]", {path, status: res.status, raw});
    lastErr = new Error(`ghPutJson failed status=${res.status} path=${path} raw=${raw}`);
    break;
    } catch (error) {
      console.error("[ghPutJson EXCEPTION]", {path, error: error.message});
      lastErr = error;
      if (attempt === 0 && error.message.includes('timeout')) {
        attempt++;
        await sleep(2000);
        continue;
      }
      break;
    }
  }

  throw lastErr || new Error(`ghPutJson failed for ${path}`);
}

// List directory contents (returns array of {name, type:"file"|"dir", sha, size})
async function ghListDir(path){
  await ensureGhToken();
  
  try {
    const res = await fetchWithRetry(ghFileUrl(path), {
      method:"GET",
      headers:{
        "Accept":"application/vnd.github+json",
        "Authorization":`Bearer ${GH_TOKEN}`
      },
      cache: 'no-store'
    }, 2, 40000); // 40s timeout, 2 retries for directory listings

    if(res.status===404) return { ok:false, status:404, items:[] };
    if(!res.ok) return { ok:false, status:res.status, items:[] };
    
    const data = await res.json();
    // GitHub returns array of {name, type, sha, size} for directories
    if(!Array.isArray(data)) return { ok:false, status:200, items:[] };
    
    return { 
      ok:true, 
      status:res.status, 
      items: data.map(item => ({
        name: item.name,
        type: item.type === 'dir' ? 'dir' : 'file',
        sha: item.sha || null,
        size: item.size || 0
      }))
    };
  } catch (error) {
    console.error('[ghListDir] Failed:', path, error.message);
    return { ok:false, status:0, items:[], error: error.message };
  }
}

let PWD_DICT_ERROR = null;

function setAuthDisabled(reason){
  loginBtn.disabled = true;
  registerBtn.disabled = true;
  dictHint.textContent = reason;
  dictHint.style.color = "rgba(239,68,68,.9)";
}

async function loadPasswordDictionary(){
  try{
    // localStorage cache
    const cacheKey = "pwd_dict_cache_v1";
    const cached = localStorage.getItem(cacheKey);
    if(cached){
      try{
        const c = JSON.parse(cached);
        if(c?.sha && c?.dict?.map){
          PWD_DICT = { sha:c.sha, charset:c.dict.charset||"", map:c.dict.map };
          PWD_DICT_READY = true;
          dictHint.textContent = "Dictionary cached ";
        }
      }catch(_){}
    }

    // Always re-check sha (cheap) so we can refresh if repo updates it
    const got = await ghGetJsonWithSha(PASSWORD_DICTIONARY_PATH);
    if(!got.ok || !got.obj){
      PWD_DICT_ERROR = `Dictionary missing/unreadable (status=${got.status}).`;
      setAuthDisabled(PWD_DICT_ERROR);
      return;
    }

    const dict = got.obj;
    if(!dict?.map || typeof dict.map !== "object"){
      PWD_DICT_ERROR = "Dictionary invalid (missing map).";
      setAuthDisabled(PWD_DICT_ERROR);
      return;
    }

    // Store in memory (READ ONLY)
    PWD_DICT = { sha: got.sha, charset: dict.charset || "", map: dict.map };
    PWD_DICT_READY = true;
    PWD_DICT_ERROR = null;

    localStorage.setItem("pwd_dict_cache_v1", JSON.stringify({ sha:got.sha, dict: { charset: PWD_DICT.charset, map: PWD_DICT.map }}));
    dictHint.textContent = "Dictionary ready ";
  }catch(e){
    console.error("[Dictionary ERROR]", e);
    PWD_DICT_ERROR = "Dictionary load failed (network).";
    setAuthDisabled(PWD_DICT_ERROR);
  }
}

async function reloadDictionary(){
  // Safe refresh: just calls load again; sha-based localStorage keeps it cheap.
  PWD_DICT_READY = false;
  await loadPasswordDictionary();
}

/* ============================================================
   === AUTH (GLOBAL USER ACCOUNT, DEVICE SESSION) ===
   ============================================================ */
const SESSION_KEY = "cp2p_session_v1";
let session = null; // {userId, username, loginAt}

function normalizeUsername(u){
  return (u||"").trim().toLowerCase();
}

async function sha256Hex(str){
  const data = new TextEncoder().encode(str);
  const digest = await crypto.subtle.digest("SHA-256", data);
  return [...new Uint8Array(digest)].map(b=>b.toString(16).padStart(2,"0")).join("");
}

function randomSaltB64(){
  const bytes = new Uint8Array(16);
  crypto.getRandomValues(bytes);
  // base64
  let bin = "";
  for(const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin);
}

function validatePasswordWithDict(pw){
  if(!PWD_DICT_READY || !PWD_DICT?.map) return { ok:false, reason:"Dictionary not ready." };
  const map = PWD_DICT.map;
  for(const ch of pw){
    if(!map.hasOwnProperty(ch)) return { ok:false, reason:`Password char not allowed: "${ch}"` };
  }
  return { ok:true };
}

function passwordToNumericStream(pw){
  const map = PWD_DICT.map;
  let out = "";
  for(const ch of pw){
    out += String(map[ch]);
  }
  return out;
}

function splitStream(stream, chunkLen=500){
  const chunks = [];
  for(let i=0;i<stream.length;i+=chunkLen) chunks.push(stream.slice(i, i+chunkLen));
  return chunks;
}

async function hashChunks(streamChunks, salt){
  const hashes = [];
  for(const chunk of streamChunks){
    const hex = await sha256Hex(`${salt}:${chunk}`);
    hashes.push(hex);
  }
  return hashes;
}

async function ensureUsersIndex(){
  // users/index.json format:
  // { v:1, byUsernameLower: { "name": "u_xxx" }, updatedAt }
  const path = "users/index.json";
  const got = await ghGetJsonWithSha(path);
  if(got.ok && got.obj) return { ok:true, sha:got.sha, obj:got.obj };
  if(got.status === 404){
    const obj = { v:1, byUsernameLower:{}, updatedAt: Date.now() };
    const put = await ghPutJson(path, obj, null, "init users index");
    return { ok:true, sha:put.sha, obj };
  }
  return { ok:false, sha:null, obj:null, status:got.status };
}

async function registerUser(username, password){
  if(!PWD_DICT_READY) throw new Error("Password dictionary not ready.");
  const uLower = normalizeUsername(username);
  if(!uLower) throw new Error("Username required.");
  if(uLower.length < 3) throw new Error("Username too short.");
  if(password.length < 4) throw new Error("Password too short.");

  const valid = validatePasswordWithDict(password);
  if(!valid.ok) throw new Error(valid.reason);

  const idx = await ensureUsersIndex();
  if(!idx.ok) throw new Error(`users/index load failed (status=${idx.status})`);

  if(idx.obj.byUsernameLower?.[uLower]) throw new Error("Username already exists.");

  // userId derived from username hash (stable)
  const userId = "u_" + (await sha256Hex(uLower)).slice(0,16);

  const salt = randomSaltB64();
  const stream = passwordToNumericStream(password);
  const chunks = splitStream(stream, 500);
  const hashes = await hashChunks(chunks, salt);

  const profilePath = `users/${userId}/profile.json`;
  const profile = {
    v:1,
    userId,
    username,
    usernameLower: uLower,
    createdAt: Date.now(),
    salt,
    authChunks: hashes.length
  };

  // Write profile
  await ghPutJson(profilePath, profile, null, "create profile");

  // Write chunk hashes
  for(let i=0;i<hashes.length;i++){
    const chunkPath = `users/${userId}/auth/chunk-${pad6(i+1)}.json`;
    const obj = { v:1, idx:i+1, hashHex: hashes[i] };
    await ghPutJson(chunkPath, obj, null, "auth chunk");
  }

  // Update index
  idx.obj.byUsernameLower[uLower] = userId;
  idx.obj.updatedAt = Date.now();
  await ghPutJson("users/index.json", idx.obj, idx.sha, "register user index");

  // Save session device-bound
  session = { userId, username, loginAt: Date.now() };
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  applySessionToUi();
}

async function loginUser(username, password){
  if(!PWD_DICT_READY) throw new Error("Password dictionary not ready.");
  const uLower = normalizeUsername(username);
  if(!uLower) throw new Error("Username required.");

  const valid = validatePasswordWithDict(password);
  if(!valid.ok) throw new Error(valid.reason);

  const idx = await ensureUsersIndex();
  const userId = idx?.obj?.byUsernameLower?.[uLower];
  if(!userId) throw new Error("User not found.");

  const prof = await ghGetJsonWithSha(`users/${userId}/profile.json`);
  if(!prof.ok || !prof.obj) throw new Error("Profile missing.");

  const salt = prof.obj.salt;
  const authChunks = prof.obj.authChunks || 0;
  if(!salt || authChunks<=0) throw new Error("Profile invalid (missing salt/authChunks).");

  const stream = passwordToNumericStream(password);
  const chunks = splitStream(stream, 500);
  const hashes = await hashChunks(chunks, salt);

  if(hashes.length !== authChunks) throw new Error("Password mismatch (chunk count).");

  for(let i=0;i<authChunks;i++){
    const chk = await ghGetJsonWithSha(`users/${userId}/auth/chunk-${pad6(i+1)}.json`);
    if(!chk.ok || !chk.obj) throw new Error("Auth data missing.");
    if(chk.obj.hashHex !== hashes[i]) throw new Error("Password incorrect.");
  }

  session = { userId, username: prof.obj.username || username, loginAt: Date.now() };
  localStorage.setItem(SESSION_KEY, JSON.stringify(session));
  applySessionToUi();
}

function logout(){
  session = null;
  localStorage.removeItem(SESSION_KEY);
  applySessionToUi();
}

function loadSessionFromStorage(){
  try{
    const raw = localStorage.getItem(SESSION_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(s?.userId && s?.username) session = s;
  }catch(_){}
}

function applySessionToUi(){
  if(session){
    authPill.textContent = `@${session.username}`;
    loginBtn.style.display = "none";
    registerBtn.style.display = "none";
    logoutBtn.style.display = "";
    browseRoomsBtn.style.display = "";
    // Helpful default display name
    if(!nameInput.value.trim()) nameInput.value = session.username;
    // Load last joined room
    loadLastJoinedRoom();
  }else{
    authPill.textContent = "Guest";
    loginBtn.style.display = "";
    registerBtn.style.display = "";
    logoutBtn.style.display = "none";
    browseRoomsBtn.style.display = "none";
  }
}

/* ============================================================
   === ROOM BROWSER & DISCOVERY ===
   ============================================================ */
const LAST_ROOM_KEY = "cp2p_last_room_v1";

function saveLastJoinedRoom(roomName){
  try{
    const data = { room: roomName, userId: session?.userId, timestamp: Date.now() };
    localStorage.setItem(LAST_ROOM_KEY, JSON.stringify(data));
  }catch(_){}
}

function loadLastJoinedRoom(){
  try{
    const raw = localStorage.getItem(LAST_ROOM_KEY);
    if(!raw) return null;
    const data = JSON.parse(raw);
    // Only use if same user and within last 7 days
    if(data.userId === session?.userId && (Date.now() - data.timestamp < 7 * 24 * 60 * 60 * 1000)){
      if(data.room && !roomInput.value.trim()){
        roomInput.value = data.room;
        roomInput.setAttribute('placeholder', `Last: ${data.room}`);
      }
      return data.room;
    }
  }catch(_){}
  return null;
}

async function discoverRooms(){
  try{
    // List all rooms from the rooms directory
    const listed = await ghListDir(ROOMS_DIR);
    if(!listed.ok) return [];
    
    const rooms = [];
    for(const item of listed.items){
      if(item.type !== 'file' || !item.name.endsWith('.json')) continue;
      const roomName = item.name.replace('.json', '');
      // Master files are now in master-rooms/ folder, so no need to skip them here
      
      // Read from room index for accurate message count
      const indexPath = roomIndexPath(roomName);
      const indexData = await ghGetJsonWithSha(indexPath);
      
      if(indexData.ok && indexData.obj){
        // V3 room with index - use accurate totalMessages
        rooms.push({
          name: roomName,
          totalMessages: indexData.obj.totalMessages || 0,
          updatedAt: indexData.obj.updatedAt || 0,
          latestCell: indexData.obj.latestCell || 0,
          lastMessageAt: indexData.obj.updatedAt || 0 // Track last message time
        });
      }else{
        // Fallback to manifest (for legacy or if index read fails)
        const manifest = await readManifestSmart(roomName);
        if(manifest.ok && manifest.obj){
          rooms.push({
            name: roomName,
            totalMessages: manifest.obj.totalMessages || 0,
            updatedAt: manifest.obj.updatedAt || 0,
            latestCell: 0,
            lastMessageAt: manifest.obj.updatedAt || 0
          });
        }
      }
    }
    
    return rooms;
  }catch(e){
    console.error('[discoverRooms ERROR]', e);
    return [];
  }
}

async function getRoomActiveUsers(roomName){
  try{
    const dir = await ghListDir(`${ROOMS_META_DIR}/${roomName}/presence`);
    if(!dir.ok) return { active: 0, recent: 0, users: [], lastActivityAt: 0 };
    
    const now = Date.now();
    let active = 0;
    let recent = 0;
    const users = [];
    let lastActivityAt = 0;
    
    for(const item of dir.items){
      if(item.type !== 'file' || !item.name.endsWith('.json')) continue;
      
      const got = await ghGetJsonWithSha(`${ROOMS_META_DIR}/${roomName}/presence/${item.name}`);
      if(got.ok && got.obj){
        const p = got.obj;
        const lastActive = p.lastActiveAt || p.lastSeenAt || 0;
        
        // Track the most recent activity across all users
        if(lastActive > lastActivityAt) lastActivityAt = lastActive;
        
        if(now - lastActive < 30_000){ // 30 seconds = active
          active++;
          users.push({ 
            username: p.username || p.userId, 
            status: 'active',
            lastActiveAt: lastActive
          });
        }else if(now - lastActive < PRESENCE_RECENT_MS){ // 5 min = recent
          recent++;
          users.push({ 
            username: p.username || p.userId, 
            status: 'recent',
            lastActiveAt: lastActive
          });
        }
      }
    }
    
    return { active, recent, users, lastActivityAt };
  }catch(e){
    console.error('[getRoomActiveUsers ERROR]', e);
    return { active: 0, recent: 0, users: [], lastActivityAt: 0 };
  }
}

async function openRoomBrowser(){
  ensureModalDom();
  const overlay = document.getElementById('modalOverlay');
  const titleEl = document.getElementById('modalTitle');
  const bodyEl = document.getElementById('modalBody');
  const okBtn = document.getElementById('modalOk');
  const cancelBtn = document.getElementById('modalCancel');
  
  titleEl.textContent = '\uD83D\uDCC1 Browse Rooms';
  bodyEl.innerHTML = '<div style="text-align:center;padding:20px;color:var(--muted)">Loading rooms...</div>';
  okBtn.style.display = 'none';
  cancelBtn.textContent = 'Close';
  overlay.classList.remove('modal-hidden');
  
  // Get current sort preference
  const currentSort = localStorage.getItem('roomBrowserSort') || 'recent-activity';
  
  // Load rooms and presence data
  const rooms = await discoverRooms();
  const lastRoom = loadLastJoinedRoom();
  
  if(rooms.length === 0){
    bodyEl.innerHTML = '<div class="empty-rooms">\uD83C\uDF10 No rooms found.<br>Create one by joining a new room name!</div>';
    return;
  }
  
  // Initialize rooms with empty presence (will be populated in background)
  const roomsWithPresence = rooms.map(room => ({
    ...room,
    presence: { active: 0, recent: 0, users: [], lastActivityAt: 0, loading: true }
  }));
  
  // Function to sort rooms based on selected criteria
  const sortRooms = (sortType) => {
    const sorted = [...roomsWithPresence];
    
    sorted.sort((a, b) => {
      // Always keep last joined room at top if sorting by recent activity
      if(sortType === 'recent-activity'){
        if(a.name === lastRoom) return -1;
        if(b.name === lastRoom) return 1;
      }
      
      switch(sortType){
        case 'recent-activity':
          // Most active users first, then most recent activity
          if(a.presence.active !== b.presence.active) return b.presence.active - a.presence.active;
          if(a.presence.recent !== b.presence.recent) return b.presence.recent - a.presence.recent;
          const aLatest = Math.max(a.presence.lastActivityAt || 0, a.lastMessageAt || 0);
          const bLatest = Math.max(b.presence.lastActivityAt || 0, b.lastMessageAt || 0);
          return bLatest - aLatest;
          
        case 'newest-first':
          // Newest rooms first (highest updatedAt)
          return (b.updatedAt || 0) - (a.updatedAt || 0);
          
        case 'oldest-first':
          // Oldest rooms first (lowest updatedAt)
          return (a.updatedAt || 0) - (b.updatedAt || 0);
          
        case 'most-active':
          // Most active users, then most recent users
          if(a.presence.active !== b.presence.active) return b.presence.active - a.presence.active;
          if(a.presence.recent !== b.presence.recent) return b.presence.recent - a.presence.recent;
          return (b.totalMessages || 0) - (a.totalMessages || 0);
          
        case 'most-messages':
          // Most messages first
          return (b.totalMessages || 0) - (a.totalMessages || 0);
          
        default:
          return 0;
      }
    });
    
    return sorted;
  };
  
  // Initial sort
  let sortedRooms = sortRooms(currentSort);
  
  // Create sort selector
  const sortContainer = document.createElement('div');
  sortContainer.style.cssText = 'padding: 10px 15px; border-bottom: 1px solid var(--border); background: var(--bg-secondary)';
  
  const sortLabel = document.createElement('label');
  sortLabel.style.cssText = 'font-size: 13px; color: var(--muted); margin-right: 8px;';
  sortLabel.textContent = '\uD83D\uDD04 Sort by:';
  
  const sortSelect = document.createElement('select');
  sortSelect.style.cssText = 'padding: 5px 10px; border-radius: 4px; border: 1px solid var(--border); background: var(--bg-primary); color: var(--text); font-size: 13px; cursor: pointer;';
  sortSelect.innerHTML = `
    <option value="recent-activity">Recent Activity</option>
    <option value="newest-first">Newest Rooms</option>
    <option value="oldest-first">Oldest Rooms</option>
    <option value="most-active">Most Active</option>
    <option value="most-messages">Most Messages</option>
  `;
  sortSelect.value = currentSort;
  
  sortSelect.onchange = () => {
    const newSort = sortSelect.value;
    localStorage.setItem('roomBrowserSort', newSort);
    sortedRooms = sortRooms(newSort);
    renderRoomList();
  };
  
  sortContainer.appendChild(sortLabel);
  sortContainer.appendChild(sortSelect);
  
  // Render room list function
  const renderRoomList = () => {
    const listDiv = document.createElement('div');
    listDiv.className = 'room-list';
    
    for(const room of sortedRooms){
    const item = document.createElement('div');
    item.className = 'room-item';
    if(room.name === lastRoom) item.classList.add('last-joined');
    
    const info = document.createElement('div');
    info.className = 'room-info';
    
    const name = document.createElement('div');
    name.className = 'room-name';
    name.textContent = `#${room.name}`;
    
    const meta = document.createElement('div');
    meta.className = 'room-meta';
    
    // Use last message time for more accurate activity indicator
    const hasActiveUsers = room.presence.active > 0;
    const lastActivity = room.lastMessageAt || room.updatedAt;
    const age = lastActivity ? formatLastActivity(lastActivity, hasActiveUsers) : 'unknown';
    const cellInfo = room.latestCell > 0 ? ` \u00b7 ${room.latestCell} cells` : '';
    
    // Show message count and activity
    meta.textContent = `${room.totalMessages || 0} messages${cellInfo} \u00b7 ${age}`;
    
    info.appendChild(name);
    info.appendChild(meta);
    
    const status = document.createElement('div');
    status.className = 'room-status';
    if(room.presence.active > 0) status.classList.add('active');
    
    const count = document.createElement('span');
    count.className = 'user-count';
    const total = room.presence.active + room.presence.recent;
    
    // Show presence with more detail (or loading state)
    if(room.presence.loading){
      count.textContent = ` ...`; // Loading indicator
      count.title = 'Loading presence...';
    }else if(room.presence.active > 0){
      count.textContent = ` ${room.presence.active}`; // Green dot for active
      count.title = `${room.presence.active} active now${room.presence.recent > 0 ? `, ${room.presence.recent} recent` : ''}`;
    }else if(room.presence.recent > 0){
      count.textContent = ` ${room.presence.recent}`; // Regular for recent only
      count.title = `${room.presence.recent} recent (within 5 min)`;
    }else{
      count.textContent = ` 0`;
      count.title = 'No active users';
    }
    
    status.appendChild(count);
    
    item.appendChild(info);
    item.appendChild(status);
    
    item.onclick = () => {
      roomInput.value = room.name;
      closeModal(false);
      // Auto-focus join button
      setTimeout(() => joinBtn.focus(), 100);
    };
    
    listDiv.appendChild(item);
    }
    
    bodyEl.innerHTML = '';
    bodyEl.appendChild(sortContainer);
    bodyEl.appendChild(listDiv);
  };
  
  // Initial render (shows rooms immediately with loading state)
  renderRoomList();
  
  // Fetch presence data in background (non-blocking)
  // Process rooms one at a time to avoid overwhelming the API
  (async () => {
    for(const room of roomsWithPresence){
      try{
        // Fetch presence for this room
        const presence = await getRoomActiveUsers(room.name);
        room.presence = presence;
        
        // Re-sort and re-render after each update
        const sortType = sortSelect.value;
        sortedRooms = sortRooms(sortType);
        renderRoomList();
      }catch(e){
        console.warn(`[Room Browser] Failed to fetch presence for ${room.name}:`, e.message);
        room.presence = { active: 0, recent: 0, users: [], lastActivityAt: 0 };
      }
    }
  })();
}

function formatTimeAgo(timestamp){
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  if(seconds < 5) return 'just now';
  if(seconds < 60) return `${seconds}s ago`;
  if(seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if(seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  if(seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
  return `${Math.floor(seconds / 604800)}w ago`;
}

function formatLastActivity(timestamp, hasActive){
  if(!timestamp) return 'unknown';
  const seconds = Math.floor((Date.now() - timestamp) / 1000);
  
  // For active rooms, show very precise timing
  if(hasActive){
    if(seconds < 5) return 'active now';
    if(seconds < 60) return `active ${seconds}s ago`;
    if(seconds < 300) return `active ${Math.floor(seconds / 60)}m ago`;
  }
  
  // For recent activity
  if(seconds < 5) return 'just now';
  if(seconds < 60) return `${seconds}s ago`;
  if(seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
  if(seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
  if(seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;
  return `${Math.floor(seconds / 604800)}w ago`;
}

/* ============================================================
   === ACTIVITY TRACKER ===
   ============================================================ */
window._chat_lastInteraction = Date.now();
window._chat_activeUntil = Date.now() + ACTIVE_BURST_MS;
window._chat_lastMarkAt = 0;
window._chat_fastScrollingUntil = 0;

/* ============================================================
   === MOBILE GESTURE & EMOTION DETECTION ===
   ============================================================ */
const userBehavior = {
  tapHistory: [],
  dwellTimes: new Map(), // msgId -> {startTime, totalTime, visits}
  scrollPatterns: [],
  currentDwell: null,
  engagement: {
    rapidTaps: 0,        // Excitement indicator
    longDwells: 0,       // Interest indicator
    quickScrolls: 0,     // Disinterest/searching
    slowScrolls: 0,      // Reading/interested
    swipeLeft: 0,        // Dismissive gesture
    swipeRight: 0,       // Engaging gesture
    swipeUp: 0,          // Scrolling through
    swipeDown: 0         // Revisiting
  }
};

// Detect tap patterns (single, double, rapid rage taps)
function detectTapPattern(x, y){
  const now = Date.now();
  const tap = { x, y, time: now };
  
  userBehavior.tapHistory.push(tap);
  
  // Keep only last 5 taps (2 second window)
  userBehavior.tapHistory = userBehavior.tapHistory.filter(t => now - t.time < 2000);
  
  if(userBehavior.tapHistory.length >= 3){
    const recentTaps = userBehavior.tapHistory.slice(-3);
    const timeSpan = recentTaps[2].time - recentTaps[0].time;
    
    // Rapid taps within 1 second = excitement/frustration
    if(timeSpan < 1000){
      userBehavior.engagement.rapidTaps++;
      log(` Rapid tap detected (${userBehavior.engagement.rapidTaps}x) - High engagement!`, "INFO");
      return 'rapid';
    }
  }
  
  if(userBehavior.tapHistory.length >= 2){
    const lastTwo = userBehavior.tapHistory.slice(-2);
    const timeDiff = lastTwo[1].time - lastTwo[0].time;
    
    // Double tap within 500ms
    if(timeDiff < 500){
      return 'double';
    }
  }
  
  return 'single';
}

// Track dwell time on messages (how long user looks at each message)
function startMessageDwell(msgId){
  if(!msgId) return;
  
  const now = Date.now();
  
  // End previous dwell if exists
  if(userBehavior.currentDwell && userBehavior.currentDwell.msgId !== msgId){
    endMessageDwell(userBehavior.currentDwell.msgId);
  }
  
  userBehavior.currentDwell = { msgId, startTime: now };
  
  if(!userBehavior.dwellTimes.has(msgId)){
    userBehavior.dwellTimes.set(msgId, {
      startTime: now,
      totalTime: 0,
      visits: 0
    });
  }
}

function endMessageDwell(msgId){
  if(!msgId) return;
  
  const dwell = userBehavior.dwellTimes.get(msgId);
  if(!dwell) return;
  
  const now = Date.now();
  const dwellTime = now - (userBehavior.currentDwell?.startTime || now);
  
  dwell.totalTime += dwellTime;
  dwell.visits++;
  
  // Long dwell (>3 seconds) = high interest
  if(dwellTime > 3000){
    userBehavior.engagement.longDwells++;
    log(` Long dwell on message (${(dwellTime/1000).toFixed(1)}s) - User interested!`, "INFO");
  }
  
  userBehavior.currentDwell = null;
}

// Analyze scroll behavior for emotional state
function analyzeScrollBehavior(speed, direction, deltaY){
  const now = Date.now();
  
  const pattern = {
    speed,
    direction, // 'up' or 'down'
    deltaY,
    time: now
  };
  
  userBehavior.scrollPatterns.push(pattern);
  
  // Keep only last 10 scrolls (5 second window)
  userBehavior.scrollPatterns = userBehavior.scrollPatterns.filter(p => now - p.time < 5000);
  
  // Fast scrolling (>2000px/s) = searching/disinterested
  if(speed > 2000){
    userBehavior.engagement.quickScrolls++;
    if(userBehavior.engagement.quickScrolls > 5){
      log(` Fast scrolling detected - User searching or disengaged`, "INFO");
    }
  }
  // Slow scrolling (<500px/s) = reading carefully
  else if(speed < 500 && Math.abs(deltaY) > 20){
    userBehavior.engagement.slowScrolls++;
    if(userBehavior.engagement.slowScrolls > 3){
      log(` Slow scrolling - User reading carefully`, "INFO");
    }
  }
}

// Detect swipe emotions
function analyzeSwipe(direction, distance, speed){
  const swipeMap = {
    'left': 'swipeLeft',
    'right': 'swipeRight',
    'up': 'swipeUp',
    'down': 'swipeDown'
  };
  
  if(swipeMap[direction]){
    userBehavior.engagement[swipeMap[direction]]++;
    
    // Fast aggressive swipes = dismissive/negative
    if(speed > 1000 && (direction === 'left' || direction === 'up')){
      log(` Dismissive swipe ${direction} - Possible dislike`, "WARN");
    }
    // Slower, deliberate swipes = engaging
    else if(speed < 500 && (direction === 'right' || direction === 'down')){
      log(` Engaging swipe ${direction} - User interested`, "INFO");
    }
  }
}

// Calculate overall engagement score
function getEngagementScore(){
  const e = userBehavior.engagement;
  
  // Positive signals
  const positive = (e.longDwells * 3) + (e.slowScrolls * 2) + (e.swipeRight * 1.5) + (e.swipeDown * 1);
  
  // Negative signals
  const negative = (e.quickScrolls * 2) + (e.swipeLeft * 1.5) + (e.swipeUp * 1);
  
  // Neutral/excitement
  const excitement = e.rapidTaps * 1;
  
  const score = positive - negative + (excitement * 0.5);
  
  return {
    score: Math.max(0, score),
    sentiment: score > 10 ? 'highly engaged' : score > 5 ? 'engaged' : score > 0 ? 'neutral' : 'disengaged',
    breakdown: { positive, negative, excitement }
  };
}

// Log engagement summary periodically
function logEngagementSummary(){
  const engagement = getEngagementScore();
  const dwellCount = userBehavior.dwellTimes.size;
  
  log(` Engagement: ${engagement.sentiment} (score: ${engagement.score.toFixed(1)}) | Dwells: ${dwellCount} | Taps: ${userBehavior.engagement.rapidTaps}`, "INFO");
}

// Reset engagement tracking (e.g., when switching rooms)
function resetBehaviorTracking(){
  userBehavior.tapHistory = [];
  userBehavior.dwellTimes.clear();
  userBehavior.scrollPatterns = [];
  userBehavior.currentDwell = null;
  for(const key in userBehavior.engagement){
    userBehavior.engagement[key] = 0;
  }
}

/* ============================================================
   PULL-TO-REFRESH GESTURE SYSTEM
   ============================================================ */
let lastRefreshTime = 0;
const REFRESH_COOLDOWN_MS = 3000; // 3 seconds between refreshes

// Unified refresh function
async function triggerManualRefresh(source = "unknown"){
  const now = Date.now();
  
  // Cooldown to prevent spam
  if(now - lastRefreshTime < REFRESH_COOLDOWN_MS){
    log(` Refresh cooldown active (${((REFRESH_COOLDOWN_MS - (now - lastRefreshTime))/1000).toFixed(1)}s remaining)`, "WARN");
    return false;
  }
  
  if(!currentRoom || !running){
    log(" Cannot refresh: no active room", "WARN");
    return false;
  }
  
  lastRefreshTime = now;
  
  try{
    // Show indicator as syncing
    pullRefreshIndicator.classList.add('active', 'syncing');
    pullRefreshText.textContent = 'Syncing...';
    
    log(` Manual refresh triggered (${source})`, "INFO");
    showToast(' Syncing messages...', 'info', 2000);
    
    // Call the sync function
    await syncLatestFromStorage();
    
    // Success feedback
    pullRefreshText.textContent = ' Synced!';
    log(` Manual refresh complete`, "INFO");
    showToast(' Chat synced successfully', 'success', 2000);
    
    // Hide indicator after delay
    setTimeout(()=>{
      pullRefreshIndicator.classList.remove('active', 'syncing');
      pullRefreshText.textContent = 'Pull to refresh';
    }, 1500);
    
    return true;
  }catch(e){
    log(` Manual refresh failed: ${e.message}`, "ERROR");
    showToast(` Sync failed: ${e.message}`, 'error', 3000);
    
    pullRefreshText.textContent = ' Failed';
    setTimeout(()=>{
      pullRefreshIndicator.classList.remove('active', 'syncing');
      pullRefreshText.textContent = 'Pull to refresh';
    }, 1500);
    
    return false;
  }
}

// Pull-to-refresh gesture detection (SINGLE METHOD: tap-hold-drag)
// Stricter requirements to avoid accidental triggers
let pullGestureState = {
  active: false,
  startY: 0,
  startTime: 0,
  currentY: 0,
  holdTimer: null,
  moved: false,
  holdConfirmed: false
};

function initPullToRefreshGesture(){
  if(!messagesEl) return;
  
  messagesEl.addEventListener("touchstart", (e)=>{
    const touch = e.touches[0];
    pullGestureState.startY = touch.clientY;
    pullGestureState.startTime = Date.now();
    pullGestureState.currentY = touch.clientY;
    pullGestureState.moved = false;
    pullGestureState.active = false;
    pullGestureState.holdConfirmed = false;
    
    // Longer hold timer: activate after 500ms (more deliberate)
    clearTimeout(pullGestureState.holdTimer);
    pullGestureState.holdTimer = setTimeout(()=>{
      pullGestureState.holdConfirmed = true;
      pullRefreshIndicator.classList.add('active');
      pullRefreshText.textContent = 'Drag slowly to refresh';
      log(" Pull gesture ready (hold 500ms)", "INFO");
      
      // Haptic feedback if available
      if(navigator.vibrate) navigator.vibrate(50);
    }, 500);
  }, {passive: true});
  
  messagesEl.addEventListener("touchmove", (e)=>{
    const touch = e.touches[0];
    pullGestureState.currentY = touch.clientY;
    pullGestureState.moved = true;
    
    // Only activate if hold was confirmed
    if(pullGestureState.holdConfirmed && !pullGestureState.active){
      const delta = pullGestureState.currentY - pullGestureState.startY;
      const absDelta = Math.abs(delta);
      
      // Require 20px movement after hold to activate
      if(absDelta > 20){
        pullGestureState.active = true;
        log(" Pull gesture active (dragging)", "INFO");
      }
    }
    
    if(pullGestureState.active){
      const delta = pullGestureState.currentY - pullGestureState.startY;
      const absDelta = Math.abs(delta);
      const elapsed = Date.now() - pullGestureState.startTime;
      const speed = absDelta / elapsed; // px/ms
      
      // Check for slow vertical movement (> 60px)
      if(absDelta > 60){
        // Slow drag: < 0.3 px/ms (slower than before)
        if(speed < 0.3){
          pullRefreshText.textContent = ' Release to refresh';
        }else{
          pullRefreshText.textContent = 'Drag slower...';
        }
      }
    }
  }, {passive: true});
  
  messagesEl.addEventListener("touchend", (e)=>{
    clearTimeout(pullGestureState.holdTimer);
    
    if(pullGestureState.active && pullGestureState.moved){
      const delta = pullGestureState.currentY - pullGestureState.startY;
      const absDelta = Math.abs(delta);
      const elapsed = Date.now() - pullGestureState.startTime;
      const speed = absDelta / elapsed;
      
      // STRICT TRIGGER: held 500ms + moved > 80px slowly (< 0.3 px/ms)
      const holdDuration = elapsed;
      if(holdDuration >= 500 && absDelta > 80 && speed < 0.3){
        log(` Refresh triggered: hold=${holdDuration}ms, dist=${absDelta.toFixed(0)}px, speed=${speed.toFixed(3)}px/ms`, "INFO");
        triggerManualRefresh("pull-to-refresh");
      }else{
        // Reset without triggering - show why it failed
        if(holdDuration < 500){
          log(` Hold too short: ${holdDuration}ms (need 500ms+)`, "WARN");
        }else if(absDelta < 80){
          log(` Movement too small: ${absDelta.toFixed(0)}px (need 80px+)`, "WARN");
        }else if(speed >= 0.3){
          log(` Drag too fast: ${speed.toFixed(3)}px/ms (need <0.3px/ms)`, "WARN");
        }
        pullRefreshIndicator.classList.remove('active');
        pullRefreshText.textContent = 'Pull to refresh';
      }
    }else{
      pullRefreshIndicator.classList.remove('active');
      pullRefreshText.textContent = 'Pull to refresh';
    }
    
    pullGestureState.active = false;
    pullGestureState.holdConfirmed = false;
  }, {passive: true});
  
  messagesEl.addEventListener("touchcancel", ()=>{
    clearTimeout(pullGestureState.holdTimer);
    pullGestureState.active = false;
    pullGestureState.holdConfirmed = false;
    pullRefreshIndicator.classList.remove('active');
    pullRefreshText.textContent = 'Pull to refresh';
  }, {passive: true});
}

function markInteraction(kind="unknown"){
  const now = Date.now();
  if(now - window._chat_lastMarkAt < INTERACTION_THROTTLE_MS) return;
  window._chat_lastMarkAt = now;
  window._chat_lastInteraction = now;
  window._chat_activeUntil = now + ACTIVE_BURST_MS;

  // Presence: if we were idle, flip online=true once
  if(presenceState.inRoom && presenceState.isIdle){
    presenceSetOnline(true, "interaction");
  }
  
  // Trigger poll check on interaction (if in room and not already polling)
  if(running && currentRoom && !pollInFlight){
    clearTimeout(pollTimer);
    scheduleNextPoll(parseInt(pollInput.value||POLL_MS_INTERACTION,10));
  }
}

function isActiveNow(){
  const now = Date.now();
  return (now <= window._chat_activeUntil) || (now - window._chat_lastInteraction <= IDLE_THRESHOLD_MS);
}

function installInteractionListeners(){
  const opts = { passive:true };

  // Pointer / mouse / keyboard
  ["pointerdown","pointermove","pointerup","click","wheel","scroll","keydown"].forEach(ev=>{
    window.addEventListener(ev, ()=>markInteraction(ev), opts);
  });

  // Touch events with tap pattern detection
  window.addEventListener("touchstart", (e)=>{
    const touch = e.touches[0];
    if(touch){
      const tapPattern = detectTapPattern(touch.clientX, touch.clientY);
      if(tapPattern === 'rapid'){
        markInteraction("rapid-tap");
      }
    }
  }, opts);

  ["touchmove","touchend","touchcancel"].forEach(ev=>{
    window.addEventListener(ev, ()=>markInteraction(ev), opts);
  });

  // Long-press/hold (>= 350ms) with dwell tracking
  let holdTimer = null;
  let holdTarget = null;
  
  window.addEventListener("touchstart", (e)=>{
    holdTarget = e.target.closest('.msg');
    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>{
      markInteraction("long-press");
      if(holdTarget){
        const msgId = holdTarget.dataset.msgId;
        if(msgId){
          startMessageDwell(msgId);
          log(` User dwelling on message`, "INFO");
        }
      }
    }, 350);
  }, opts);
  
  window.addEventListener("touchend", (e)=>{
    clearTimeout(holdTimer);
    if(holdTarget){
      const msgId = holdTarget.dataset.msgId;
      if(msgId) endMessageDwell(msgId);
    }
    holdTarget = null;
  }, opts);
  
  // Mobile gesture detection: swipe with emotion analysis
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  
  window.addEventListener("touchstart", (e)=>{
    touchStartX = e.touches[0]?.clientX || 0;
    touchStartY = e.touches[0]?.clientY || 0;
    touchStartTime = Date.now();
  }, opts);
  
  window.addEventListener("touchend", (e)=>{
    const touchEndX = e.changedTouches[0]?.clientX || 0;
    const touchEndY = e.changedTouches[0]?.clientY || 0;
    const deltaX = touchEndX - touchStartX;
    const deltaY = touchEndY - touchStartY;
    const absDeltaX = Math.abs(deltaX);
    const absDeltaY = Math.abs(deltaY);
    const deltaTime = Date.now() - touchStartTime;
    
    // Detect swipe (fast gesture > 50px in < 500ms)
    if(deltaTime < 500 && (absDeltaX > 50 || absDeltaY > 50)){
      const distance = Math.sqrt(absDeltaX * absDeltaX + absDeltaY * absDeltaY);
      const speed = distance / (deltaTime / 1000); // px/s
      
      let direction;
      if(absDeltaX > absDeltaY){
        direction = deltaX > 0 ? 'right' : 'left';
      }else{
        direction = deltaY > 0 ? 'down' : 'up';
      }
      
      analyzeSwipe(direction, distance, speed);
      markInteraction("swipe");
    }
  }, opts);
  
  // Pinch/zoom gesture (indicates engagement)
  window.addEventListener("gesturestart", ()=>markInteraction("pinch"), opts);
  window.addEventListener("gesturechange", ()=>markInteraction("pinch"), opts);
  
  // Orientation change (user rotated device)
  window.addEventListener("orientationchange", ()=>{
    markInteraction("orientation");
    // Check messages after orientation change
    if(running && currentRoom && !pollInFlight){
      setTimeout(pollLoop, 200);
    }
  });
  
  // Focus events (keyboard opened/closed on mobile)
  msgInput.addEventListener("focus", ()=>{
    markInteraction("input-focus");
    startTypingMode();
  });
  
  msgInput.addEventListener("blur", ()=>{
    markInteraction("input-blur");
  });

  // Fast-scroll detector with behavior analysis
  let lastScrollTop = 0;
  let lastT = performance.now();
  messagesEl.addEventListener("scroll", ()=>{
    const now = performance.now();
    const dt = Math.max(1, now - lastT);
    const currentScrollTop = messagesEl.scrollTop;
    const dy = currentScrollTop - lastScrollTop;
    const absDy = Math.abs(dy);
    const speed = (absDy / dt) * 1000; // px/s
    
    // Determine scroll direction
    const direction = dy > 0 ? 'down' : 'up';
    
    // Analyze scrolling behavior for emotions
    analyzeScrollBehavior(speed, direction, dy);
    
    lastScrollTop = currentScrollTop;
    lastT = now;
    
    if(speed > 1600){ // Fast scrolling threshold
      window._chat_fastScrollingUntil = Date.now() + 300;
    }
  }, opts);
  
  // Track message visibility (IntersectionObserver for dwell detection)
  const dwellObserver = new IntersectionObserver((entries)=>{
    entries.forEach(entry =>{
      const msgId = entry.target.dataset.msgId;
      if(!msgId) return;
      
      if(entry.isIntersecting && entry.intersectionRatio > 0.7){
        // Message is 70%+ visible - start dwell tracking
        startMessageDwell(msgId);
      }else if(!entry.isIntersecting || entry.intersectionRatio < 0.3){
        // Message left viewport or mostly hidden
        endMessageDwell(msgId);
      }
    });
  }, {
    root: messagesEl,
    threshold: [0, 0.3, 0.7, 1.0]
  });
  
  // Observe all messages for dwell tracking
  const observeMessages = ()=>{
    messagesEl.querySelectorAll('.msg').forEach(msg => {
      dwellObserver.observe(msg);
    });
  };
  
  // Initial observation
  setTimeout(observeMessages, 500);
  
  // Re-observe when new messages arrive
  const msgObserver = new MutationObserver(observeMessages);
  msgObserver.observe(messagesEl, { childList: true });
  
  // Log engagement summary every 30 seconds
  setInterval(()=>{
    if(running && currentRoom){
      logEngagementSummary();
    }
  }, 30000);
}

/* ============================================================
   ROOM STATE
   ============================================================ */
let currentRoom = null;
let running = false;

// Last known master state
let masterLastValue = false;

/* ============================================================
   REPLY & MENTION SYSTEM
   ============================================================ */
let replyingTo = null; // {msgId, sender, text}
let lastReadMessageTs = 0; // Timestamp of last message user has seen
let unreadCount = 0;
let mentionCount = 0;

function setReplyTo(msg){
  if(!msg) return;
  replyingTo = {
    msgId: msg.id,
    sender: msg.sender,
    text: msg.text,
    userId: msg.userId
  };
  replyPreview.classList.add('active');
  replyToUser.textContent = msg.sender;
  replyToText.textContent = msg.text;
  msgInput.focus();
  log(` Replying to ${msg.sender}`, "INFO");
}

function cancelReplyTo(){
  replyingTo = null;
  replyPreview.classList.remove('active');
  replyToUser.textContent = '';
  replyToText.textContent = '';
}

function detectMentions(text){
  // Match @username patterns
  const mentionRegex = /@([\w\-]+)/g;
  const mentions = [];
  let match;
  while((match = mentionRegex.exec(text)) !== null){
    mentions.push(match[1]);
  }
  return mentions;
}

function highlightMentions(text, currentUser){
  if(!text) return document.createTextNode('');
  
  const fragment = document.createDocumentFragment();
  const mentionRegex = /@([\w\-]+)/g;
  let lastIndex = 0;
  let match;
  
  while((match = mentionRegex.exec(text)) !== null){
    // Add text before mention
    if(match.index > lastIndex){
      fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
    }
    
    // Add mention span
    const isSelf = (match[1].toLowerCase() === currentUser.toLowerCase());
    const span = document.createElement('span');
    span.className = isSelf ? 'mention mention-me' : 'mention';
    span.textContent = match[0]; // Safe: @username
    fragment.appendChild(span);
    
    lastIndex = match.index + match[0].length;
  }
  
  // Add remaining text
  if(lastIndex < text.length){
    fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
  }
  
  return fragment;
}

function scrollToMessage(msgId){
  const msgEl = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
  if(!msgEl) {
    log(` Message ${msgId} not in view`, "WARN");
    return;
  }
  
  // Scroll to message
  msgEl.scrollIntoView({behavior: 'smooth', block: 'center'});
  
  // Highlight it
  msgEl.classList.add('msg-highlight');
  setTimeout(()=>{
    msgEl.classList.remove('msg-highlight');
  }, 2000);
}

function updateUnreadBadge(){
  if(unreadCount > 0){
    unreadBadge.textContent = unreadCount > 99 ? '99+' : String(unreadCount);
  }else{
    unreadBadge.textContent = '';
  }
}

function updateMentionBadge(){
  if(mentionCount > 0){
    mentionBadge.textContent = mentionCount > 99 ? '99+' : String(mentionCount);
  }else{
    mentionBadge.textContent = '';
  }
}

function checkNewMessages(messages){
  if(!session && !localGuest.userId) return;
  
  const userId = session?.userId || localGuest.userId;
  const username = session?.username || nameInput.value || localGuest.name;
  
  let newUnread = 0;
  let newMentions = 0;
  
  for(const msg of messages){
    // Skip own messages
    if(msg.userId === userId) continue;
    
    // Check if message is newer than last read
    if(msg.ts > lastReadMessageTs){
      newUnread++;
      
      // Check for mentions
      const mentions = detectMentions(msg.text);
      if(mentions.some(m => m.toLowerCase() === username.toLowerCase())){
        newMentions++;
      }
    }
  }
  
  unreadCount = newUnread;
  mentionCount = newMentions;
  
  updateUnreadBadge();
  updateMentionBadge();
}

function markAllAsRead(){
  // Set last read to most recent message timestamp
  if(loadedMessages.length > 0){
    const latestMsg = loadedMessages[loadedMessages.length - 1];
    lastReadMessageTs = latestMsg.ts;
  }else{
    lastReadMessageTs = Date.now();
  }
  
  unreadCount = 0;
  mentionCount = 0;
  updateUnreadBadge();
  updateMentionBadge();
  
  // Save to localStorage
  if(currentRoom){
    try{
      const key = `cp2p_lastread_${currentRoom}`;
      localStorage.setItem(key, String(lastReadMessageTs));
    }catch(e){}
  }
}

function loadLastReadTimestamp(){
  if(!currentRoom) return;
  try{
    const key = `cp2p_lastread_${currentRoom}`;
    const stored = localStorage.getItem(key);
    if(stored){
      lastReadMessageTs = parseInt(stored, 10);
      log(` Last read: ${new Date(lastReadMessageTs).toLocaleTimeString()}`, "INFO");
    }
  }catch(e){}
}

/* ============================================================
   CELL TRACKING & CACHE
   ============================================================ */
let cellMetadata = {
  currentViewingCell: null,
  totalCells: 0,
  latestCell: 0,
  isSynced: false,
  lastUpdate: 0
};

function saveCellMetadataToCache(){
  if(!currentRoom) return;
  try{
    const key = `cp2p_cell_${currentRoom}`;
    localStorage.setItem(key, JSON.stringify(cellMetadata));
  }catch(e){
    console.warn("[Cell Cache] Save failed:", e);
  }
}

function loadCellMetadataFromCache(){
  if(!currentRoom) return;
  try{
    const key = `cp2p_cell_${currentRoom}`;
    const raw = localStorage.getItem(key);
    if(raw){
      const cached = JSON.parse(raw);
      cellMetadata = {...cellMetadata, ...cached};
      updateCellIndicatorUI();
      log(` Cell cache loaded: viewing ${cached.currentViewingCell}/${cached.totalCells}`, "INFO");
    }
  }catch(e){
    console.warn("[Cell Cache] Load failed:", e);
  }
}

function updateCellMetadata(viewing, total, latest){
  cellMetadata.currentViewingCell = viewing;
  cellMetadata.totalCells = total;
  cellMetadata.latestCell = latest;
  cellMetadata.isSynced = (viewing >= latest - 1); // Synced if viewing latest or one before
  cellMetadata.lastUpdate = Date.now();
  
  updateCellIndicatorUI();
  saveCellMetadataToCache();
}

function updateCellIndicatorUI(){
  const viewing = cellMetadata.currentViewingCell || 0;
  const total = cellMetadata.totalCells || 0;
  const latest = cellMetadata.latestCell || 0;
  
  if(viewing > 0 && total > 0){
    cellViewingNum.textContent = `Cell ${viewing}`;
    cellTotalNum.textContent = `${total}`;
    
    // Update sync status
    cellIndicator.classList.remove('synced', 'behind');
    if(viewing >= latest){
      cellIndicator.classList.add('synced');
      cellIndicator.title = `Viewing latest cell (${viewing}/${total})`;
    }else if(latest - viewing >= 2){
      cellIndicator.classList.add('behind');
      cellIndicator.title = `Behind by ${latest - viewing} cells - pull to refresh`;
    }else{
      cellIndicator.title = `Viewing cell ${viewing} of ${total}`;
    }
  }else{
    cellViewingNum.textContent = '';
    cellTotalNum.textContent = '';
    cellIndicator.title = 'No cells loaded';
  }
}

// Poll loop guards
let pollTimer = null;
let pollInFlight = false;
let isTypingMode = false;
let typingTimeout = null;
let lastTypingAt = 0;
let burstModeUntil = 0;  // Timestamp for burst mode end
let lastMessageSyncAt = 0; // Track last time we synced messages for active users
let syncDebounceTimer = null; //  Evitar mltiples syncs simultneos

// V3 loaded window
let loadedCellsMin = null;
let loadedCellsMax = null;
let loadedMessages = []; // currently displayed (newest last)
let roomIndex = null;    // rooms-cells/<room>/index.json (cached)
let roomIndexSha = null;

// Presence cache
let presenceCache = new Map(); // userId -> obj
let presenceDirSha = null;
let lastPresenceRefreshAt = 0;

// Audio cache for in-browser playback
let audioCache = new Map(); // audioPath -> { blob, blobUrl, size, cachedAt }
const AUDIO_CACHE_MAX_AGE = 3600000; // 1 hour in milliseconds

// Media cache for images/videos/files
let mediaCache = new Map(); // mediaPath -> { blob, blobUrl, size, cachedAt, type }
const MEDIA_CACHE_MAX_AGE = 900000; // 15 minutes in milliseconds

//  IndexedDB para persistencia de media (no se borra al recargar)
let mediaDB = null;
const MEDIA_DB_NAME = 'ChatMediaDB';
const MEDIA_DB_VERSION = 1;
const MEDIA_STORE_NAME = 'mediaStore';

// Inicializar IndexedDB para media persistente
async function initMediaDB(){
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(MEDIA_DB_NAME, MEDIA_DB_VERSION);
    
    request.onerror = () => {
      console.error(' [MediaDB] Error opening database');
      reject(request.error);
    };
    
    request.onsuccess = () => {
      mediaDB = request.result;
      console.log(' [MediaDB] Database opened successfully');
      resolve(mediaDB);
    };
    
    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if(!db.objectStoreNames.contains(MEDIA_STORE_NAME)){
        const objectStore = db.createObjectStore(MEDIA_STORE_NAME, { keyPath: 'path' });
        objectStore.createIndex('type', 'type', { unique: false });
        objectStore.createIndex('cachedAt', 'cachedAt', { unique: false });
        console.log(' [MediaDB] Object store created');
      }
    };
  });
}

// Guardar media en IndexedDB
async function saveMediaToDB(path, blob, type){
  if(!mediaDB) return false;
  
  return new Promise((resolve, reject) => {
    const transaction = mediaDB.transaction([MEDIA_STORE_NAME], 'readwrite');
    const objectStore = transaction.objectStore(MEDIA_STORE_NAME);
    
    const data = {
      path,
      blob,
      type,
      size: blob.size,
      cachedAt: Date.now()
    };
    
    const request = objectStore.put(data);
    
    request.onsuccess = () => {
      console.log(` [MediaDB] Saved: ${path} (${formatBytes(blob.size)})`);
      resolve(true);
    };
    
    request.onerror = () => {
      console.error(' [MediaDB] Error saving:', request.error);
      reject(request.error);
    };
  });
}

// Obtener media de IndexedDB
async function getMediaFromDB(path){
  if(!mediaDB) return null;
  
  return new Promise((resolve, reject) => {
    const transaction = mediaDB.transaction([MEDIA_STORE_NAME], 'readonly');
    const objectStore = transaction.objectStore(MEDIA_STORE_NAME);
    const request = objectStore.get(path);
    
    request.onsuccess = () => {
      if(request.result){
        console.log(` [MediaDB] Retrieved: ${path}`);
        resolve(request.result);
      }else{
        resolve(null);
      }
    };
    
    request.onerror = () => {
      console.error(' [MediaDB] Error retrieving:', request.error);
      reject(request.error);
    };
  });
}

// Limpiar media vieja de IndexedDB (> 7 das)
async function cleanOldMediaFromDB(){
  if(!mediaDB) return;
  
  const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
  
  return new Promise((resolve, reject) => {
    const transaction = mediaDB.transaction([MEDIA_STORE_NAME], 'readwrite');
    const objectStore = transaction.objectStore(MEDIA_STORE_NAME);
    const index = objectStore.index('cachedAt');
    const request = index.openCursor(IDBKeyRange.upperBound(sevenDaysAgo));
    
    let deletedCount = 0;
    
    request.onsuccess = (event) => {
      const cursor = event.target.result;
      if(cursor){
        cursor.delete();
        deletedCount++;
        cursor.continue();
      }else{
        if(deletedCount > 0){
          console.log(` [MediaDB] Cleaned ${deletedCount} old media files`);
        }
        resolve(deletedCount);
      }
    };
    
    request.onerror = () => {
      console.error(' [MediaDB] Error cleaning:', request.error);
      reject(request.error);
    };
  });
}

// Thumbnail cache
let thumbnailCache = new Map(); // path -> base64DataUrl

// Active media uploads state
let activeMediaUploads = [];

// Current viewer state
let currentViewerImages = [];
let currentViewerIndex = 0;
let currentViewerMessageId = null;

// Read receipts throttling
let lastReadWriteAt = 0;

/* ============================================================
   === V3 AUTO MIGRATION ===
   ============================================================ */

function manifestPath(roomName){ return `${ROOMS_DIR}/${roomName}.json`; }
function masterPath(roomName){ return `${MASTER_ROOMS_DIR}/${roomName}.json`; }

function roomIndexPath(roomName){ return `${ROOMS_CELLS_BASE}/${roomName}/index.json`; }
function boxesIndexPath(roomName){ return `${ROOMS_CELLS_BASE}/${roomName}/boxes/boxes-index.json`; }
function boxPath(roomName, boxNum){ return `${ROOMS_CELLS_BASE}/${roomName}/boxes/box-${padBox(boxNum)}.json`; }
function cellPath(roomName, cellNum){ return `${ROOMS_CELLS_BASE}/${roomName}/cells/cell-${pad6(cellNum)}.json`; }

function presencePath(roomName, userId){ return `${ROOMS_META_DIR}/${roomName}/presence/${userId}.json`; }

async function readManifestSmart(roomName){
  // Prefer raw for low-rate reads; fallback to API for 404/errors
  const raw = await rawGetText(manifestPath(roomName));
  if(raw.ok){
    try{ return { ok:true, obj: JSON.parse(raw.text), source:"raw" }; }catch(e){}
  }
  const api = await ghGetJsonWithSha(manifestPath(roomName));
  if(api.ok && api.obj) return { ok:true, obj: api.obj, source:"api", sha: api.sha };
  return { ok:false, status: raw.status || api.status || 0 };
}

async function ensureRoomV3(roomName){
  // If missing -> create V3 manifest + initial indexes + first cell + first box
  const got = await ghGetJsonWithSha(manifestPath(roomName));
  if(got.status === 404){
    const now = Date.now();

    const manifest = {
      v: MANIFEST_VERSION_V3,
      room: roomName,
      createdAt: now,
      updatedAt: now,
      storage: {
        cellMaxMessages: CELL_MAX_MESSAGES,
        cellsPerBox: CELLS_PER_BOX
      },
      paths: {
        roomIndex: roomIndexPath(roomName),
        boxesIndex: boxesIndexPath(roomName),
        cellsDir: `${ROOMS_CELLS_BASE}/${roomName}/cells/`,
        boxesDir: `${ROOMS_CELLS_BASE}/${roomName}/boxes/`
      }
    };

    // init room index
    const idxObj = {
      v:3,
      room: roomName,
      latestCell: 1,
      totalMessages: 0,
      updatedAt: now
    };

    const boxesIdxObj = {
      v:3,
      room: roomName,
      boxes: [ { box: 1, startCell: 1, endCell: 1, updatedAt: now } ],
      updatedAt: now
    };

    const boxObj = { v:3, room: roomName, box:1, startCell:1, endCell:1, cellCount:1, updatedAt: now };

    // create files (order doesn't matter, but keep clean)
    await ghPutJson(roomIndexPath(roomName), idxObj, null, "init room index");
    await ghPutJson(boxesIndexPath(roomName), boxesIdxObj, null, "init boxes index");
    await ghPutJson(boxPath(roomName, 1), boxObj, null, "init box");
    await ghPutJson(cellPath(roomName, 1), [], null, "init cell");
    await ghPutJson(manifestPath(roomName), manifest, null, "init room manifest v3");

    // Ensure master file exists (false)
    await ensureMasterExists(roomName);

    log(` Room "${roomName}" created (V3).`);
    return { ok:true, manifest };
  }

  // If exists but not v3 -> migrate silently
  if(got.ok && got.obj && got.obj.v === 3){
    await ensureMasterExists(roomName);
    return { ok:true, manifest: got.obj };
  }

  // Migration path: we will attempt to load all messages and rebuild V3 structure
  log(` Migrating room "${roomName}" to V3 (silent)`, "INFO");
  const all = await loadAllMessagesAny(roomName, got.obj);
  await rebuildV3FromMessages(roomName, all);

  // Overwrite manifest to V3
  const now = Date.now();
  const manifest = {
    v: MANIFEST_VERSION_V3,
    room: roomName,
    createdAt: (got.obj?.createdAt || now),
    updatedAt: now,
    migratedFrom: (got.obj?.v || "legacy"),
    storage: { cellMaxMessages: CELL_MAX_MESSAGES, cellsPerBox: CELLS_PER_BOX },
    paths: {
      roomIndex: roomIndexPath(roomName),
      boxesIndex: boxesIndexPath(roomName),
      cellsDir: `${ROOMS_CELLS_BASE}/${roomName}/cells/`,
      boxesDir: `${ROOMS_CELLS_BASE}/${roomName}/boxes/`
    }
  };
  await ghPutJson(manifestPath(roomName), manifest, got.sha || null, "migrate manifest v3");
  await ensureMasterExists(roomName);

  log(` Migration done (${all.length} msgs).`, "INFO");
  return { ok:true, manifest };
}

async function loadAllMessagesAny(roomName, existingManifestObj){
  // 1) If rooms/<room>.json is an array (legacy), treat it as history
  if(Array.isArray(existingManifestObj)){
    return existingManifestObj.map(normalizeMessage).filter(Boolean).sort((a,b)=>a.ts-b.ts);
  }

  // 2) If manifest looks like V2 that stored messages in the manifest itself
  // (some earlier builds used rooms/<room>.json as an array)
  const got = await ghGetJsonWithSha(manifestPath(roomName));
  if(got.ok && Array.isArray(got.obj)){
    return got.obj.map(normalizeMessage).filter(Boolean).sort((a,b)=>a.ts-b.ts);
  }

  // 3) Try list cells directory (v2)
  const listed = await ghListDir(`${ROOMS_CELLS_BASE}/${roomName}/cells`);
  if(listed.ok){
    const cellFiles = listed.items
      .filter(it=>it.type==="file" && /^cell-\d{6}\.json$/.test(it.name))
      .sort((a,b)=>a.name.localeCompare(b.name));
    const out = [];
    for(const f of cellFiles){
      const gotCell = await ghGetJsonWithSha(`${ROOMS_CELLS_BASE}/${roomName}/cells/${f.name}`);
      if(gotCell.ok && Array.isArray(gotCell.obj)){
        for(const raw of gotCell.obj){
          const msg = normalizeMessage(raw);
          if(msg) out.push(msg);
        }
      }
    }
    out.sort((a,b)=>a.ts-b.ts);
    return out;
  }

  return [];
}

async function rebuildV3FromMessages(roomName, messages){
  const now = Date.now();
  // Split into cells of 4
  const cells = [];
  for(let i=0;i<messages.length;i+=CELL_MAX_MESSAGES){
    cells.push(messages.slice(i, i+CELL_MAX_MESSAGES));
  }
  const totalCells = Math.max(1, cells.length);

  // Write cells
  for(let c=1;c<=totalCells;c++){
    const arr = cells[c-1] || [];
    await ghPutJson(cellPath(roomName, c), arr, null, `migrate cell ${c}`);
  }

  // Build boxes: 100 cells per box
  const totalBoxes = Math.max(1, Math.ceil(totalCells / CELLS_PER_BOX));
  const boxesIndex = { v:3, room:roomName, boxes:[], updatedAt: now };

  for(let b=1;b<=totalBoxes;b++){
    const startCell = (b-1)*CELLS_PER_BOX + 1;
    const endCell = Math.min(totalCells, b*CELLS_PER_BOX);
    const boxObj = { v:3, room:roomName, box:b, startCell, endCell, cellCount:(endCell-startCell+1), updatedAt: now };
    await ghPutJson(boxPath(roomName,b), boxObj, null, `migrate box ${b}`);
    boxesIndex.boxes.push({ box:b, startCell, endCell, updatedAt: now });
  }
  await ghPutJson(boxesIndexPath(roomName), boxesIndex, null, "migrate boxes index");

  // Room index
  const idxObj = { v:3, room: roomName, latestCell: totalCells, totalMessages: messages.length, updatedAt: now };
  await ghPutJson(roomIndexPath(roomName), idxObj, null, "migrate room index");
}

/* ============================================================
   MESSAGE NORMALIZATION
   ============================================================ */
function normalizeMessage(raw){
  if(!raw || typeof raw !== "object") return null;
  const ts = (typeof raw.ts === "number") ? raw.ts : Date.now();
  const normalized = {
    id: raw.id || `m-${ts}-${Math.random().toString(36).slice(2,8)}`,
    room: raw.room || currentRoom || "unknown",
    sender: raw.sender || "Anon",
    userId: raw.userId || "legacy",
    ts,
    text: String(raw.text || ""),
    edited: !!raw.edited,
    editedAt: raw.editedAt || null,
    deleted: !!raw.deleted,
    createdAt: raw.createdAt || ts,
    replyTo: raw.replyTo || null, // {msgId, sender, text}
    mentions: raw.mentions || [] // Array of mentioned usernames
  };
  
  // ========================================
  // AUDIO METADATA: Preserve all audio-specific fields when loading from GitHub
  // This ensures audio messages maintain their playback info and listen tracking
  // ========================================
  if(raw.type === 'audio'){
    normalized.type = 'audio';
    normalized.audioPath = raw.audioPath || null;           // GitHub path to audio file
    normalized.audioData = raw.audioData || null;           // Base64 data (legacy/just-sent)
    normalized.audioSize = raw.audioSize || 0;              // File size in bytes
    normalized.audioFileName = raw.audioFileName || null;   // Original filename
    normalized.audioFolderType = raw.audioFolderType || null; // 'recorded-audios' or 'media-audios'
    normalized.audioDuration = raw.audioDuration || 0;      // Duration in seconds
    normalized.listenedBy = raw.listenedBy || [];          // AUDIO READ RECEIPT: Array of {userId, username, listenedAt}
  }
  
  // ========================================
  // MEDIA METADATA: Preserve attachments array for media messages
  // Supports images, videos, and files with their metadata
  // ========================================
  if(raw.type === 'media'){
    normalized.type = 'media';
    normalized.attachments = raw.attachments || []; // Array of attachment objects
  }
  
  return normalized;
}

/* ============================================================
   V3 LOAD / APPEND
   ============================================================ */
async function loadRoomIndex(roomName){
  // CRTICO: Usar API (true) para obtener el ndice REAL instantneamente
  // El ndice nos dice cuntos mensajes hay, debe ser preciso
  const got = await ghGetJsonWithSha(roomIndexPath(roomName), true);
  if(got.ok && got.obj){
    roomIndex = got.obj;
    roomIndexSha = got.sha;
    console.log(` [loadRoomIndex] Loaded: latestCell=${roomIndex.latestCell}, totalMessages=${roomIndex.totalMessages}`);
    return roomIndex;
  }
  // If missing (shouldn't), rebuild from scratch empty
  const now = Date.now();
  roomIndex = { v:3, room:roomName, latestCell:1, totalMessages:0, updatedAt: now };
  const put = await ghPutJson(roomIndexPath(roomName), roomIndex, null, "repair room index");
  roomIndexSha = put.sha;
  console.warn(` [loadRoomIndex] Index missing, created new: latestCell=1, totalMessages=0`);
  return roomIndex;
}

async function saveRoomIndex(roomName){
  if(!roomIndex) return;
  roomIndex.updatedAt = Date.now();
  const put = await ghPutJson(roomIndexPath(roomName), roomIndex, roomIndexSha, "update room index");
  roomIndexSha = put.sha;
}

async function ensureCellExists(roomName, cellNum){
  const got = await ghGetJsonWithSha(cellPath(roomName, cellNum));
  if(got.status === 404){
    const put = await ghPutJson(cellPath(roomName, cellNum), [], null, `init cell ${cellNum}`);
    return { ok:true, arr:[], sha: put.sha || null };
  }
  if(!got.ok || !Array.isArray(got.obj)) return { ok:false, arr:[], sha:null };
  return { ok:true, arr:got.obj, sha: got.sha };
}

async function loadCellsRange(roomName, startCell, endCell){
  const out = [];
  const failedCells = [];
  
  console.log(` [loadCellsRange] Loading cells ${startCell} to ${endCell} (latest known: ${roomIndex?.latestCell || 'unknown'})`);
  
  for(let c=startCell;c<=endCell;c++){
    try{
      // LGICA HBRIDA INTELIGENTE:
      // - ltima celda (endCell): API (true) = Datos frescos instantneos (1-2s latencia)
      // - Celdas antiguas: Raw (false) = Cach 5min pero ahorra rate limit
      const isLatestCell = (c === endCell);
      console.log(`  Cell ${c}: ${isLatestCell ? ' Forcing API (latest cell)' : ' Using Raw CDN (historical)'}`);
      const got = await ghGetJsonWithSha(cellPath(roomName,c), isLatestCell);
      if(got.ok && Array.isArray(got.obj)){
        for(const raw of got.obj){
          const msg = normalizeMessage(raw);
          if(msg){
            // Tag message with cell number for live tracking
            msg.cell = c;
            out.push(msg);
            
            // Debug: Log audio messages
            if(msg.type === 'audio'){
              console.log(' Loaded audio message from GitHub:', {
                msgId: msg.id,
                hasPath: !!msg.audioPath,
                hasData: !!msg.audioData,
                size: formatBytes(msg.audioSize || 0),
                duration: msg.audioDuration,
                path: msg.audioPath
              });
            }
          }
        }
      }else if(got.status === 404){
        // Cell doesn't exist yet, that's OK
        console.log(`Cell ${c} not found (may be empty)`);
      }else{
        failedCells.push(c);
        console.warn(`Failed to load cell ${c}: ${got.error || 'unknown error'}`);
      }
    }catch(error){
      failedCells.push(c);
      console.error(`Exception loading cell ${c}:`, error.message);
    }
  }
  
  if(failedCells.length > 0){
    console.warn(` Failed to load ${failedCells.length} cells: ${failedCells.join(', ')}`);
    // Show user notification if too many failures
    if(failedCells.length > (endCell - startCell + 1) / 2){
      showToast('Network issues detected. Some messages may not load.', 'warning', 5000);
    }
  }
  
  out.sort((a,b)=>a.ts-b.ts);
  return out;
}

async function loadLatestMessages(roomName, wantCount=50){
  await loadRoomIndex(roomName);
  const latestCell = roomIndex.latestCell || 1;
  const needCells = Math.max(1, Math.ceil(wantCount / CELL_MAX_MESSAGES));
  const startCell = Math.max(1, latestCell - needCells + 1);
  const msgs = await loadCellsRange(roomName, startCell, latestCell);
  loadedCellsMin = startCell;
  loadedCellsMax = latestCell;
  return msgs;
}

async function loadOlderByMessages(roomName, count){
  await loadRoomIndex(roomName);
  if(loadedCellsMin === null) return [];
  if(loadedCellsMin <= 1) return [];

  const needCells = Math.max(1, Math.ceil(count / CELL_MAX_MESSAGES));
  const newStart = Math.max(1, loadedCellsMin - needCells);
  const msgs = await loadCellsRange(roomName, newStart, loadedCellsMin-1);
  loadedCellsMin = newStart;
  return msgs;
}

async function appendMessageV3(roomName, msgObj){
  await loadRoomIndex(roomName);
  let cellNum = roomIndex.latestCell || 1;

  const cell = await ensureCellExists(roomName, cellNum);
  let arr = cell.arr || [];
  let sha = cell.sha;

  // If cell full -> next cell
  if(arr.length >= CELL_MAX_MESSAGES){
    cellNum += 1;
    arr = [];
    sha = null;
    roomIndex.latestCell = cellNum;
    
    // Clear box-related caches to prevent SHA conflicts
    const boxNum = Math.ceil(cellNum / CELLS_PER_BOX);
    clearCachedSha(boxesIndexPath(roomName));
    clearCachedSha(boxPath(roomName, boxNum));

    // ensure new cell file exists
    const initResult = await ghPutJson(cellPath(roomName, cellNum), [], null, `init cell ${cellNum}`);
    if(!initResult || !initResult.ok){
      throw new Error(`Failed to initialize new cell ${cellNum}`);
    }

    // update boxes structures when crossing box boundary
    await ensureBoxForCell(roomName, cellNum);
  }

  // write the cell index into the message for later edits
  msgObj.cell = cellNum;
  
  // Check for duplicates before appending
  const existingIdx = arr.findIndex(m => m.id === msgObj.id);
  if(existingIdx >= 0){
    // Message already exists, update it instead of appending
    console.log(`[appendMessageV3] Message ${msgObj.id} already exists in cell ${cellNum}, updating...`);
    arr[existingIdx] = msgObj;
  }else{
    // New message, append it
    arr.push(msgObj);
  }
  
  // Critical: Write message to GitHub and verify success
  const put = await ghPutJson(cellPath(roomName, cellNum), arr, sha, `append msg cell ${cellNum}`);
  if(!put || !put.ok || !put.sha){
    throw new Error(`Failed to write message to cell ${cellNum} - no SHA returned`);
  }
  
  // Update room index (only increment if this was a new message, not an update)
  if(existingIdx < 0){
    roomIndex.totalMessages = (roomIndex.totalMessages || 0) + 1;
  }
  await saveRoomIndex(roomName);

  // notify master (with retry logic)
  await saveMasterValue(roomName, true);

  log(` Message appended to cell ${cellNum}, total messages: ${roomIndex.totalMessages}`, "INFO");
  return { cellNum, cellSha: put.sha };
}

async function ensureBoxForCell(roomName, cellNum){
  const boxNum = Math.max(1, Math.ceil(cellNum / CELLS_PER_BOX));
  const startCell = (boxNum-1)*CELLS_PER_BOX + 1;
  const endCell = cellNum;

  // boxes-index
  const gotIdx = await ghGetJsonWithSha(boxesIndexPath(roomName));
  let idxObj = gotIdx.ok && gotIdx.obj ? gotIdx.obj : { v:3, room:roomName, boxes:[], updatedAt: Date.now() };
  let idxSha = gotIdx.sha || null;
  if(!Array.isArray(idxObj.boxes)) idxObj.boxes = [];

  let entry = idxObj.boxes.find(b=>b.box===boxNum);
  if(!entry){
    entry = { box: boxNum, startCell, endCell, updatedAt: Date.now() };
    idxObj.boxes.push(entry);
    idxObj.boxes.sort((a,b)=>a.box-b.box);
  }else{
    entry.endCell = Math.max(entry.endCell||endCell, endCell);
    entry.updatedAt = Date.now();
  }
  idxObj.updatedAt = Date.now();
  const putIdx = await ghPutJson(boxesIndexPath(roomName), idxObj, idxSha, "update boxes-index");
  // box file
  const gotBox = await ghGetJsonWithSha(boxPath(roomName, boxNum));
  const boxObj = gotBox.ok && gotBox.obj ? gotBox.obj : { v:3, room:roomName, box:boxNum, startCell, endCell, cellCount:(endCell-startCell+1), updatedAt:Date.now() };
  boxObj.startCell = startCell;
  boxObj.endCell = Math.max(boxObj.endCell||endCell, endCell);
  boxObj.cellCount = (boxObj.endCell - boxObj.startCell + 1);
  boxObj.updatedAt = Date.now();
  await ghPutJson(boxPath(roomName, boxNum), boxObj, gotBox.sha||null, "update box");
}

/* ============================================================
   MASTER (raw read + API fallback) + POLL LOOP (activity/idle)
   ============================================================ */
async function ensureMasterExists(roomName){
  // Only use new path: master-rooms/<room>.json
  const path = masterPath(roomName);
  
  // Check if exists via raw read (fast)
  const raw = await rawGetText(path);
  if(raw.ok) return;
  
  // Create new master file if doesn't exist
  const got = await ghGetJsonWithSha(path);
  if(got.status === 404){
    await ghPutJson(path, false, null, "init master");
  }
}

async function readMasterValue(roomName){
  const p = masterPath(roomName);
  
  // CRTICO: SIEMPRE usar API (forceApi=true) para el master flag
  // Este archivo es el "semforo" que avisa de mensajes nuevos
  // DEBE leerse en tiempo real, no puede tener cach de 5 minutos
  try{
    const api = await ghGetJsonWithSha(p, true); // <-- TRUE = API instantnea
    if(api.ok){
      return { ok:true, value: !!api.obj, source:"api-fresh" };
    }
    return { ok:false, status: api.status, value:false, source:"api" };
  }catch(e){
    console.error('[readMasterValue] Error:', e.message);
    return { ok:false, status:0, value:false, source:"error" };
  }
}

async function saveMasterValue(roomName, value){
  const p = masterPath(roomName);
  try{
    // Try with cached SHA first
    const cachedSha = getCachedSha(p);
    
    if(cachedSha){
      const result = await ghPutJson(p, !!value, cachedSha, "set master");
      if(result && result.ok){
        log(` Master flag set to ${value}`, "INFO");
        return;
      }
    }
    
    // No cache or failed - fetch fresh SHA from API
    const sha = await ghGetSha(p);
    const result = await ghPutJson(p, !!value, sha, "set master");
    
    if(!result || !result.ok){
      // Retry once if failed
      log(` Master flag update failed, retrying...`, "WARN");
      await sleep(500);
      const sha2 = await ghGetSha(p);
      await ghPutJson(p, !!value, sha2, "set master (retry)");
    }else{
      log(` Master flag set to ${value}`, "INFO");
    }
  }catch(e){
    console.error('[saveMasterValue ERROR]', e);
    log(` Failed to set master flag: ${e.message}`, "ERROR");
  }
}

function scheduleNextPoll(ms){
  clearTimeout(pollTimer);
  pollTimer = setTimeout(pollLoop, ms);
}

// Typing mode: enable fast polling when user is typing
function startTypingMode(){
  const now = Date.now();
  lastTypingAt = now;
  
  if(!isTypingMode){
    isTypingMode = true;
    // Trigger immediate check when typing starts
    clearTimeout(pollTimer);
    setTimeout(pollLoop, 0);
  }
  
  // Auto-disable typing mode after 3 seconds of no typing
  clearTimeout(typingTimeout);
  typingTimeout = setTimeout(() => {
    isTypingMode = false;
    // One final check when typing stops
    if(running && currentRoom) pollLoop();
  }, 3000);
}

function stopTypingMode(){
  clearTimeout(typingTimeout);
  isTypingMode = false;
}

async function pollLoop(){
  try{
    if(!running || !currentRoom) return;
    if(pollInFlight) return;

    const now = Date.now();
    const active = isActiveNow();
    
    // Handle idle state
    if(!active){
      if(presenceState.inRoom && !presenceState.isIdle){
        await presenceSetOnline(false, "idle");
      }
      // No more polling when idle - will resume on interaction
      return;
    }

    // Active: ensure presence online
    if(presenceState.inRoom && presenceState.isIdle){
      await presenceSetOnline(true, "active");
    }

    pollInFlight = true;

    // Read master flag (lightweight check)
    const master = await readMasterValue(currentRoom);
    if(!master.ok){
      pollInFlight = false;
      return;
    }

    // ========================================
    // ACTIVE USER MESSAGE SYNC:
    // If user is actively viewing the chat, periodically sync messages
    // even if master flag is false. This ensures they see new messages
    // from other users without waiting for interactions.
    // ========================================
    const inBurstMode = now < burstModeUntil;
    const shouldForceSync = active && (now - lastMessageSyncAt > (inBurstMode ? 1000 : 5000)); //  1s en burst mode para respuesta ultra-rpida
    
    // Sync if master=true OR if user is actively viewing (force sync)
    if(master.value || shouldForceSync){
      if(master.value){
        log(` Syncing new messages (master=true)...`, "INFO");
      }else if(inBurstMode){
        log(` Burst mode sync - checking for replies...`, "INFO");
      }else{
        log(` Active user sync - checking for new messages...`, "INFO");
      }
      
      await syncLatestFromStorage();
      lastMessageSyncAt = now; // Track last sync time
      
      if(master.value){
        await sleep(100);
        await saveMasterValue(currentRoom, false);
      }
      
      // Enter burst mode: check frequently for quick back-and-forth
      burstModeUntil = now + POLL_BURST_DURATION;
    }else{
      // No new messages, just refresh presence
      await maybeRefreshPresence();
    }

    // Smart scheduling:
    // - Burst mode (after message received): aggressive polling for 10s
    // - Typing mode: check while typing
    // - Active viewing: moderate polling to catch new messages
    // - Otherwise: NO automatic polling (wait for interaction)
    
    // inBurstMode ya est declarado arriba
    
    if(inBurstMode || isTypingMode || active){
      // Continue polling during conversation or when actively viewing
      let interval;
      if(inBurstMode){
        interval = POLL_MS_BURST;           // 300ms - ultra rpido durante conversacin
      }else if(isTypingMode){
        interval = POLL_MS_INTERACTION;     // 2000ms - while typing
      }else{
        interval = POLL_MS_INTERACTION * 2; // 4000ms - when just viewing
      }
      scheduleNextPoll(interval);
    }
    // else: stop polling, wait for next interaction
    
  }catch(e){
    console.error("[pollLoop ERROR]", e);
  }finally{
    pollInFlight = false;
  }
}

/* ============================================================
   RENDER + LAZY LOAD (gesture speed based)
   ============================================================ */
function renderAll(messages){
  messagesEl.innerHTML = "";
  loadedMessages = [];
  
  // Use DocumentFragment for batch rendering (mucho ms rpido)
  const fragment = document.createDocumentFragment();
  
  for(const m of messages){
    loadedMessages.push(m);
    const msgElement = createMessageElement(m);
    fragment.appendChild(msgElement);
  }
  
  // Single DOM append (mucho ms eficiente que mltiples appends)
  messagesEl.appendChild(fragment);
  
  // Scroll immediately usando requestAnimationFrame
  requestAnimationFrame(() => {
    messagesEl.scrollTop = messagesEl.scrollHeight;
    
    // Segundo scroll despus de que las imgenes carguen
    setTimeout(() => {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }, 200);
  });
  
  setupReadObserver(); // attach read receipts to current DOM nodes
  
  // Check for unread messages and mentions
  checkNewMessages(messages);
}

function addMessageToDom(m, silent=false, prepend=false){
  // Skip if message already exists in DOM (rpido)
  const existing = messagesEl.querySelector(`[data-msg-id="${m.id}"]`);
  if(existing){
    //  ACTUALIZACIN INTELIGENTE: Detectar cambios en el mensaje
    const existingInMemory = loadedMessages.find(msg => msg.id === m.id);
    
    // Verificar si hay cambios importantes (deleted, edited, status)
    const hasChanges = !existingInMemory || 
                      existingInMemory.deleted !== m.deleted ||
                      existingInMemory.edited !== m.edited ||
                      existingInMemory.status !== m.status;
    
    if(hasChanges){
      console.log(` [Update] Message ${m.id} changed - re-rendering`);
      // Actualizar en memoria
      const idx = loadedMessages.findIndex(msg => msg.id === m.id);
      if(idx !== -1) loadedMessages[idx] = m;
      else loadedMessages.push(m);
      
      // Reemplazar elemento en DOM
      const newEl = createMessageElement(m);
      existing.replaceWith(newEl);
      if(readObserver) readObserver.observe(newEl);
      return;
    }
    
    // Si no hay cambios, solo actualizar status si existe
    if(m.status && existing.querySelector('.msg-status')){
      updateMessageStatus(m.id, m.status);
    }
    return;
  }
  
  // Skip if already in loadedMessages (evitar duplicados en memoria)
  const existingInMemory = loadedMessages.findIndex(msg => msg.id === m.id);
  if(existingInMemory !== -1){
    // Actualizar el mensaje existente en lugar de agregar duplicado
    loadedMessages[existingInMemory] = m;
    return;
  }
  
  // Store to loaded list
  if(prepend) loadedMessages.unshift(m);
  else loadedMessages.push(m);
  
  // Create message element
  const wrap = createMessageElement(m);
  
  // Add to DOM
  if(prepend){
    messagesEl.insertBefore(wrap, messagesEl.firstChild);
  }else{
    messagesEl.appendChild(wrap);
    if(!silent){
      requestAnimationFrame(() => {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
    }
  }
  
  // Observe for read receipts
  if(readObserver) readObserver.observe(wrap);
}

function createMessageElement(m){
  const wrap = document.createElement("div");
  wrap.className = "msg" + ((session && m.userId===session.userId) ? " me" : "");
  wrap.dataset.msgId = m.id;
  // Store cell number for live detection
  if(m.cell !== undefined && m.cell !== null){
    wrap.dataset.cell = String(m.cell);
  }
  wrap.dataset.ts = String(m.ts);

  // Reply preview (if message is replying to another)
  if(m.replyTo && m.replyTo.msgId){
    const replyDiv = document.createElement("div");
    replyDiv.className = "msg-reply";
    replyDiv.dataset.replyTo = m.replyTo.msgId;
    replyDiv.onclick = ()=> scrollToMessage(m.replyTo.msgId);
    
    const replyAuthor = document.createElement("div");
    replyAuthor.className = "msg-reply-author";
    replyAuthor.textContent = m.replyTo.sender || "Unknown";
    
    const replyText = document.createElement("div");
    replyText.className = "msg-reply-text";
    replyText.textContent = m.replyTo.text || "";
    
    replyDiv.appendChild(replyAuthor);
    replyDiv.appendChild(replyText);
    wrap.appendChild(replyDiv);
  }

  const text = document.createElement("div");
  text.className = "text";
  
  // Check if this is an audio message
  if(m.type === 'audio' && (m.audioData || m.audioPath)){
    const audioMsg = document.createElement("div");
    audioMsg.className = "msg-audio";
    audioMsg.dataset.msgId = m.id;
    
    const audioPlayBtn = document.createElement("button");
    audioPlayBtn.className = "audio-play-btn";
    audioPlayBtn.textContent = ""; // Download icon initially
    audioPlayBtn.dataset.playing = "false";
    audioPlayBtn.dataset.loaded = "false";
    audioPlayBtn.title = "Tap to download and play";
    
    const audioWaveform = document.createElement("div");
    audioWaveform.className = "audio-waveform";
    
    // Generate waveform bars
    const barCount = 30;
    for(let i = 0; i < barCount; i++){
      const bar = document.createElement("div");
      bar.className = "audio-wave-bar";
      const height = Math.random() * 30 + 10;
      bar.style.height = height + 'px';
      audioWaveform.appendChild(bar);
    }
    
    const audioDuration = document.createElement("div");
    audioDuration.className = "audio-duration";
    
    // Show file size initially if not downloaded yet
    const audioSize = m.audioSize || 0;
    const durationSec = Math.floor(m.audioDuration || 0);
    
    if(audioSize > 0){
      // Show size before download
      const sizeSpan = document.createElement('span');
      sizeSpan.style.opacity = '0.7';
      sizeSpan.textContent = formatBytes(audioSize);
      audioDuration.appendChild(sizeSpan);
      audioDuration.appendChild(document.createTextNode(`  ${formatDuration(durationSec)}`));
    }else{
      audioDuration.textContent = formatDuration(durationSec);
    }
    
    // Audio element (hidden)
    const audioElement = document.createElement("audio");
    audioElement.style.display = "none";
    audioElement.preload = "metadata";
    audioElement.dataset.msgId = m.id;
    
    // Load audio function (on-demand)
    const loadAudioOnDemand = async () => {
      if(audioPlayBtn.dataset.loaded === "true") return true;
      
      audioPlayBtn.textContent = "";
      audioPlayBtn.disabled = true;
      audioDuration.textContent = '';
      const loadingSpan = document.createElement('span');
      loadingSpan.style.opacity = '0.7';
      loadingSpan.textContent = 'Loading...';
      audioDuration.appendChild(loadingSpan);
      
      try{
        if(m.audioPath){
          // Get from cache or download
          const cached = await getCachedAudio(m.audioPath);
          if(!cached) throw new Error('Failed to download audio');
          
          audioElement.src = cached.blobUrl;
          audioPlayBtn.textContent = "";
          audioPlayBtn.disabled = false;
          audioPlayBtn.dataset.loaded = "true";
          audioPlayBtn.title = "Play audio";
          
          // Update duration display to show just time now
          audioDuration.textContent = formatDuration(durationSec);
          
          console.log('Audio ready for playback:', {
            msgId: m.id,
            size: formatBytes(cached.size),
            path: m.audioPath
          });
          
          return true;
        }else if(m.audioData){
          // Use base64 data (legacy or just-sent)
          audioElement.src = m.audioData;
          audioPlayBtn.textContent = "";
          audioPlayBtn.disabled = false;
          audioPlayBtn.dataset.loaded = "true";
          audioPlayBtn.title = "Play audio";
          audioDuration.textContent = formatDuration(durationSec);
          return true;
        }
      }catch(err){
        console.error('Error loading audio:', err);
        audioPlayBtn.textContent = "";
        audioPlayBtn.disabled = true;
        audioDuration.textContent = '';
        const failSpan = document.createElement('span');
        failSpan.style.opacity = '0.7';
        failSpan.style.color = 'var(--danger)';
        failSpan.textContent = 'Failed';
        audioDuration.appendChild(failSpan);
        showToast('Failed to load audio: ' + err.message, 'error');
        return false;
      }
    };
    
    // Handle audio element errors
    audioElement.addEventListener('error', (e) => {
      console.error('Audio playback error:', e);
      audioPlayBtn.textContent = "";
      audioPlayBtn.disabled = true;
      showToast('Audio playback failed', 'error');
    });
    
    // Play/pause functionality with on-demand loading
    audioPlayBtn.onclick = async () => {
      if(audioPlayBtn.disabled) return;
      
      // Load audio if not loaded yet
      if(audioPlayBtn.dataset.loaded !== "true"){
        const loaded = await loadAudioOnDemand();
        if(!loaded) return;
        // Don't auto-play after download, wait for second click
        showToast('Audio ready. Tap to play.', 'success');
        return;
      }
      
      const isPlaying = audioPlayBtn.dataset.playing === "true";
      
      if(isPlaying){
        audioElement.pause();
        audioPlayBtn.textContent = "";
        audioPlayBtn.dataset.playing = "false";
      }else{
        // Pause all other audio players
        document.querySelectorAll('.audio-play-btn[data-playing="true"]').forEach(btn => {
          if(btn !== audioPlayBtn){
            const otherMsgId = btn.closest('.msg-audio').dataset.msgId;
            const otherAudio = document.querySelector(`audio[data-msg-id="${otherMsgId}"]`);
            if(otherAudio){
              otherAudio.pause();
              btn.textContent = "";
              btn.dataset.playing = "false";
            }
          }
        });
        
        // Play this audio
        audioElement.play().then(() => {
          audioPlayBtn.textContent = "";
          audioPlayBtn.dataset.playing = "true";
          console.log('Audio playing:', m.id);
          
          // ========================================
          // AUDIO READ RECEIPT: Mark as listened when playback starts
          // This is the ONLY way audio messages get marked as "read"
          // (not just by being visible like regular text messages)
          // ========================================
          markAudioAsListened(m.id);
        }).catch(e => {
          console.error('Error playing audio:', e);
          showToast('Could not play audio: ' + e.message, 'error');
          audioPlayBtn.textContent = "";
        });
      }
    };
    
    //  Update waveform y tiempo durante reproduccin (optimizado con requestAnimationFrame)
    let playbackAnimationId = null;
    let lastUpdateTime = 0;
    const UPDATE_INTERVAL = 50; // Actualizar cada 50ms para suavidad y eficiencia
    
    const updatePlaybackProgress = (timestamp = 0) => {
      //  Throttle: Solo actualizar cada 50ms para mejor performance
      if(timestamp - lastUpdateTime < UPDATE_INTERVAL && lastUpdateTime !== 0){
        if(!audioElement.paused){
          playbackAnimationId = requestAnimationFrame(updatePlaybackProgress);
        }
        return;
      }
      lastUpdateTime = timestamp;
      
      if(!audioElement.duration) {
        if(!audioElement.paused){
          playbackAnimationId = requestAnimationFrame(updatePlaybackProgress);
        }
        return;
      }
      
      const progress = audioElement.currentTime / audioElement.duration;
      const bars = audioWaveform.querySelectorAll('.audio-wave-bar');
      const activeBarCount = Math.floor(progress * bars.length);
      
      //  Batch DOM updates para mejor performance
      requestAnimationFrame(() => {
        bars.forEach((bar, idx) => {
          if(idx < activeBarCount){
            bar.classList.add('active');
          }else{
            bar.classList.remove('active');
          }
        });
        
        // Update duration display con tiempo actual
        const currentSec = Math.floor(audioElement.currentTime);
        audioDuration.textContent = formatDuration(currentSec);
      });
      
      // Continue animation mientras reproduce
      if(!audioElement.paused){
        playbackAnimationId = requestAnimationFrame(updatePlaybackProgress);
      }
    };
    
    audioElement.addEventListener('play', () => {
      lastUpdateTime = 0; // Reset throttle
      playbackAnimationId = requestAnimationFrame(updatePlaybackProgress);
    });
    
    audioElement.addEventListener('pause', () => {
      if(playbackAnimationId){
        cancelAnimationFrame(playbackAnimationId);
        playbackAnimationId = null;
      }
    });
    
    //  timeupdate: Importante para seek/skip y como backup
    // El throttling (50ms) evita demasiadas actualizaciones
    audioElement.addEventListener('timeupdate', updatePlaybackProgress);
    
    audioElement.addEventListener('ended', () => {
      audioPlayBtn.textContent = "";
      audioPlayBtn.dataset.playing = "false";
      
      // Reset waveform
      const bars = audioWaveform.querySelectorAll('.audio-wave-bar');
      bars.forEach(bar => bar.classList.remove('active'));
      
      // Reset duration
      audioDuration.textContent = formatDuration(durationSec);
    });
    
    // Click waveform to seek
    audioWaveform.onclick = (e) => {
      if(!audioElement.duration) return;
      
      const rect = audioWaveform.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const progress = Math.max(0, Math.min(1, x / rect.width));
      audioElement.currentTime = progress * audioElement.duration;
    };
    
    audioMsg.appendChild(audioPlayBtn);
    audioMsg.appendChild(audioWaveform);
    audioMsg.appendChild(audioDuration);
    
    // ========================================
    // AUDIO READ RECEIPT UI: Show " N" indicator on sender's messages
    // Displays how many people listened to this audio message
    // Only visible to the person who sent the audio
    // Hover tooltip shows names of all listeners
    // ========================================
    const userId = session?.userId || localGuest.userId;
    const isMyMessage = m.userId === userId;
    
    if(isMyMessage && m.listenedBy && m.listenedBy.length > 0){
      const listenedCount = m.listenedBy.length;
      const listeners = m.listenedBy.map(l => l.username).join(', ');
      const listenedIndicator = document.createElement('div');
      listenedIndicator.className = 'audio-listened-indicator';
      const indicatorSpan = document.createElement('span');
      indicatorSpan.title = `Listened by: ${listeners}`;
      indicatorSpan.textContent = ` ${listenedCount}`;
      listenedIndicator.appendChild(indicatorSpan);
      listenedIndicator.style.cssText = 'font-size:10px; opacity:0.7; margin-top:4px; text-align:right; color:var(--muted);';
      audioMsg.appendChild(listenedIndicator);
    }
    
    text.appendChild(audioMsg);
    text.appendChild(audioElement);
  }else if(m.type === 'media' && m.attachments && m.attachments.length > 0){
    // ========================================
    // MEDIA MESSAGE: Images, Videos, Files
    // Render attachments using createElement (NO innerHTML)
    // ========================================
    
    // Separate attachments by type
    const images = m.attachments.filter(a => a.kind === 'image');
    const videos = m.attachments.filter(a => a.kind === 'video');
    const files = m.attachments.filter(a => a.kind === 'file');
    
    // IMAGES: Show up to 4 in 2x2 grid
    if(images.length > 0){
      const imageGrid = document.createElement('div');
      imageGrid.className = 'msg-media-grid';
      if(images.length === 1) imageGrid.classList.add('single');
      
      const displayImages = images.slice(0, 4);
      
      displayImages.forEach((img, idx) => {
        const tile = document.createElement('div');
        tile.className = 'media-image-tile';
        tile.dataset.index = idx;
        
        const imgEl = document.createElement('img');
        imgEl.alt = img.fileName || 'Image';
        imgEl.loading = 'lazy'; //  Browser native lazy loading
        
        // Load thumbnail or full image
        if(img.thumbPath){
          downloadMediaFromGitHub(img.thumbPath, 'image', false, 0).then(cached => {
            if(cached){
              imgEl.src = cached.blobUrl;
              tile.classList.add('loaded');
            }
          });
        }else if(img.path){
          downloadMediaFromGitHub(img.path, 'image', img.isChunked || false, img.chunkCount || 0).then(cached => {
            if(cached){
              imgEl.src = cached.blobUrl;
              tile.classList.add('loaded');
            }
          });
        }
        
        tile.appendChild(imgEl);
        
        // Add caption if exists
        if(img.caption && img.caption.trim()){
          const captionEl = document.createElement('div');
          captionEl.className = 'media-caption';
          captionEl.textContent = img.caption;
          captionEl.style.cssText = 'font-size:12px; color:var(--muted); margin-top:4px; padding:0 4px;';
          tile.appendChild(captionEl);
        }
        
        // If 4th tile and more images exist, add overlay
        if(idx === 3 && images.length > 4){
          const overlay = document.createElement('div');
          overlay.className = 'media-image-overlay';
          overlay.textContent = `+${images.length - 4}`;
          tile.appendChild(overlay);
          
          // Click overlay -> open gallery drawer
          tile.onclick = (e) => {
            e.stopPropagation();
            openGalleryDrawer(images, m.id);
          };
        }else{
          // Click tile -> open viewer
          tile.onclick = (e) => {
            e.stopPropagation();
            openImageViewer(images, idx, m.id);
          };
        }
        
        imageGrid.appendChild(tile);
      });
      
      text.appendChild(imageGrid);
    }
    
    // VIDEOS: Each video gets its own card
    videos.forEach((video, idx) => {
      const videoCard = document.createElement('div');
      videoCard.className = 'msg-video';
      videoCard.dataset.videoIndex = idx;
      
      const poster = document.createElement('div');
      poster.className = 'msg-video-poster';
      
      const posterImg = document.createElement('img');
      posterImg.alt = video.fileName || 'Video';
      
      // Load poster
      if(video.posterPath){
        downloadMediaFromGitHub(
          video.posterPath,
          'image',
          false,
          0
        ).then(cached => {
          if(cached){
            posterImg.src = cached.blobUrl;
            poster.classList.add('loaded');
          }
        });
      }
      
      poster.appendChild(posterImg);
      
      // Play button
      const playBtn = document.createElement('button');
      playBtn.className = 'msg-video-play-btn';
      playBtn.textContent = '';
      
      // Close button (initially hidden)
      const closeBtn = document.createElement('button');
      closeBtn.className = 'msg-video-close-btn';
      closeBtn.textContent = '';
      closeBtn.title = 'Cerrar video';
      
      let currentVideoEl = null;
      
      playBtn.onclick = async (e) => {
        e.stopPropagation();
        
        // If video is already playing, just resume
        if(currentVideoEl){
          posterImg.style.display = 'none';
          playBtn.style.display = 'none';
          currentVideoEl.style.display = 'block';
          poster.classList.add('playing');
          currentVideoEl.play();
          return;
        }
        
        // Download and play video
        playBtn.textContent = '';
        playBtn.style.background = 'rgba(255,255,255,.5)';
        
        const cached = await downloadMediaFromGitHub(
          video.path,
          'video',
          video.isChunked || false,
          video.chunkCount || 0
        );
        if(cached){
          const videoEl = document.createElement('video');
          videoEl.src = cached.blobUrl;
          videoEl.controls = true;
          videoEl.autoplay = true;
          videoEl.style.cssText = 'width:100%; max-height:500px; border-radius:20px; box-shadow:0 8px 32px rgba(0,0,0,.4); display:block;';
          
          // Hide poster elements and show video
          posterImg.style.display = 'none';
          playBtn.style.display = 'none';
          poster.appendChild(videoEl);
          poster.classList.add('playing');
          poster.style.aspectRatio = 'auto';
          
          currentVideoEl = videoEl;
        }else{
          playBtn.textContent = '';
          playBtn.style.background = 'rgba(255,100,100,.8)';
        }
      };
      
      closeBtn.onclick = (e) => {
        e.stopPropagation();
        // Pause video and show poster again
        if(currentVideoEl){
          currentVideoEl.pause();
          currentVideoEl.style.display = 'none';
        }
        posterImg.style.display = 'block';
        playBtn.style.display = 'flex';
        playBtn.textContent = '';
        playBtn.style.background = '';
        poster.classList.remove('playing');
        poster.style.aspectRatio = '16/9';
      };
      
      poster.appendChild(playBtn);
      poster.appendChild(closeBtn);
      
      // Preview overlay for long-press
      const previewOverlay = document.createElement('div');
      previewOverlay.className = 'msg-video-preview-overlay';
      poster.appendChild(previewOverlay);
      
      // Long-press preview (mobile)
      let longPressTimer = null;
      let previewVideo = null;
      
      poster.addEventListener('touchstart', (e) => {
        longPressTimer = setTimeout(async () => {
          // Start 5-second preview
          const cached = await downloadMediaFromGitHub(
            video.path,
            'video',
            video.isChunked || false,
            video.chunkCount || 0
          );
          if(cached){
            previewVideo = document.createElement('video');
            previewVideo.src = cached.blobUrl;
            previewVideo.muted = true;
            previewVideo.currentTime = 0;
            previewOverlay.appendChild(previewVideo);
            previewOverlay.classList.add('active');
            
            previewVideo.play();
            
            // Auto-stop after 5 seconds
            setTimeout(() => {
              if(previewVideo){
                previewVideo.pause();
                previewOverlay.classList.remove('active');
                previewOverlay.innerHTML = '';
                previewVideo = null;
              }
            }, 5000);
          }
        }, 800); // 800ms to trigger long-press
      });
      
      poster.addEventListener('touchend', () => {
        if(longPressTimer){
          clearTimeout(longPressTimer);
          longPressTimer = null;
        }
        // Stop preview if active
        if(previewVideo){
          previewVideo.pause();
          previewOverlay.classList.remove('active');
          previewOverlay.innerHTML = '';
          previewVideo = null;
        }
      });
      
      videoCard.appendChild(poster);
      
      // Video info
      const videoInfo = document.createElement('div');
      videoInfo.className = 'msg-video-info';
      
      const fileNameSpan = document.createElement('span');
      fileNameSpan.textContent = video.fileName || 'Video';
      videoInfo.appendChild(fileNameSpan);
      
      const sizeSpan = document.createElement('span');
      sizeSpan.textContent = `${formatBytes(video.size || 0)}  ${formatDuration(video.duration || 0)}`;
      videoInfo.appendChild(sizeSpan);
      
      videoCard.appendChild(videoInfo);
      
      // Add caption if exists
      if(video.caption && video.caption.trim()){
        const captionEl = document.createElement('div');
        captionEl.className = 'media-caption';
        captionEl.textContent = video.caption;
        captionEl.style.cssText = 'font-size:12px; color:var(--muted); margin-top:6px; padding:0 8px; word-break: break-word;';
        videoCard.appendChild(captionEl);
      }
      
      text.appendChild(videoCard);
    });
    
    // FILES/DOCUMENTS: Show as file chips
    files.forEach((file, idx) => {
      const fileChip = document.createElement('div');
      fileChip.className = 'msg-file';
      fileChip.dataset.fileIndex = idx;
      
      const fileIcon = document.createElement('div');
      fileIcon.className = 'msg-file-icon';
      fileIcon.textContent = getFileIcon(file.mime);
      
      const fileInfo = document.createElement('div');
      fileInfo.className = 'msg-file-info';
      
      const fileName = document.createElement('div');
      fileName.className = 'msg-file-name';
      fileName.textContent = file.fileName || 'File';
      
      const fileSize = document.createElement('div');
      fileSize.className = 'msg-file-size';
      fileSize.textContent = formatBytes(file.size || 0);
      
      fileInfo.appendChild(fileName);
      fileInfo.appendChild(fileSize);
      
      const downloadBtn = document.createElement('button');
      downloadBtn.className = 'msg-file-download';
      downloadBtn.textContent = '';
      downloadBtn.onclick = async (e) => {
        e.stopPropagation();
        downloadBtn.disabled = true;
        downloadBtn.textContent = '';
        
        try{
          const cached = await downloadMediaFromGitHub(file.path, 'file');
          if(cached){
            // Trigger download
            const a = document.createElement('a');
            a.href = cached.blobUrl;
            a.download = file.fileName || 'download';
            a.click();
            downloadBtn.textContent = '';
            setTimeout(() => {
              downloadBtn.textContent = '';
              downloadBtn.disabled = false;
            }, 2000);
          }else{
            throw new Error('Download failed');
          }
        }catch(err){
          downloadBtn.textContent = '';
          setTimeout(() => {
            downloadBtn.textContent = '';
            downloadBtn.disabled = false;
          }, 2000);
          showToast('Failed to download file', 'error');
        }
      };
      
      fileChip.appendChild(fileIcon);
      fileChip.appendChild(fileInfo);
      fileChip.appendChild(downloadBtn);
      
      // Add caption if exists
      if(file.caption && file.caption.trim()){
        const captionEl = document.createElement('div');
        captionEl.className = 'media-caption';
        captionEl.textContent = file.caption;
        captionEl.style.cssText = 'font-size:11px; color:var(--muted); margin-top:4px; padding:0 8px; word-break: break-word;';
        fileChip.appendChild(captionEl);
      }
      
      text.appendChild(fileChip);
    });
    
    // Show message text as caption if present
    if(m.text && m.text.trim()){
      const captionEl = document.createElement('div');
      captionEl.className = 'media-caption';
      captionEl.style.cssText = 'margin-top:8px; padding:8px 0; font-size:14px; line-height:1.4;';
      
      // Highlight mentions in caption
      const currentUser = session?.username || nameInput.value || localGuest.name;
      const highlightedCaption = highlightMentions(m.text, currentUser);
      captionEl.appendChild(highlightedCaption);
      
      text.appendChild(captionEl);
    }
    
  }else{
    // Regular text message
    // Highlight mentions in text
    if(!m.deleted){
      const currentUser = session?.username || nameInput.value || localGuest.name;
      const highlightedContent = highlightMentions(m.text, currentUser);
      text.appendChild(highlightedContent);
    }else{
      //  Mensaje borrado: mostrar con estilo especial
      const deletedEl = document.createElement('span');
      deletedEl.style.cssText = 'font-style:italic; color:var(--muted); opacity:0.6;';
      deletedEl.textContent = ' This message was deleted';
      text.appendChild(deletedEl);
    }
  }

  const meta = document.createElement("div");
  meta.className = "meta";
  const d = new Date(m.ts);
  const hh = String(d.getHours()).padStart(2,"0");
  const mm = String(d.getMinutes()).padStart(2,"0");
  const timeText = document.createElement("span");
  
  //  Mostrar info de borrado si aplica
  if(m.deleted && m.deletedAt){
    const deletedDate = new Date(m.deletedAt);
    const delHH = String(deletedDate.getHours()).padStart(2,"0");
    const delMM = String(deletedDate.getMinutes()).padStart(2,"0");
    timeText.textContent = `${hh}:${mm}  ${m.sender}  deleted at ${delHH}:${delMM}`;
    timeText.style.color = 'var(--muted)';
  }else{
    timeText.textContent = `${hh}:${mm}  ${m.sender}${m.edited ? "  edited":""}`;
  }
  meta.appendChild(timeText);

  // Message status indicator (for own messages only)
  if(session && m.userId === session.userId){
    const status = document.createElement("span");
    status.className = `msg-status status-${m.status || 'sending'}`;
    status.dataset.msgId = m.id;
    meta.appendChild(status);

    // Retry button for failed messages
    if(m.status === 'failed'){
      const retry = document.createElement("button");
      retry.className = "msg-retry";
      retry.textContent = "Retry";
      retry.onclick = (e) => { e.stopPropagation(); retryMessage(m); };
      meta.appendChild(retry);
      wrap.classList.add('msg-failed');
    }
  }

  const reads = document.createElement("div");
  reads.className = "reads";
  reads.textContent = ""; // filled by updateReadBadges()

  wrap.appendChild(text);
  wrap.appendChild(meta);
  wrap.appendChild(reads);

  // Actions (edit/delete/reply) for all messages
  const actions = document.createElement('div');
  actions.className = 'msg-actions';

  // Reply button (for all messages)
  const replyBtn = document.createElement('button');
  replyBtn.textContent = ' Reply';
  replyBtn.addEventListener('click', (e)=>{ 
    e.stopPropagation(); 
    setReplyTo(m); 
  });
  actions.appendChild(replyBtn);

  // Edit/Delete only for own messages
  if(session && m.userId === session.userId){
    // Show edit button only if there's text to edit
    // - Text messages: always have text
    // - Media messages: only if caption was added
    // - Audio messages: never (can't edit audio)
    const hasTextToEdit = m.type === 'text' || (m.type === 'media' && m.text && m.text.trim());
    
    if(m.type !== 'audio' && hasTextToEdit){
      const editBtn = document.createElement('button');
      editBtn.textContent = ' Edit';
      editBtn.addEventListener('click', (e)=>{ e.stopPropagation(); editMessageById(m.id); });
      actions.appendChild(editBtn);
    }

    const delBtn = document.createElement('button');
    delBtn.textContent = ' Delete';
    delBtn.className = 'danger';
    delBtn.addEventListener('click', (e)=>{ e.stopPropagation(); deleteMessageById(m.id); });

    actions.appendChild(delBtn);
  }
  
  wrap.appendChild(actions);
  
  // Return the element instead of appending to DOM (for batch rendering)
  return wrap;
}

function clearView(){
  messagesEl.innerHTML = "";
  loadedMessages = [];
  loadedCellsMin = null;
  loadedCellsMax = null;
  log(" Cleared view (history still in GitHub).","INFO");
}

function pickLoadCountFromScrollSpeed(pxPerSec){
  // Mobile flick / fast wheel -> bigger batch
  if(pxPerSec >= 2400) return 100;
  if(pxPerSec >= 1200) return 50;
  return 20;
}

/* ============================================================
   LIVE CELL DETECTION (Scroll-based)
   ============================================================ */
let cellDetectionThrottle = null;

function detectVisibleCells(){
  if(!messagesEl || !currentRoom) return;
  
  // Get all message nodes in viewport
  const rect = messagesEl.getBoundingClientRect();
  const messages = messagesEl.querySelectorAll('.msg');
  
  if(messages.length === 0) return;
  
  // Find messages in viewport (center 50% for stability)
  const centerY = rect.top + rect.height / 2;
  const tolerance = rect.height * 0.25; // 25% tolerance
  
  const visibleCells = new Set();
  let closestToCenter = null;
  let closestDistance = Infinity;
  
  for(const msg of messages){
    const msgRect = msg.getBoundingClientRect();
    const msgCenterY = msgRect.top + msgRect.height / 2;
    const distance = Math.abs(msgCenterY - centerY);
    
    // Check if in viewport center area
    if(distance < tolerance){
      const cellNum = parseInt(msg.dataset.cell || '0', 10);
      if(cellNum > 0) visibleCells.add(cellNum);
    }
    
    // Track closest to exact center
    if(distance < closestDistance){
      closestDistance = distance;
      closestToCenter = msg;
    }
  }
  
  // Use cell closest to center as "current viewing cell"
  let viewingCell = null;
  if(closestToCenter){
    viewingCell = parseInt(closestToCenter.dataset.cell || '0', 10);
  }
  
  // If no cell found, use first visible
  if(!viewingCell && visibleCells.size > 0){
    viewingCell = Math.min(...Array.from(visibleCells));
  }
  
  // Update metadata if changed
  if(viewingCell && viewingCell !== cellMetadata.currentViewingCell){
    const totalCells = loadedCellsMax || roomIndex?.latestCell || 0;
    const latestCell = roomIndex?.latestCell || totalCells;
    updateCellMetadata(viewingCell, totalCells, latestCell);
  }
}

function startCellDetection(){
  if(!messagesEl) return;
  
  // Throttled scroll listener
  messagesEl.addEventListener('scroll', ()=>{
    clearTimeout(cellDetectionThrottle);
    cellDetectionThrottle = setTimeout(detectVisibleCells, 150);
  }, {passive: true});
  
  // Initial detection
  setTimeout(detectVisibleCells, 500);
  
  // Periodic check every 3 seconds (backup)
  setInterval(()=>{
    if(running && currentRoom && messagesEl.childElementCount > 0){
      detectVisibleCells();
    }
  }, 3000);
}

function installLazyLoader(){
  let lastTop = messagesEl.scrollTop;
  let lastT = performance.now();

  messagesEl.addEventListener("scroll", async ()=>{
    // If near top -> load older
    if(messagesEl.scrollTop > 90) return;

    const now = performance.now();
    const dt = Math.max(1, now-lastT);
    const dy = Math.abs(messagesEl.scrollTop-lastTop);
    const speed = (dy/dt)*1000; // px/s
    lastTop = messagesEl.scrollTop;
    lastT = now;

    const want = pickLoadCountFromScrollSpeed(speed);

    // Preserve current viewport anchor so content doesn't jump
    const prevHeight = messagesEl.scrollHeight;

    const older = await loadOlderByMessages(currentRoom, want);
    if(!older.length) return;

    // Prepend older
    for(let i=older.length-1;i>=0;i--){
      addMessageToDom(older[i], true, true);
    }
    // Keep scroll position steady (so user doesn't get yeeted)
    const newHeight = messagesEl.scrollHeight;
    messagesEl.scrollTop = newHeight - prevHeight;
    setupReadObserver();
    updateReadBadges();
  }, { passive:true });
}

/* ============================================================
   MESSAGE EDIT / DELETE helpers
   - editMessageById: allow owner to change text; write back to correct cell
   - deleteMessageById: mark deleted=true (delete for everyone)
 ============================================================ */

async function findMessageLocation(msgId){
  // Try loadedMessages first
  for(const m of loadedMessages){
    if(m.id === msgId){
      // If message has cell stored, return quickly
      if(m.cell) return { cell: m.cell, msg: m };
    }
  }

  // Fallback: scan last few cells from roomIndex.latestCell downwards
  await loadRoomIndex(currentRoom);
  const latest = roomIndex?.latestCell || 1;
  const scanCount = Math.min(6, latest); // scan up to last 6 cells
  for(let c = latest; c >= Math.max(1, latest - scanCount + 1); c--){
    try{
      const got = await ghGetJsonWithSha(cellPath(currentRoom, c));
      if(!got.ok || !Array.isArray(got.obj)) continue;
      for(const raw of got.obj){
        if(raw && raw.id === msgId){
          const msg = normalizeMessage(raw);
          msg.cell = c;
          return { cell: c, msg, cellArr: got.obj, cellSha: got.sha };
        }
      }
    }catch(_){/* ignore */}
  }
  return null;
}

/* =========================
   Modal UI (v3 style)  openModal / closeModal / showEditModal / showConfirmModal
   These avoid alerts/prompts and use the DOM modal overlay.
   Requires elements with ids: modalOverlay, modalTitle, modalBody, modalOk, modalCancel, modalClose
   If not present, we create a minimal modal markup now.
========================= */

let _modalResolve = null;
function ensureModalDom(){
  if(document.getElementById('modalOverlay')) return;
  const html = `
  <div id="modalOverlay" class="modal-overlay modal-hidden" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modal-header">
        <div id="modalTitle" class="modal-title">Modal</div>
        <button id="modalClose" class="modal-close"></button>
      </div>
      <div class="modal-body" id="modalBody"></div>
      <div class="modal-footer">
        <button id="modalCancel" class="btn-ghost">Cancel</button>
        <button id="modalOk" class="primary">OK</button>
      </div>
    </div>
  </div>`;
  document.body.insertAdjacentHTML('beforeend', html);
  const mo = document.getElementById('modalOverlay');
  document.getElementById('modalClose').addEventListener('click', ()=> closeModal(false));
  document.getElementById('modalCancel').addEventListener('click', ()=> closeModal(false));
  document.getElementById('modalOk').addEventListener('click', ()=> closeModal(true));
}

function openModal({ title, bodyNode, okText='OK', cancelText='Cancel', showCancel=true }){
  ensureModalDom();
  const overlay = document.getElementById('modalOverlay');
  const titleEl = document.getElementById('modalTitle');
  const bodyEl = document.getElementById('modalBody');
  const okBtn = document.getElementById('modalOk');
  const cancelBtn = document.getElementById('modalCancel');

  titleEl.textContent = title || 'Modal';
  bodyEl.innerHTML = '';
  if(bodyNode) bodyEl.appendChild(bodyNode);
  okBtn.textContent = okText;
  cancelBtn.textContent = cancelText;
  cancelBtn.style.display = showCancel ? '' : 'none';
  overlay.classList.remove('modal-hidden');
  return new Promise((resolve)=>{ _modalResolve = resolve; });
}

function closeModal(result){
  const overlay = document.getElementById('modalOverlay');
  if(overlay) overlay.classList.add('modal-hidden');
  try{ if(_modalResolve) _modalResolve(result); }finally{ _modalResolve = null; }
}

async function showEditModal(oldText){
  const wrap = document.createElement('div');
  const p = document.createElement('p'); p.textContent = 'Edit your message:'; wrap.appendChild(p);
  const ta = document.createElement('textarea'); ta.value = oldText || ''; ta.style.width = '100%'; ta.style.minHeight = '120px';
  wrap.appendChild(ta);
  const ok = await openModal({ title:'Edit message', bodyNode: wrap, okText:'Save', cancelText:'Cancel', showCancel:true });
  if(!ok) return null;
  const val = (ta.value||'').trim();
  return val.length ? val : null;
}

async function showConfirmModal(text){
  const wrap = document.createElement('div');
  const p = document.createElement('p'); p.textContent = text || 'Confirm?'; wrap.appendChild(p);
  const ok = await openModal({ title:'Confirm', bodyNode: wrap, okText:'Yes', cancelText:'No', showCancel:true });
  return !!ok;
}

async function editMessageById(msgId){
  if(!currentRoom) return;
  // Find message in loadedMessages or storage
  const loc = await findMessageLocation(msgId);
  if(!loc) { log('Message not found','WARN'); return; }
  const orig = loc.msg;

  const userId = session?.userId || localGuest.userId;
  if(orig.userId !== userId){ log('You can only edit your own messages','WARN'); return; }

  const newText = await showEditModal(orig.text || '');
  if(!newText) return; // canceled or empty
  const trimmed = String(newText).trim();

  // Load the cell array if we don't have it
  let cellArr = loc.cellArr;
  let cellSha = loc.cellSha;
  if(!cellArr){
    const got = await ghGetJsonWithSha(cellPath(currentRoom, loc.cell));
    if(!got.ok || !Array.isArray(got.obj)){ showToast('Failed to read cell for edit', 'error'); return; }
    cellArr = got.obj;
    cellSha = got.sha;
  }

  // Find message inside cellArr
  const idx = cellArr.findIndex(x => x && x.id === msgId);
  if(idx === -1){ showToast('Message not found in storage', 'error'); return; }

  // Update fields
  cellArr[idx].text = trimmed;
  cellArr[idx].edited = true;
  cellArr[idx].editedAt = Date.now();
  cellArr[idx].editedBy = userId;

  // PUT back
  try{
    const put = await ghPutJson(cellPath(currentRoom, loc.cell), cellArr, cellSha, `edit msg ${msgId}`);
    // Update in-memory loadedMessages and DOM
    for(const m of loadedMessages){ if(m.id === msgId){ m.text = trimmed; m.edited = true; m.editedAt = cellArr[idx].editedAt; } }
    const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
    if(el){
      const textEl = el.querySelector('.text'); if(textEl) textEl.textContent = trimmed;
      const meta = el.querySelector('.meta'); if(meta){
        const d = new Date(cellArr[idx].ts||Date.now());
        const hh = String(d.getHours()).padStart(2,'0');
        const mm = String(d.getMinutes()).padStart(2,'0');
        meta.textContent = `${hh}:${mm}  ${cellArr[idx].sender}  edited`;
      }
    }
    showToast('Message edited successfully', 'success');
  }catch(e){ console.error('[editMessage ERROR]', e); showToast('Edit failed: '+String(e), 'error'); }
}

async function deleteMessageById(msgId){
  if(!currentRoom) return;
  const loc = await findMessageLocation(msgId);
  if(!loc) { log('Message not found','WARN'); return; }
  const orig = loc.msg;
  const userId = session?.userId || localGuest.userId;
  if(orig.userId !== userId){ log('You can only delete your own messages','WARN'); return; }

  const ok = await showConfirmModal('Delete this message for everyone? This will mark it deleted.');
  if(!ok) return;

  let cellArr = loc.cellArr;
  let cellSha = loc.cellSha;
  if(!cellArr){
    const got = await ghGetJsonWithSha(cellPath(currentRoom, loc.cell));
    if(!got.ok || !Array.isArray(got.obj)){ showToast('Failed to read cell for delete', 'error'); return; }
    cellArr = got.obj;
    cellSha = got.sha;
  }

  const idx = cellArr.findIndex(x => x && x.id === msgId);
  if(idx === -1){ showToast('Message not found in storage', 'error'); return; }

  cellArr[idx].deleted = true;
  cellArr[idx].deletedAt = Date.now();
  cellArr[idx].deletedBy = userId;

  try{
    const put = await ghPutJson(cellPath(currentRoom, loc.cell), cellArr, cellSha, `delete msg ${msgId}`);
    
    //  NOTIFICAR A OTROS DISPOSITIVOS: Activar master flag
    await saveMasterValue(currentRoom, true);
    log(' Master flag activated - other devices will sync deleted message', 'INFO');
    
    // Update in-memory and DOM
    for(const m of loadedMessages){ 
      if(m.id === msgId){ 
        m.deleted = true; 
        m.deletedAt = Date.now();
        m.deletedBy = userId;
      } 
    }
    
    //  Actualizar DOM con renderizado mejorado
    const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
    if(el){
      // Reemplazar completamente el elemento con versin borrada
      const updatedMsg = loadedMessages.find(m => m.id === msgId);
      if(updatedMsg){
        const newEl = createMessageElement(updatedMsg);
        el.replaceWith(newEl);
        if(readObserver) readObserver.observe(newEl);
      }
    }
    
    log('Message deleted and synced to all devices','INFO');
    showToast('Message deleted successfully', 'success');
  }catch(e){ console.error('[deleteMessage ERROR]', e); log('Delete failed: '+String(e),'ERROR'); showToast('Delete failed: '+String(e), 'error'); }
}

/* ============================================================
   === PRESENCE ===
   ============================================================ */
const presenceState = {
  inRoom:false,
  isIdle:true,
  heartbeatTimer:null,
  lastOnlineWriteAt:0,
  lastPresenceWriteSha:null
};

async function presenceWrite(obj){
  if(!currentRoom) return;
  const p = presencePath(currentRoom, obj.userId);
  
  try {
    // Try optimistic write with cached SHA (no CORS preflight needed if using cache)
    const cachedSha = getCachedSha(p);
    
    if(cachedSha){
      // We have cached SHA - try write immediately
      const result = await ghPutJson(p, obj, cachedSha, "presence");
      if(result && result.ok) return; // Success!
    }
    
    // No cached SHA or write failed - try without SHA (for new files)
    const result = await ghPutJson(p, obj, undefined, "presence");
    if(result && result.ok) return; // Success!
    
  } catch(error) {
    // CORS or network error - log but don't throw
    // This allows app to continue working even when GitHub API is slow
    console.warn('[presenceWrite] Failed (CORS/network):', error.message);
    // Don't show toast - presence updates are not critical
  }
}

async function presenceSetOnline(online, reason=""){
  if(!currentRoom) return;

  const now = Date.now();
  const userId = session?.userId || localGuest.userId;
  const username = session?.username || localGuest.name || "Guest";

  const base = presenceCache.get(userId) || {
    v:1, room: currentRoom, userId, username,
    online:false,
    lastSeenAt: now,
    lastActiveAt: now,
    lastReadTs: 0,
    lastReadMsgId: null,
    device: { ua: navigator.userAgent, platform: navigator.platform || "" }
  };

  if(online){
    base.online = true;
    base.lastActiveAt = now;
    base.lastSeenAt = now;
    presenceState.isIdle = false;

    // Start heartbeat if not running
    if(!presenceState.heartbeatTimer){
      presenceState.heartbeatTimer = setInterval(async ()=>{
        if(!running || !currentRoom) return;
        if(!isActiveNow()){
          // Stop on idle
          await presenceSetOnline(false, "idle-heartbeat");
          return;
        }
        await presenceSetOnline(true, "heartbeat");
      }, PRESENCE_ACTIVE_HEARTBEAT_MS);
    }
  }else{
    base.online = false;
    base.lastSeenAt = now;
    presenceState.isIdle = true;

    // Stop heartbeat
    if(presenceState.heartbeatTimer){
      clearInterval(presenceState.heartbeatTimer);
      presenceState.heartbeatTimer = null;
    }
  }

  // Throttle "online/offline" writes so we don't spam
  if(now - presenceState.lastOnlineWriteAt < 700 && reason!=="heartbeat") return;
  presenceState.lastOnlineWriteAt = now;

  presenceCache.set(userId, base);
  await presenceWrite(base);
}

async function refreshPresence(){
  if(!currentRoom) return;

  const dir = await ghListDir(`${ROOMS_META_DIR}/${currentRoom}/presence`);
  if(!dir.ok) return;

  // Pull each presence file (small)
  const now = Date.now();
  const next = new Map();

  for(const it of dir.items){
    if(it.type!=="file" || !it.name.endsWith(".json")) continue;
    const got = await ghGetJsonWithSha(`${ROOMS_META_DIR}/${currentRoom}/presence/${it.name}`);
    if(got.ok && got.obj && got.obj.userId){
      next.set(got.obj.userId, got.obj);
    }
  }

  presenceCache = next;
  lastPresenceRefreshAt = now;
  renderPresenceSummary();
  updateReadBadges();
}

async function maybeRefreshPresence(){
  const now = Date.now();
  if(now - lastPresenceRefreshAt < 10_000) return; // at most every 10s active
  await refreshPresence();
}

function renderPresenceSummary(){
  if(!currentRoom) return;
  const now = Date.now();
  let active=0, recent=0;
  for(const p of presenceCache.values()){
    const lastActiveAt = p.lastActiveAt||0;
    const lastSeenAt = p.lastSeenAt||0;
    if(now - lastActiveAt < 10_000) active++;
    else if(now - lastSeenAt < PRESENCE_RECENT_MS) recent++;
  }
  presenceText.textContent = `presence: ${active} active  ${recent} recent`;
}

/* ============================================================
   === READ RECEIPTS ===
   ============================================================ */
let readObserver = null;
let readHoldTimers = new Map(); // msgId -> timer

function setupReadObserver(){
  if(!messagesEl) return;
  if(readObserver) return; // install once

  readObserver = new IntersectionObserver((entries)=>{
    for(const ent of entries){
      const node = ent.target;
      const msgId = node.dataset.msgId;
      const ts = Number(node.dataset.ts||0);
      
      // ========================================
      // AUDIO READ RECEIPT: Skip automatic read tracking for audio messages
      // Audio messages require explicit user interaction (download + play)
      // to be marked as "listened". This prevents marking audio as "read"
      // when user just scrolls past it without actually listening.
      // ========================================
      const isAudioMsg = node.querySelector('.msg-audio');
      if(isAudioMsg){
        continue;
      }

      // Only consider if visible enough
      if(ent.intersectionRatio < 0.60){
        // cancel pending
        if(readHoldTimers.has(msgId)){
          clearTimeout(readHoldTimers.get(msgId));
          readHoldTimers.delete(msgId);
        }
        continue;
      }

      // If fast scrolling, ignore
      if(Date.now() < window._chat_fastScrollingUntil) continue;

      // Hold 250ms visible
      if(readHoldTimers.has(msgId)) continue;

      const t = setTimeout(async ()=>{
        readHoldTimers.delete(msgId);
        // Re-check visibility by bounding box within container
        if(Date.now() < window._chat_fastScrollingUntil) return;

        // Zone weighting (TOP/CENTER/BOTTOM)  we only store monotonic lastReadTs
        const rect = node.getBoundingClientRect();
        const rootRect = messagesEl.getBoundingClientRect();
        const centerY = rect.top + rect.height/2;
        const rel = (centerY - rootRect.top) / Math.max(1, rootRect.height);
        // Zones: [0..0.33]=TOP, (0.33..0.66]=CENTER, (0.66..1]=BOTTOM
        const zone = (rel <= 0.33) ? "TOP" : (rel <= 0.66 ? "CENTER" : "BOTTOM");

        await markRead(ts, msgId, zone);
      }, 250);

      readHoldTimers.set(msgId, t);
    }
  }, { root: messagesEl, threshold: [0,0.6,1] });

  // Observe existing nodes
  for(const node of messagesEl.querySelectorAll(".msg")){
    readObserver.observe(node);
  }
}

async function markRead(ts, msgId, zone){
  if(!currentRoom) return;

  // If user is reading old messages (scrolled up), we still only store monotonic lastReadTs
  const userId = session?.userId || localGuest.userId;

  const p = presenceCache.get(userId);
  if(!p) return;

  const prev = p.lastReadTs || 0;
  const next = Math.max(prev, ts);

  if(next === prev) return; // no change

  p.lastReadTs = next;
  p.lastReadMsgId = msgId;
  p.lastSeenAt = Date.now();
  if(zone !== "TOP") p.lastActiveAt = Date.now(); // center/bottom implies more "engaged"

  presenceCache.set(userId, p);

  // Throttle writes
  const now = Date.now();
  if(now - lastReadWriteAt < 1500) return;
  lastReadWriteAt = now;

  await presenceWrite(p);
  updateReadBadges();
}

/* ============================================================
   AUDIO READ RECEIPTS: markAudioAsListened()
   
   Tracks when users actually PLAY audio messages (not just see them).
   This function is called when user clicks play button on an audio message.
   
   What it does:
   1. Checks if user already listened (prevents duplicates)
   2. Adds {userId, username, listenedAt} to message.listenedBy array
   3. Updates message in GitHub cell with listened status
   4. Marks message as "read" in presence tracking
   5. Updates UI badges to show "listened by" count
   
   GitHub Storage:
   - listenedBy array saved to: rooms-cells/<room>/cells/cell-NNNNNN.json
   - Synced across all devices via poll loop
   - Sender can see who listened to their audio messages
   ============================================================ */
async function markAudioAsListened(msgId){
  if(!currentRoom) return;
  
  const userId = session?.userId || localGuest.userId;
  const username = session?.username || localGuest.name || "Guest";
  
  // Find the message in loadedMessages array
  const msg = loadedMessages.find(m => m.id === msgId);
  if(!msg || msg.type !== 'audio') return;
  
  // Prevent duplicate entries - check if this user already listened
  if(!msg.listenedBy) msg.listenedBy = [];
  const alreadyListened = msg.listenedBy.some(l => l.userId === userId);
  if(alreadyListened) return;
  
  // Create listened entry with user info and timestamp
  const listenEntry = {
    userId,
    username,
    listenedAt: Date.now()
  };
  msg.listenedBy.push(listenEntry);
  
  log(` Marked audio as listened: ${msgId}`, 'INFO');
  
  // ========================================
  // Save listened status to GitHub for cross-device sync
  // This updates the message in the cell JSON file
  // ========================================
  try{
    const cellNum = msg.cell;
    if(!cellNum){
      console.warn('No cell number for message:', msgId);
      return;
    }
    
    const got = await ghGetJsonWithSha(cellPath(currentRoom, cellNum));
    if(!got.ok || !Array.isArray(got.obj)){
      console.error('Failed to load cell for audio listened update');
      return;
    }
    
    const cellArr = got.obj;
    const idx = cellArr.findIndex(m => m.id === msgId);
    if(idx === -1){
      console.warn('Message not found in cell:', msgId);
      return;
    }
    
    // Update the message in the cell with listened entry
    if(!cellArr[idx].listenedBy) cellArr[idx].listenedBy = [];
    cellArr[idx].listenedBy.push(listenEntry);
    
    // Write updated cell back to GitHub with SHA for conflict resolution
    const put = await ghPutJson(cellPath(currentRoom, cellNum), cellArr, got.sha, `audio listened ${msgId}`);
    if(put && put.ok){
      log(` Audio listened status saved to GitHub`, 'INFO');
      
      // Also mark as read in presence (updates lastReadTs)
      // This ensures the message is considered "read" for badge calculations
      await markRead(msg.ts, msgId, 'CENTER');
      
      // Refresh UI to show "listened by" count
      updateReadBadges();
    }
  }catch(err){
    console.error('Error updating audio listened status:', err);
  }
}

function updateReadBadges(){
  // ========================================
  // READ RECEIPTS: Show "read by" for text, "listened by" for audio
  // 
  // Text messages: Use presence.lastReadTs (automatic when visible)
  // Audio messages: Use message.listenedBy array (only when played)
  // 
  // This dual system ensures:
  // - Text messages = seen = read (traditional)
  // - Audio messages = played = read (engagement-based)
  // ========================================
  const nodes = messagesEl.querySelectorAll(".msg");
  const selfId = session?.userId || localGuest.userId;
  
  for(const node of nodes){
    const ts = Number(node.dataset.ts||0);
    const msgId = node.dataset.msgId;
    const readsEl = node.querySelector(".reads");
    if(!readsEl) continue;
    
    // Check if this is an audio message
    const isAudioMsg = node.querySelector('.msg-audio');
    
    if(isAudioMsg){
      // ========================================
      // AUDIO READ RECEIPT: Use listenedBy array (not presence tracking)
      // Shows "listened by" instead of "read by"
      // Only counts users who actually played the audio
      // ========================================
      const msg = loadedMessages.find(m => m.id === msgId);
      if(msg && msg.listenedBy && msg.listenedBy.length > 0){
        const listeners = msg.listenedBy
          .filter(l => l.userId !== selfId)  // Exclude self from count
          .map(l => l.username || l.userId);
        
        if(listeners.length > 0){
          readsEl.textContent = `listened by: ${listeners.slice(0,3).join(", ")}${listeners.length>3?"":""}`;
          
          // Update message status indicator to 'read' ()
          const statusEl = node.querySelector('.msg-status');
          if(statusEl){
            updateMessageStatus(msgId, 'read');
          }
        }else{
          readsEl.textContent = "";
        }
      }else{
        readsEl.textContent = "";
      }
    }else{
      // ========================================
      // REGULAR MESSAGE READ RECEIPT: Use presence.lastReadTs
      // Traditional read tracking - marks as read when visible
      // ========================================
      const readers = [];
      let hasOtherReaders = false;
      
      for(const p of presenceCache.values()){
        if(!p.userId) continue;
        if((p.lastReadTs||0) >= ts){
          // don't show self
          if(p.userId !== selfId){
            readers.push(p.username || p.userId);
              hasOtherReaders = true;
          }
        }
      }
      readsEl.textContent = readers.length ? `read by: ${readers.slice(0,3).join(", ")}${readers.length>3?"":""}` : "";
      
      // Update own message status to 'read' if others have read it
      const statusEl = node.querySelector('.msg-status');
      if(statusEl && hasOtherReaders){
        const currentStatus = statusEl.className.match(/status-(\w+)/)?.[1];
        if(currentStatus && ['sent', 'delivered'].includes(currentStatus)){
          updateMessageStatus(msgId, 'read');
        }
      }
    }
  }
}

/* ============================================================
   SENDING + SYNC
   ============================================================ */
async function sendMessage(){
  if(!running || !currentRoom) return;

  const text = (msgInput.value||"").trim();
  if(!text) return;

  const now = Date.now();
  const userId = session?.userId || localGuest.userId;
  const sender = (nameInput.value||"").trim() || session?.username || localGuest.name || "Anon";

  // Detect mentions in message
  const mentions = detectMentions(text);

  // attach rich metadata for provenance
  const ip = null; // IP tracking disabled
  const device = `${navigator.platform || 'unknown'} - ${navigator.userAgent.slice(0,50)}`;
  const sessionType = session?.userId ? 'registered' : (String(localGuest.userId||'').startsWith('g-') ? 'guest' : 'anon');

  const msg = {
    id: `m-${now}-${Math.random().toString(36).slice(2,8)}`,
    room: currentRoom,
    sender,
    userId,
    ts: now,
    text,
    edited:false,
    editedAt:null,
    deleted:false,
    createdAt: now,
    status: 'sending', // New status field
    replyTo: replyingTo ? {
      msgId: replyingTo.msgId,
      sender: replyingTo.sender,
      text: replyingTo.text,
      userId: replyingTo.userId
    } : null,
    mentions: mentions,
    meta: {
      sessionType,
      sessionUsername: session?.username || null,
      device,
      ip,
      ua: navigator.userAgent || null
    }
  };

  // OPTIMISTIC UI: Show message immediately with "sending" status
  addMessageToDom(msg);
  msgInput.value = "";
  cancelReplyTo(); // Clear reply after sending
  markInteraction("send");

  // Send to GitHub (wait for confirmation before marking as sent)
  try{
    log(` Sending message to GitHub...`, "INFO");
    
    // This will throw an error if the write fails
    const result = await appendMessageV3(currentRoom, msg);
    
    // Only mark as sent if GitHub confirmed the write
    if(result && result.cellSha){
      msg.status = 'sent';
      updateMessageStatus(msg.id, 'sent');
      log(` Message successfully written to GitHub (cell ${result.cellNum})`, "INFO");
      
      // Enter burst mode: check frequently for responses
      burstModeUntil = Date.now() + POLL_BURST_DURATION;
      if(running && currentRoom){
        clearTimeout(pollTimer);
        scheduleNextPoll(POLL_MS_BURST);
      }
      
      // Presence update
      await presenceSetOnline(true, "send");
      
      // Refresh presence list occasionally
      await maybeRefreshPresence();
      
      // After a brief moment, update to delivered
      setTimeout(() => {
        msg.status = 'delivered';
        updateMessageStatus(msg.id, 'delivered');
      }, 300); //  Ms rpido para mejor UX
    }else{
      throw new Error("GitHub write returned no SHA (write may have failed)");
    }
    
  }catch(e){
    console.error('[sendMessage ERROR]', e);
    msg.status = 'failed';
    updateMessageStatus(msg.id, 'failed');
    log(` Failed to write message to GitHub: ${e.message}`, "ERROR");
    showToast('Failed to send message to GitHub. Click retry to try again.', 'error', 6000);
  }
}

function updateMessageStatus(msgId, status){
  // Update in loadedMessages
  for(const m of loadedMessages){
    if(m.id === msgId){
      m.status = status;
      break;
    }
  }
  
  // Update DOM
  const el = messagesEl.querySelector(`[data-msg-id="${msgId}"]`);
  if(!el) return;
  
  const statusEl = el.querySelector('.msg-status');
  if(statusEl){
    statusEl.className = `msg-status status-${status}`;
  }
  
  // Handle failed state
  if(status === 'failed'){
    el.classList.add('msg-failed');
    // Add retry button if not exists
    if(!el.querySelector('.msg-retry')){
      const meta = el.querySelector('.meta');
      if(meta){
        const retry = document.createElement('button');
        retry.className = 'msg-retry';
        retry.textContent = 'Retry';
        const msg = loadedMessages.find(m => m.id === msgId);
        retry.onclick = (e) => { e.stopPropagation(); if(msg) retryMessage(msg); };
        meta.appendChild(retry);
      }
    }
  }else{
    el.classList.remove('msg-failed');
    const retry = el.querySelector('.msg-retry');
    if(retry) retry.remove();
  }
}

async function retryMessage(msg){
  if(!msg || !currentRoom) return;
  
  // Update status to sending
  updateMessageStatus(msg.id, 'sending');
  
  try{
    // For media messages: files are already uploaded, just need to save message metadata
    // Check if message already exists in the cell to avoid duplicates
    if(msg.cell){
      const cellNum = msg.cell;
      
      // Clear cached SHA to force fresh fetch
      const cellPathStr = cellPath(currentRoom, cellNum);
      clearCachedSha(cellPathStr);
      
      // Fetch current cell content
      const got = await ghGetJsonWithSha(cellPathStr);
      if(!got.ok || !Array.isArray(got.obj)){
        throw new Error(`Failed to fetch cell ${cellNum} for retry`);
      }
      
      const cellArr = got.obj;
      const existingIdx = cellArr.findIndex(m => m.id === msg.id);
      
      if(existingIdx >= 0){
        // Message already exists, just update it
        cellArr[existingIdx] = msg;
        console.log(`[retryMessage] Updating existing message in cell ${cellNum}`);
      }else{
        // Message doesn't exist yet, append it
        cellArr.push(msg);
        console.log(`[retryMessage] Appending message to cell ${cellNum}`);
      }
      
      // Write back with fresh SHA
      const put = await ghPutJson(cellPathStr, cellArr, got.sha, `retry msg cell ${cellNum}`);
      if(!put || !put.ok || !put.sha){
        throw new Error(`Failed to write message to cell ${cellNum} - no SHA returned`);
      }
      
      // Update room index if this was a new append
      if(existingIdx < 0){
        await loadRoomIndex(currentRoom);
        roomIndex.totalMessages = (roomIndex.totalMessages || 0) + 1;
        await saveRoomIndex(currentRoom);
        await saveMasterValue(currentRoom, true);
      }
    }else{
      // No cell assigned yet, use normal append
      await appendMessageV3(currentRoom, msg);
    }
    
    updateMessageStatus(msg.id, 'sent');
    showToast('Message sent successfully', 'success');
    
    setTimeout(() => {
      updateMessageStatus(msg.id, 'delivered');
    }, 500);
    
  }catch(e){
    console.error('[retryMessage ERROR]', e);
    updateMessageStatus(msg.id, 'failed');
    showToast('Retry failed. Please try again.', 'error');
  }
}

/* ============================================================
   MEDIA MESSAGE SENDING
   ============================================================ */
async function sendMediaMessage(files, captions = []){
  console.log('[sendMediaMessage] ENTRY', { filesCount: files?.length, captionsCount: captions?.length, running, currentRoom });
  
  if(!running || !currentRoom || !files || files.length === 0){
    console.warn('[sendMediaMessage] Validation failed - aborting', { running, currentRoom, filesLength: files?.length });
    return;
  }
  
  const now = Date.now();
  const userId = session?.userId || localGuest.userId;
  const sender = (nameInput.value||"").trim() || session?.username || localGuest.name || "Anon";
  
  const msgId = `m-${now}-${Math.random().toString(36).slice(2,8)}`;
  
  // Show upload progress
  mediaUploadProgress.style.display = 'block';
  mediaUploadProgressText.textContent = `Preparing ${files.length} file(s)...`;
  mediaUploadProgressFill.style.width = '0%';
  
  try{
    const attachments = [];
    let processedCount = 0;
    
    for(let i = 0; i < files.length; i++){
      const file = files[i];
      const mimeType = file.type || 'application/octet-stream';
      const caption = captions[i] || ''; // Get caption for this file
      
      console.log(`[sendMediaMessage] Processing file ${i+1}/${files.length}:`, {
        name: file.name,
        type: mimeType,
        size: file.size,
        caption: caption || '(no caption)'
      });
      
      // Update progress
      processedCount++;
      const progress = Math.floor((processedCount / (files.length * 2)) * 100);
      mediaUploadProgressText.textContent = `Processing ${file.name}...`;
      mediaUploadProgressFill.style.width = progress + '%';
      
      let kind = 'file';
      let attachment = {
        kind: 'file',
        fileName: file.name,
        mime: mimeType,
        size: file.size,
        caption: caption // Add caption to attachment
      };
      
      // Determine kind
      if(mimeType.startsWith('image/')){
        kind = 'image';
        attachment.kind = 'image';
        
        // Generate thumbnail
        try{
          console.log(`[sendMediaMessage] Generating thumbnail for ${file.name}...`);
          const thumb = await generateThumbnail(file, 480);
          attachment.width = thumb.width;
          attachment.height = thumb.height;
          console.log(`[sendMediaMessage]  Thumbnail generated: ${thumb.width}x${thumb.height}`);
          
          // Upload thumbnail
          console.log(`[sendMediaMessage] Uploading thumbnail...`);
          const thumbUpload = await uploadThumbnailToGitHub(thumb.blob, msgId, i);
          if(thumbUpload.ok){
            attachment.thumbPath = thumbUpload.path;
            attachment.thumbUrl = thumbUpload.url;
            console.log(`[sendMediaMessage]  Thumbnail uploaded: ${thumbUpload.path}`);
          }else{
            console.warn(`[sendMediaMessage]  Thumbnail upload failed`);
          }
        }catch(err){
          console.warn('[sendMediaMessage]  Thumbnail generation failed:', err);
        }
      }else if(mimeType.startsWith('video/')){
        kind = 'video';
        attachment.kind = 'video';
        
        // Generate poster
        try{
          console.log(`[sendMediaMessage] Generating video poster for ${file.name}...`);
          const poster = await generateVideoPoster(file);
          attachment.duration = poster.duration || 0;
          console.log(`[sendMediaMessage]  Poster generated, duration: ${poster.duration}s`);
          
          // Upload poster
          console.log(`[sendMediaMessage] Uploading poster...`);
          const posterBlob = poster.blob;
          const posterUpload = await uploadThumbnailToGitHub(posterBlob, msgId, i);
          if(posterUpload.ok){
            attachment.posterPath = posterUpload.path;
            attachment.posterUrl = posterUpload.url;
            console.log(`[sendMediaMessage]  Poster uploaded: ${posterUpload.path}`);
          }else{
            console.warn(`[sendMediaMessage]  Poster upload failed`);
          }
        }catch(err){
          console.warn('[sendMediaMessage]  Poster generation failed:', err);
        }
      }
      
      // Upload main file
      console.log(`[sendMediaMessage] Uploading main file: ${file.name}...`);
      mediaUploadProgressText.textContent = `Uploading ${file.name}...`;
      const upload = await uploadMediaToGitHub(file, msgId, kind);
      
      if(!upload.ok){
        console.error(`[sendMediaMessage]  Upload failed for ${file.name}:`, upload.error);
        throw new Error(`Failed to upload ${file.name}: ${upload.error}`);
      }
      
      console.log(`[sendMediaMessage]  File uploaded: ${upload.path}`);
      attachment.path = upload.path;
      attachment.url = upload.url;
      
      // Save chunking metadata if file was chunked
      if(upload.isChunked){
        attachment.isChunked = true;
        attachment.chunkCount = upload.chunkCount;
        attachment.totalSize = upload.totalSize;
        console.log(`[sendMediaMessage] File was chunked: ${upload.chunkCount} chunks, ${formatBytes(upload.totalSize)} total`);
      }
      
      attachments.push(attachment);
      console.log(`[sendMediaMessage]  Attachment ${i+1}/${files.length} complete`);
      
      // Update progress
      processedCount++;
      const finalProgress = Math.floor((processedCount / (files.length * 2)) * 100);
      mediaUploadProgressFill.style.width = finalProgress + '%';
    }
    
    // Create message
    const device = `${navigator.platform || 'unknown'} - ${navigator.userAgent.slice(0,50)}`;
    const sessionType = session?.userId ? 'registered' : (String(localGuest.userId||'').startsWith('g-') ? 'guest' : 'anon');
    
    // Combine all captions into message text (first non-empty caption)
    const messageText = captions.find(c => c && c.trim()) || '';
    
    const msg = {
      id: msgId,
      room: currentRoom,
      sender,
      userId,
      ts: now,
      text: messageText, // Use caption as message text
      type: 'media',
      attachments: attachments,
      edited: false,
      editedAt: null,
      deleted: false,
      createdAt: now,
      status: 'sending',
      replyTo: replyingTo ? {
        msgId: replyingTo.msgId,
        sender: replyingTo.sender,
        text: replyingTo.text,
        userId: replyingTo.userId
      } : null,
      mentions: [],
      meta: {
        sessionType,
        sessionUsername: session?.username || null,
        device,
        ip: null,
        ua: navigator.userAgent || null
      }
    };
    
    // Debug: Log message being sent
    console.log(' [sendMediaMessage] Creating message object:', {
      msgId: msg.id,
      type: msg.type,
      attachmentsCount: msg.attachments?.length || 0,
      text: msg.text || '(no caption)',
      room: currentRoom
    });
    console.log(' [sendMediaMessage] Attachments detail:', msg.attachments);
    
    // Show optimistically
    console.log('[sendMediaMessage] Adding message to DOM (optimistic UI)...');
    addMessageToDom(msg);
    cancelReplyTo();
    markInteraction('send');
    
    // Upload to GitHub
    console.log('[sendMediaMessage] Saving message metadata to GitHub...');
    mediaUploadProgressText.textContent = 'Saving message...';
    mediaUploadProgressFill.style.width = '95%';
    
    // Clear cell cache to ensure fresh SHA for message save
    if(roomIndex.latestCell){
      const cellPathStr = cellPath(currentRoom, roomIndex.latestCell);
      console.log(`[sendMediaMessage] Clearing cached SHA for ${cellPathStr}`);
      clearCachedSha(cellPathStr);
    }
    
    console.log('[sendMediaMessage] Calling appendMessageV3...');
    const result = await appendMessageV3(currentRoom, msg);
    console.log('[sendMediaMessage] appendMessageV3 returned:', result);
    
    if(result && result.cellSha){
      console.log(` [sendMediaMessage] SUCCESS! Message saved to cell ${result.cellNum}`);
      msg.status = 'sent';
      updateMessageStatus(msg.id, 'sent');
      log(` Media message sent (${attachments.length} attachment(s))`, 'INFO');
      
      mediaUploadProgressFill.style.width = '100%';
      setTimeout(() => {
        mediaUploadProgress.style.display = 'none';
      }, 1000);
      
      // Burst mode
      console.log('[sendMediaMessage] Entering burst mode for quick response polling');
      burstModeUntil = Date.now() + POLL_BURST_DURATION;
      if(running && currentRoom){
        clearTimeout(pollTimer);
        scheduleNextPoll(POLL_MS_BURST);
      }
      
      await presenceSetOnline(true, 'send');
      await maybeRefreshPresence();
      
      setTimeout(() => {
        msg.status = 'delivered';
        updateMessageStatus(msg.id, 'delivered');
        console.log(` [sendMediaMessage] Message marked as delivered`);
      }, 200); //  200ms para feedback instantneo
      
      console.log(` [sendMediaMessage] COMPLETE - Sent ${attachments.length} file(s)`);
      showToast(`Sent ${attachments.length} file(s)`, 'success');
    }else{
      console.error(' [sendMediaMessage] GitHub write returned no SHA');
      throw new Error('GitHub write returned no SHA');
    }
    
  }catch(error){
    console.error(' [sendMediaMessage] FAILED:', error);
    console.error(' [sendMediaMessage] Error stack:', error.stack);
    mediaUploadProgress.style.display = 'none';
    showToast(`Failed to send media: ${error.message}`, 'error', 5000);
  }
  
  console.log('[sendMediaMessage] EXIT');
}

async function syncLatestFromStorage(){
  // DEBOUNCING: Evitar mltiples syncs simultneos (mejora performance)
  if(syncDebounceTimer){
    console.log(' Sync ya programado, saltando...');
    return;
  }
  
  syncDebounceTimer = setTimeout(() => { syncDebounceTimer = null; }, 300);
  
  // Load newest messages - check last 3 cells to ensure completeness
  await loadRoomIndex(currentRoom);

  const latestCellNum = roomIndex.latestCell || 1;

  // If nothing loaded yet -> load latest
  if(loadedCellsMax === null){
    const msgs = await loadLatestMessages(currentRoom, 50);
    renderAll(msgs);
    
    // Scroll usando requestAnimationFrame para mejor performance
    requestAnimationFrame(() => {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
    
    updateReadBadges();
    return;
  }

  // OPTIMIZACIN: Solo verificar si hay cambios reales
  // Comparar loadedCellsMax con latestCellNum para detectar nuevas clulas
  const safeCheckFrom = Math.max(1, latestCellNum - 2); // Check last 3 cells
  const needToCheck = loadedCellsMax < safeCheckFrom;
  
  if(needToCheck){
    // User is significantly behind - load ALL missing cells
    log(` Loading missing cells ${loadedCellsMax+1} to ${latestCellNum}`, "INFO");
    const newMsgs = await loadCellsRange(currentRoom, loadedCellsMax+1, latestCellNum);
    loadedCellsMax = latestCellNum;
    
    // Filter out duplicates and add to DOM
    let addedCount = 0;
    const existingIds = new Set(loadedMessages.map(m => m.id));
    
    for(const m of newMsgs){
      if(existingIds.has(m.id)) continue;
      addMessageToDom(m, false);
      addedCount++;
    }
    
    if(addedCount > 0){
      log(` ${addedCount} new message(s) received (loaded cells)`, "INFO");
      setupReadObserver();
      
      // Scroll to bottom after adding new messages
      setTimeout(() => {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      }, 100);
    }
    
    // Update cell metadata after sync
    const totalCells1 = loadedCellsMax || (roomIndex?.latestCell || 0);
    const latestForMeta1 = roomIndex?.latestCell || totalCells1;
    const currentViewing1 = cellMetadata.currentViewingCell || latestForMeta1;
    updateCellMetadata(currentViewing1, totalCells1, latestForMeta1);
    
    // Detect visible cells after new messages load
    setTimeout(detectVisibleCells, 300);
    
    await maybeRefreshPresence();
    updateReadBadges();
    return;
  }

  // User is close to latest - check if there are new cells
  if(latestCellNum <= loadedCellsMax){
    // No new cells, but reload last 3 cells to ensure completeness
    // (in case messages were added to existing cells)
    const reloadFrom = Math.max(1, latestCellNum - 2);
    if(reloadFrom <= loadedCellsMax){
      log(` Verifying last 3 cells (${reloadFrom} to ${latestCellNum})`, "INFO");
      const msgs = await loadCellsRange(currentRoom, reloadFrom, latestCellNum);
      
      // Add any messages we don't have yet
      let addedCount = 0;
      const existingIds = new Set(loadedMessages.map(m => m.id));
      
      for(const m of msgs){
        if(existingIds.has(m.id)) continue;
        addMessageToDom(m, false);
        addedCount++;
      }
      
      if(addedCount > 0){
        log(` ${addedCount} message(s) found in verification`, "INFO");
        setupReadObserver();
      }
    }
    
    await maybeRefreshPresence();
    updateReadBadges();
    return;
  }

  // Load new cells from user's position to latest
  log(` Loading new cells ${loadedCellsMax+1} to ${latestCellNum}`, "INFO");
  const newMsgs = await loadCellsRange(currentRoom, loadedCellsMax+1, latestCellNum);
  loadedCellsMax = latestCellNum;

  // Filter out duplicates and add to DOM
  let addedCount = 0;
  const existingIds = new Set(loadedMessages.map(m => m.id));
  
  for(const m of newMsgs){
    // Skip if already in DOM
    if(existingIds.has(m.id)) continue;
    
    addMessageToDom(m, false); // false = auto-scroll
    addedCount++;
  }
  
  if(addedCount > 0){
    log(` ${addedCount} new message(s) received`, "INFO");
    setupReadObserver();
    
    // Check for new messages and mentions
    checkNewMessages(newMsgs);
    
    // Scroll to bottom after adding new messages
    setTimeout(() => {
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }, 100);
  }
  
  // Update cell metadata after sync
  const totalCells2 = loadedCellsMax || (roomIndex?.latestCell || 0);
  const latestForMeta2 = roomIndex?.latestCell || totalCells2;
  const currentViewing2 = cellMetadata.currentViewingCell || latestForMeta2;
  updateCellMetadata(currentViewing2, totalCells2, latestForMeta2);
  
  // Detect visible cells after new messages load
  setTimeout(detectVisibleCells, 300);
  
  await maybeRefreshPresence();
  updateReadBadges();
}

/* ============================================================
   LOCAL GUEST IDENTITY (used if not logged in)
   ============================================================ */
const localGuest = {
  userId: null,
  name: "Guest"
};

function initGuestIdentity(){
  try{
    const k="cp2p_guest_v1";
    const raw = localStorage.getItem(k);
    if(raw){
      const obj = JSON.parse(raw);
      if(obj?.userId){
        localGuest.userId = obj.userId;
        localGuest.name = obj.name || "Guest";
        return;
      }
    }
    const now = Date.now();
    const rand = Math.random().toString(36).slice(2,10);
    localGuest.userId = `g-${now}-${rand}`;
    localGuest.name = "Guest";
    localStorage.setItem(k, JSON.stringify(localGuest));
  }catch(_){
    localGuest.userId = `g-${Date.now()}-${Math.random().toString(36).slice(2,10)}`;
  }
}

/* ============================================================
   UI: AUTH MODAL + ROOM JOIN/LEAVE
   ============================================================ */
let authMode = "login"; // "login" | "register"

function openAuth(mode){
  authMode = mode;
  authModalTitle.textContent = mode === "login" ? "Login" : "Register";
  authActionBtn.textContent  = mode === "login" ? "Login" : "Register";
  authMsg.textContent = "";
  authModalBack.style.display = "flex";
  authUserInput.focus();
}

function closeAuth(){
  authModalBack.style.display = "none";
  authUserInput.value = "";
  authPassInput.value = "";
  authMsg.textContent = "";
}

loginBtn.onclick = ()=>openAuth("login");
registerBtn.onclick = ()=>openAuth("register");
logoutBtn.onclick = ()=>logout();
browseRoomsBtn.onclick = ()=>openRoomBrowser();

authCloseBtn.onclick = closeAuth;
authModalBack.addEventListener("click", (e)=>{ if(e.target===authModalBack) closeAuth(); });

authActionBtn.onclick = async ()=>{
  try{
    authMsg.style.color = "var(--muted)";
    authMsg.textContent = "Working";
    const u = authUserInput.value.trim();
    const p = authPassInput.value;

    if(authMode==="register"){
      await registerUser(u, p);
      authMsg.style.color = "rgba(34,197,94,.95)";
      authMsg.textContent = "Registered ";
      closeAuth();
    }else{
      await loginUser(u, p);
      authMsg.style.color = "rgba(34,197,94,.95)";
      authMsg.textContent = "Logged in ";
      closeAuth();
    }

    // If inside room, presence file path changes from guest->user. Write online once.
    if(running && currentRoom){
      await presenceSetOnline(true, "auth");
      await refreshPresence();
    }
  }catch(e){
    authMsg.style.color = "rgba(239,68,68,.95)";
    authMsg.textContent = String(e?.message || e);
  }
};

joinBtn.onclick = async ()=>{
  try{
    const r = roomInput.value.trim();
    if(!r){ log("Room required.","WARN"); return; }

    const displayName = nameInput.value.trim() || session?.username || "Anon";
    if(!nameInput.value.trim()) nameInput.value = displayName;

    currentRoom = r;
    running = true;

    // Save last joined room for logged-in users
    if(session && session.userId){
      saveLastJoinedRoom(r);
    }

    // Ensure storage (V3) + master file
    setNet("ok","joining");
    await ensureRoomV3(currentRoom);

    // UI
    chatPanel.style.display = "flex";
    syncBtn.style.display = "inline-block";
    roomTitle.textContent = `#${currentRoom}`;
    roomSubText.textContent = `V3 Storage`;
    
    // Load cell metadata from cache
    loadCellMetadataFromCache();
    
    // Load last read timestamp for unread counter
    loadLastReadTimestamp();

    // Presence: join => online=true
    presenceState.inRoom = true;
    await presenceSetOnline(true, "join");

    // Load latest
    const msgs = await loadLatestMessages(currentRoom, 50);
    renderAll(msgs);

    // Lazy load + observers
    installLazyLoader();
    setupReadObserver();
    
    // Start live cell detection
    startCellDetection();
    
    // Update cell metadata with initial state
    const totalCells = loadedCellsMax || roomIndex?.latestCell || 0;
    const latestCell = roomIndex?.latestCell || totalCells;
    updateCellMetadata(latestCell, totalCells, latestCell);

    // Kick poll loop
    clearTimeout(pollTimer);
    scheduleNextPoll(50);

    // Pull presence list
    await refreshPresence();

    // Reset behavior tracking for new room
    resetBehaviorTracking();
    log(` Behavior tracking initialized`, "INFO");

    log(` Joined "${currentRoom}" as ${displayName}.`, "INFO");
  }catch(e){
    console.error("[Join ERROR]", e);
    setNet("bad","join error");
    log("Join failed. Check token / permissions / network.","ERROR");
  }
};

leaveBtn.onclick = async ()=>{
  try{
    if(!running) return;

    // Show final engagement summary before leaving
    const finalEngagement = getEngagementScore();
    log(` Final Engagement: ${finalEngagement.sentiment} (${finalEngagement.score.toFixed(1)})`, "INFO");
    showToast(`Session ended: ${finalEngagement.sentiment} engagement`, 'info');

    // Presence offline once
    await presenceSetOnline(false, "leave");
    presenceState.inRoom = false;

    running = false;
    currentRoom = null;
    clearTimeout(pollTimer);
    pollTimer = null;

    if(presenceState.heartbeatTimer){
      clearInterval(presenceState.heartbeatTimer);
      presenceState.heartbeatTimer = null;
    }

    chatPanel.style.display = "none";
    syncBtn.style.display = "none";
    clearView();
    
    // Reset behavior tracking
    resetBehaviorTracking();
    
    log("Left room.","INFO");
  }catch(e){
    console.error("[Leave ERROR]", e);
  }
};

syncBtn.onclick = async ()=>{
  if(!running || !currentRoom){
    showToast('Not in a room', 'warning');
    return;
  }
  try{
    syncBtn.disabled = true;
    syncBtn.textContent = ' Syncing...';
    
    // Use the unified refresh function
    await triggerManualRefresh("sync-button");
    
  }catch(e){
    console.error('[Manual Sync ERROR]', e);
    showToast('Sync failed: ' + e.message, 'error');
  }finally{
    syncBtn.disabled = false;
    syncBtn.textContent = ' Check Messages';
  }
};

/* ============================================================
   AUDIO RECORDING WITH GITHUB STORAGE
   ============================================================ */
let mediaRecorder = null;
let audioChunks = [];
let audioStream = null;
let recordingStartTime = 0;
let recordingInterval = null;
let audioPaused = false;
let pausedDuration = 0;
let lastPauseTime = 0;
let visualizerInterval = null;
let audioContext = null;
let analyser = null;
let dataArray = null;
let bufferLength = 0;
let recordedBlob = null;
let isRecordingLocked = false;
let recordingStartPos = { x: 0, y: 0 };
let isMobileGestureRecording = false;
let animationFrameId = null;

// Initialize visualizer bars
function initVisualizer(){
  audioVisualizer.innerHTML = '';
  const barCount = 40;
  for(let i = 0; i < barCount; i++){
    const bar = document.createElement('div');
    bar.className = 'audio-bar';
    bar.style.height = '4px';
    audioVisualizer.appendChild(bar);
  }
}

// Update visualizer with real audio data
function updateVisualizer(){
  if(!analyser || audioPaused) return;
  
  // Get frequency data
  analyser.getByteFrequencyData(dataArray);
  
  const bars = audioVisualizer.querySelectorAll('.audio-bar');
  const barCount = bars.length;
  
  // Calculate how many data points per bar
  const step = Math.floor(bufferLength / barCount);
  
  bars.forEach((bar, index) => {
    // Get average amplitude for this bar's range
    let sum = 0;
    const start = index * step;
    const end = start + step;
    
    for(let i = start; i < end && i < bufferLength; i++){
      sum += dataArray[i];
    }
    
    const average = sum / step;
    
    // Normalize to 0-1 range (dataArray values are 0-255)
    const normalized = average / 255;
    
    // Map to height (minimum 4px, maximum 70px)
    const height = 4 + (normalized * 66);
    bar.style.height = height + 'px';
  });
  
  // Continue animation
  animationFrameId = requestAnimationFrame(updateVisualizer);
}

// Stop visualizer animation
function stopVisualizerAnimation(){
  if(animationFrameId){
    cancelAnimationFrame(animationFrameId);
    animationFrameId = null;
  }
  const bars = audioVisualizer.querySelectorAll('.audio-bar');
  bars.forEach(bar => bar.style.height = '4px');
}

// Update recording timer
function updateTimer(){
  if(audioPaused) return;
  const elapsed = Date.now() - recordingStartTime - pausedDuration;
  const seconds = Math.floor(elapsed / 1000);
  const minutes = Math.floor(seconds / 60);
  const secs = seconds % 60;
  audioTimer.textContent = `${minutes}:${secs.toString().padStart(2, '0')}`;
}

// Upload audio file to GitHub
// isRecorded: true for recorded audio, false for uploaded audio files
async function uploadAudioToGitHub(blob, messageId, roomName, isRecorded = true){
  try{
    const userId = session?.userId || localGuest.userId || 'anon';
    const timestamp = Date.now();
    
    // Determine file extension from blob type
    let ext = 'webm';
    if(blob.type.includes('mp3')) ext = 'mp3';
    else if(blob.type.includes('mp4')) ext = 'mp4';
    else if(blob.type.includes('ogg')) ext = 'ogg';
    else if(blob.type.includes('wav')) ext = 'wav';
    
    // Organize by type: recorded-audios vs media-audios
    const folderType = isRecorded ? 'recorded-audios' : 'media-audios';
    
    // File naming: user_timestamp_msgid.ext
    const fileName = `${userId}_${timestamp}_${messageId}.${ext}`;
    const audioPath = `${ROOMS_META_DIR}/${roomName}/${folderType}/${fileName}`;
    
    // Convert blob to base64
    const reader = new FileReader();
    const base64Promise = new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result.split(',')[1]);
      reader.onerror = reject;
    });
    reader.readAsDataURL(blob);
    const base64Content = await base64Promise;
    
    // Upload to GitHub
    const commitMsg = isRecorded 
      ? `Upload recorded audio from ${userId}` 
      : `Upload media audio from ${userId}`;
    const result = await ghPutFile(audioPath, base64Content, null, commitMsg);
    
    if(result.ok){
      log(` Audio uploaded to GitHub: ${audioPath}`, 'INFO');
      return { 
        ok: true, 
        path: audioPath, 
        url: result.url,
        fileName: fileName,
        folderType: folderType
      };
    }else{
      throw new Error(`Upload failed with status ${result.status}`);
    }
  }catch(error){
    console.error('Error uploading audio:', error);
    return { ok: false, error: error.message };
  }
}

// Download audio from GitHub
async function downloadAudioFromGitHub(audioPath){
  try{
    const response = await rawGetBinary(audioPath);
    if(response.ok){
      return response.blob;
    }else{
      throw new Error(`Download failed with status ${response.status}`);
    }
  }catch(error){
    console.error('Error downloading audio:', error);
    return null;
  }
}

// Get cached audio or download if not cached
async function getCachedAudio(audioPath){
  //  PASO 1: Verificar IndexedDB primero (persistente)
  const dbAudio = await getMediaFromDB(audioPath);
  if(dbAudio && dbAudio.blob){
    const blobUrl = URL.createObjectURL(dbAudio.blob);
    const cacheEntry = {
      blob: dbAudio.blob,
      blobUrl,
      size: dbAudio.size,
      cachedAt: dbAudio.cachedAt
    };
    audioCache.set(audioPath, cacheEntry);
    log(` Using persistent audio: ${audioPath}`, 'INFO');
    return cacheEntry;
  }
  
  // PASO 2: Verificar cache RAM
  const cached = audioCache.get(audioPath);
  if(cached){
    const age = Date.now() - cached.cachedAt;
    if(age < AUDIO_CACHE_MAX_AGE){
      log(` Using cached audio: ${audioPath}`, 'INFO');
      return cached;
    }else{
      // Cache expired, clean up
      if(cached.blobUrl) URL.revokeObjectURL(cached.blobUrl);
      audioCache.delete(audioPath);
    }
  }
  
  // PASO 3: Descargar audio
  log(` Downloading audio: ${audioPath}`, 'INFO');
  const blob = await downloadAudioFromGitHub(audioPath);
  if(!blob) return null;
  
  // Create blob URL and cache
  const blobUrl = URL.createObjectURL(blob);
  const cacheEntry = {
    blob,
    blobUrl,
    size: blob.size,
    cachedAt: Date.now()
  };
  audioCache.set(audioPath, cacheEntry);
  
  //  PASO 4: Guardar en IndexedDB
  await saveMediaToDB(audioPath, blob, 'audio');
  
  log(` Audio cached: ${audioPath} (${formatBytes(blob.size)})`, 'INFO');
  return cacheEntry;
}

// Format bytes to human readable size
function formatBytes(bytes, decimals = 2){
  if(bytes === 0) return '0 B';
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['B', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

// Format duration in seconds to MM:SS
function formatDuration(seconds){
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/* ============================================================
   MEDIA HELPER FUNCTIONS
   ============================================================ */

// Generate thumbnail from image file using canvas
async function generateThumbnail(file, maxWidth = 480){
  return new Promise((resolve, reject) => {
    const img = new Image();
    const url = URL.createObjectURL(file);
    
    img.onload = () => {
      try{
        // Calculate dimensions
        let width = img.width;
        let height = img.height;
        
        if(width > maxWidth){
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Create canvas
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        
        // Convert to blob (JPEG for smaller size)
        canvas.toBlob((blob) => {
          URL.revokeObjectURL(url);
          if(blob){
            resolve({
              blob,
              width,
              height,
              dataUrl: canvas.toDataURL('image/jpeg', 0.8)
            });
          }else{
            reject(new Error('Failed to generate thumbnail'));
          }
        }, 'image/jpeg', 0.8);
      }catch(err){
        URL.revokeObjectURL(url);
        reject(err);
      }
    };
    
    img.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load image'));
    };
    
    img.src = url;
  });
}

// Generate video poster (first frame) from video file
async function generateVideoPoster(file){
  return new Promise((resolve, reject) => {
    const video = document.createElement('video');
    video.preload = 'metadata';
    video.muted = true;
    
    const url = URL.createObjectURL(file);
    
    video.onloadedmetadata = () => {
      // Seek to 1 second or 10% of duration
      const seekTime = Math.min(1, video.duration * 0.1);
      video.currentTime = seekTime;
    };
    
    video.onseeked = () => {
      try{
        const canvas = document.createElement('canvas');
        canvas.width = Math.min(video.videoWidth, 640);
        canvas.height = (canvas.width / video.videoWidth) * video.videoHeight;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        
        canvas.toBlob((blob) => {
          URL.revokeObjectURL(url);
          if(blob){
            resolve({
              blob,
              width: canvas.width,
              height: canvas.height,
              dataUrl: canvas.toDataURL('image/jpeg', 0.7),
              duration: video.duration
            });
          }else{
            reject(new Error('Failed to generate poster'));
          }
        }, 'image/jpeg', 0.7);
      }catch(err){
        URL.revokeObjectURL(url);
        reject(err);
      }
    };
    
    video.onerror = () => {
      URL.revokeObjectURL(url);
      reject(new Error('Failed to load video'));
    };
    
    video.src = url;
  });
}

// Get file icon emoji by MIME type
function getFileIcon(mimeType){
  if(!mimeType) return '';
  
  if(mimeType.startsWith('image/')) return '';
  if(mimeType.startsWith('video/')) return '';
  if(mimeType.startsWith('audio/')) return '';
  
  if(mimeType.includes('pdf')) return '';
  if(mimeType.includes('word') || mimeType.includes('document')) return '';
  if(mimeType.includes('excel') || mimeType.includes('spreadsheet')) return '';
  if(mimeType.includes('powerpoint') || mimeType.includes('presentation')) return '';
  if(mimeType.includes('zip') || mimeType.includes('rar') || mimeType.includes('7z')) return '';
  if(mimeType.includes('text')) return '';
  
  return '';
}

/* ============================================================
   CHUNKED FILE UPLOAD/DOWNLOAD SYSTEM
   For files >800KB, split into chunks to bypass GitHub API limits
   ============================================================ */

const CHUNK_SIZE = 800 * 1024; // 800KB chunks (safe under 1MB GitHub limit)

// Split file into chunks
function splitFileIntoChunks(file){
  const chunks = [];
  const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
  
  for(let i = 0; i < totalChunks; i++){
    const start = i * CHUNK_SIZE;
    const end = Math.min(start + CHUNK_SIZE, file.size);
    const chunk = file.slice(start, end);
    chunks.push(chunk);
  }
  
  return chunks;
}

// Upload file as chunks
async function uploadFileAsChunks(file, messageId, kind){
  const userId = session?.userId || localGuest.userId || 'anon';
  const timestamp = Date.now();
  const roomName = currentRoom;
  const chunks = splitFileIntoChunks(file);
  const totalChunks = chunks.length;
  
  console.log(` [Chunks] Splitting file into ${totalChunks} chunks (${formatBytes(file.size)} total)`);
  
  let folderType = 'media-files';
  if(kind === 'image') folderType = 'media-images';
  else if(kind === 'video') folderType = 'media-videos';
  
  const ext = file.name.split('.').pop() || 'bin';
  const baseFileName = `${userId}_${timestamp}_${messageId}`;
  
  // Upload each chunk
  for(let i = 0; i < totalChunks; i++){
    const chunk = chunks[i];
    const chunkFileName = `${baseFileName}.chunk${i}.${ext}`;
    const chunkPath = `${ROOMS_META_DIR}/${roomName}/${folderType}/${chunkFileName}`;
    
    console.log(` [Chunks] Uploading chunk ${i+1}/${totalChunks} (${formatBytes(chunk.size)})...`);
    
    // Convert chunk to base64
    const reader = new FileReader();
    const base64Promise = new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result.split(',')[1]);
      reader.onerror = reject;
    });
    reader.readAsDataURL(chunk);
    const base64Content = await base64Promise;
    
    const result = await ghPutFile(chunkPath, base64Content, null, `Upload chunk ${i+1}/${totalChunks}`);
    if(!result.ok){
      throw new Error(`Failed to upload chunk ${i+1}/${totalChunks}`);
    }
    
    console.log(` [Chunks] Chunk ${i+1}/${totalChunks} uploaded`);
  }
  
  // Return metadata for chunked file
  const mainPath = `${ROOMS_META_DIR}/${roomName}/${folderType}/${baseFileName}.${ext}`;
  return {
    ok: true,
    path: mainPath,
    fileName: `${baseFileName}.${ext}`,
    folderType: folderType,
    isChunked: true,
    chunkCount: totalChunks,
    totalSize: file.size
  };
}

// Download and reconstruct chunked file
async function downloadChunkedFile(basePath, chunkCount){
  try{
    console.log(` [Chunks] Downloading ${chunkCount} chunks for ${basePath}...`);
    
    const chunks = [];
    const ext = basePath.split('.').pop();
    const basePathWithoutExt = basePath.substring(0, basePath.lastIndexOf('.'));
    
    // Download all chunks
    for(let i = 0; i < chunkCount; i++){
      const chunkPath = `${basePathWithoutExt}.chunk${i}.${ext}`;
      console.log(` [Chunks] Downloading chunk ${i+1}/${chunkCount}...`);
      
      const response = await rawGetBinary(chunkPath);
      if(!response.ok){
        throw new Error(`Failed to download chunk ${i+1}/${chunkCount}`);
      }
      
      chunks.push(response.blob);
      console.log(` [Chunks] Chunk ${i+1}/${chunkCount} downloaded (${formatBytes(response.blob.size)})`);
    }
    
    // Reconstruct file from chunks
    console.log(` [Chunks] Reconstructing file from ${chunkCount} chunks...`);
    const completeBlob = new Blob(chunks);
    console.log(` [Chunks] File reconstructed: ${formatBytes(completeBlob.size)}`);
    
    return {
      ok: true,
      blob: completeBlob,
      size: completeBlob.size
    };
  }catch(error){
    console.error('[Chunks] Error downloading chunked file:', error);
    return { ok: false, error: error.message };
  }
}

// Upload media file to GitHub with proper folder structure
async function uploadMediaToGitHub(file, messageId, kind){
  try{
    const userId = session?.userId || localGuest.userId || 'anon';
    const timestamp = Date.now();
    const roomName = currentRoom;
    
    // Check if file is large enough to need chunking
    if(file.size > CHUNK_SIZE){
      console.log(` [Upload] File is large (${formatBytes(file.size)}), using chunked upload...`);
      return await uploadFileAsChunks(file, messageId, kind);
    }
    
    // Standard upload for small files
    console.log(` [Upload] File is small (${formatBytes(file.size)}), using standard upload...`);
    
    // Determine file extension
    let ext = file.name.split('.').pop() || 'bin';
    
    // Organize by type: media-images, media-videos, media-files
    let folderType = 'media-files';
    if(kind === 'image') folderType = 'media-images';
    else if(kind === 'video') folderType = 'media-videos';
    
    // File naming: user_timestamp_msgid_index.ext
    const fileName = `${userId}_${timestamp}_${messageId}.${ext}`;
    const mediaPath = `${ROOMS_META_DIR}/${roomName}/${folderType}/${fileName}`;
    
    // Convert file to base64
    const reader = new FileReader();
    const base64Promise = new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result.split(',')[1]);
      reader.onerror = reject;
    });
    reader.readAsDataURL(file);
    const base64Content = await base64Promise;
    
    // Upload to GitHub
    const commitMsg = `Upload ${kind} from ${userId}`;
    const result = await ghPutFile(mediaPath, base64Content, null, commitMsg);
    
    if(result.ok){
      log(` ${kind} uploaded: ${mediaPath}`, 'INFO');
      return {
        ok: true,
        path: mediaPath,
        url: result.url,
        fileName: fileName,
        folderType: folderType,
        isChunked: false
      };
    }else{
      throw new Error(`Upload failed with status ${result.status}`);
    }
  }catch(error){
    console.error('Error uploading media:', error);
    return { ok: false, error: error.message };
  }
}

// Upload thumbnail to GitHub
async function uploadThumbnailToGitHub(thumbBlob, messageId, index){
  try{
    const userId = session?.userId || localGuest.userId || 'anon';
    const timestamp = Date.now();
    const roomName = currentRoom;
    
    const fileName = `${userId}_${timestamp}_${messageId}_${index}_thumb.jpg`;
    const thumbPath = `${ROOMS_META_DIR}/${roomName}/media-thumbs/${fileName}`;
    
    // Convert blob to base64
    const reader = new FileReader();
    const base64Promise = new Promise((resolve, reject) => {
      reader.onloadend = () => resolve(reader.result.split(',')[1]);
      reader.onerror = reject;
    });
    reader.readAsDataURL(thumbBlob);
    const base64Content = await base64Promise;
    
    const result = await ghPutFile(thumbPath, base64Content, null, `Upload thumbnail`);
    
    if(result.ok){
      return { ok: true, path: thumbPath, url: result.url };
    }else{
      throw new Error(`Thumbnail upload failed`);
    }
  }catch(error){
    console.error('Error uploading thumbnail:', error);
    return { ok: false, error: error.message };
  }
}

// Download media from GitHub with caching
async function downloadMediaFromGitHub(mediaPath, type = 'image', isChunked = false, chunkCount = 0){
  try{
    //  PASO 1: Verificar IndexedDB primero (persistente)
    const dbMedia = await getMediaFromDB(mediaPath);
    if(dbMedia && dbMedia.blob){
      // Crear nuevo blobUrl del blob almacenado
      const blobUrl = URL.createObjectURL(dbMedia.blob);
      const cacheEntry = {
        blob: dbMedia.blob,
        blobUrl,
        size: dbMedia.size,
        type: dbMedia.type || type,
        cachedAt: dbMedia.cachedAt
      };
      // Agregar a memoria RAM para acceso rpido
      mediaCache.set(mediaPath, cacheEntry);
      log(` Using persistent media: ${mediaPath}`, 'INFO');
      return cacheEntry;
    }
    
    // PASO 2: Verificar cache RAM (temporal)
    const cached = mediaCache.get(mediaPath);
    if(cached){
      const age = Date.now() - cached.cachedAt;
      if(age < MEDIA_CACHE_MAX_AGE){
        log(` Using cached media: ${mediaPath}`, 'INFO');
        return cached;
      }else{
        // Cache expired, clean up
        if(cached.blobUrl) URL.revokeObjectURL(cached.blobUrl);
        mediaCache.delete(mediaPath);
      }
    }
    
    // PASO 3: Descargar media
    let blob;
    
    if(isChunked && chunkCount > 0){
      // Download chunked file
      log(` Downloading chunked media: ${mediaPath} (${chunkCount} chunks)`, 'INFO');
      const response = await downloadChunkedFile(mediaPath, chunkCount);
      if(!response.ok) throw new Error('Chunked download failed');
      blob = response.blob;
    }else{
      // Standard download
      log(` Downloading media: ${mediaPath}`, 'INFO');
      const response = await rawGetBinary(mediaPath);
      if(!response.ok) throw new Error('Download failed');
      blob = response.blob;
    }
    
    const blobUrl = URL.createObjectURL(blob);
    
    const cacheEntry = {
      blob,
      blobUrl,
      size: blob.size,
      type,
      cachedAt: Date.now()
    };
    mediaCache.set(mediaPath, cacheEntry);
    
    //  PASO 4: Guardar en IndexedDB para persistencia
    await saveMediaToDB(mediaPath, blob, type);
    
    log(` Media cached: ${mediaPath} (${formatBytes(blob.size)})`, 'INFO');
    return cacheEntry;
  }catch(error){
    console.error('Error downloading media:', error);
    return null;
  }
}

// Helper to get binary from GitHub raw (with API fallback for fresh files)
async function rawGetBinary(path){
  try{
    // Try Raw CDN first (faster, better for old files)
    const rawUrl = `https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/${path}`;
    const rawResponse = await fetch(rawUrl);
    if(rawResponse.ok){
      const blob = await rawResponse.blob();
      return { ok: true, blob, status: rawResponse.status, source: 'raw-cdn' };
    }
    
    // If Raw CDN returns 404, might be fresh file not propagated yet
    if(rawResponse.status === 404){
      console.warn(` Raw CDN 404 for ${path}, trying API fallback...`);
      
      // Try API for small files (<1MB, API limit)
      const apiUrl = `https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/contents/${path}`;
      const apiResponse = await fetch(apiUrl, {
        headers: { 'Authorization': `token ${GH_TOKEN}` }
      });
      
      if(apiResponse.ok){
        const json = await apiResponse.json();
        
        // Check file size (API only supports <1MB)
        if(json.size && json.size > 1000000){
          console.warn(` File too large for API (${formatBytes(json.size)}), waiting for CDN...`);
          showToast(`Video is uploading to CDN... Please wait a moment and try again.`, 'info', 5000);
          return { ok: false, status: 404, error: 'File too large for API, CDN not ready' };
        }
        
        if(json.content && json.encoding === 'base64'){
          // Decode base64 to blob
          const binaryString = atob(json.content.replace(/\s/g, ''));
          const bytes = new Uint8Array(binaryString.length);
          for(let i = 0; i < binaryString.length; i++){
            bytes[i] = binaryString.charCodeAt(i);
          }
          const blob = new Blob([bytes]);
          console.log(` Retrieved ${path} from API (${formatBytes(blob.size)}, bypassed CDN delay)`);
          return { ok: true, blob, status: 200, source: 'api' };
        }
      }
    }
    
    return { ok: false, status: rawResponse.status };
  }catch(error){
    return { ok: false, error: error.message };
  }
}

/* ============================================================
   IMAGE VIEWER & GALLERY
   ============================================================ */

// Open full-screen image viewer
async function openImageViewer(images, startIndex = 0, messageId = null){
  if(!images || images.length === 0) return;
  
  currentViewerImages = images;
  currentViewerIndex = startIndex;
  currentViewerMessageId = messageId;
  
  imageViewer.classList.add('active');
  document.body.style.overflow = 'hidden';
  
  await showViewerImage(currentViewerIndex);
  updateViewerControls();
}

// Show image at specific index
async function showViewerImage(index){
  if(!currentViewerImages || index < 0 || index >= currentViewerImages.length) return;
  
  const img = currentViewerImages[index];
  imageViewerImg.src = '';
  imageViewerImg.alt = 'Loading...';
  
  // Download full image
  const cached = await downloadMediaFromGitHub(
    img.path,
    'image',
    img.isChunked || false,
    img.chunkCount || 0
  );
  if(cached){
    imageViewerImg.src = cached.blobUrl;
    imageViewerImg.alt = img.fileName || 'Image';
  }else{
    imageViewerImg.alt = 'Failed to load image';
  }
}

// Update viewer controls (counter, navigation buttons)
function updateViewerControls(){
  imageViewerCounter.textContent = `${currentViewerIndex + 1} / ${currentViewerImages.length}`;
  
  // Show/hide navigation buttons
  if(currentViewerImages.length <= 1){
    imageViewerPrev.style.display = 'none';
    imageViewerNext.style.display = 'none';
  }else{
    imageViewerPrev.style.display = 'flex';
    imageViewerNext.style.display = 'flex';
    imageViewerPrev.disabled = currentViewerIndex === 0;
    imageViewerNext.disabled = currentViewerIndex === currentViewerImages.length - 1;
  }
}

// Navigate viewer
async function viewerPrev(){
  if(currentViewerIndex > 0){
    currentViewerIndex--;
    await showViewerImage(currentViewerIndex);
    updateViewerControls();
  }
}

async function viewerNext(){
  if(currentViewerIndex < currentViewerImages.length - 1){
    currentViewerIndex++;
    await showViewerImage(currentViewerIndex);
    updateViewerControls();
  }
}

// Close viewer
function closeImageViewer(){
  imageViewer.classList.remove('active');
  document.body.style.overflow = '';
  currentViewerImages = [];
  currentViewerIndex = 0;
  currentViewerMessageId = null;
  imageViewerImg.src = '';
}

// Download current image
async function downloadCurrentImage(){
  if(!currentViewerImages || currentViewerIndex < 0) return;
  
  const img = currentViewerImages[currentViewerIndex];
  const cached = await downloadMediaFromGitHub(
    img.path,
    'image',
    img.isChunked || false,
    img.chunkCount || 0
  );
  
  if(cached){
    const a = document.createElement('a');
    a.href = cached.blobUrl;
    a.download = img.fileName || 'image.jpg';
    a.click();
    showToast('Download started', 'success');
  }else{
    showToast('Failed to download image', 'error');
  }
}

// Open gallery drawer (vertical list of all images)
async function openGalleryDrawer(images, messageId = null){
  if(!images || images.length === 0) return;
  
  galleryDrawerTitle.textContent = `All Images (${images.length})`;
  galleryDrawerContent.innerHTML = '';
  
  for(let i = 0; i < images.length; i++){
    const img = images[i];
    
    const item = document.createElement('div');
    item.className = 'gallery-item';
    item.dataset.index = i;
    
    const thumb = document.createElement('div');
    thumb.className = 'gallery-item-thumb';
    
    const thumbImg = document.createElement('img');
    thumbImg.alt = img.fileName || 'Image';
    
    // Load thumbnail
    if(img.thumbPath){
      downloadMediaFromGitHub(img.thumbPath, 'image', false, 0).then(cached => {
        if(cached) thumbImg.src = cached.blobUrl;
      });
    }else if(img.path){
      downloadMediaFromGitHub(img.path, 'image', img.isChunked || false, img.chunkCount || 0).then(cached => {
        if(cached) thumbImg.src = cached.blobUrl;
      });
    }
    
    thumb.appendChild(thumbImg);
    
    const info = document.createElement('div');
    info.className = 'gallery-item-info';
    
    const name = document.createElement('div');
    name.className = 'gallery-item-name';
    name.textContent = img.fileName || 'Image';
    
    const size = document.createElement('div');
    size.className = 'gallery-item-size';
    size.textContent = formatBytes(img.size || 0);
    
    info.appendChild(name);
    info.appendChild(size);
    
    const downloadBtn = document.createElement('button');
    downloadBtn.className = 'gallery-item-download';
    downloadBtn.textContent = ' Download';
    downloadBtn.onclick = async (e) => {
      e.stopPropagation();
      downloadBtn.disabled = true;
      downloadBtn.textContent = '';
      
      try{
        const cached = await downloadMediaFromGitHub(
          img.path,
          'image',
          img.isChunked || false,
          img.chunkCount || 0
        );
        if(cached){
          const a = document.createElement('a');
          a.href = cached.blobUrl;
          a.download = img.fileName || 'image.jpg';
          a.click();
          downloadBtn.textContent = '';
          setTimeout(() => {
            downloadBtn.textContent = ' Download';
            downloadBtn.disabled = false;
          }, 2000);
        }else{
          throw new Error('Download failed');
        }
      }catch(err){
        downloadBtn.textContent = '';
        setTimeout(() => {
          downloadBtn.textContent = ' Download';
          downloadBtn.disabled = false;
        }, 2000);
      }
    };
    
    // Click item (not download button) -> open viewer
    item.onclick = (e) => {
      if(e.target === downloadBtn || downloadBtn.contains(e.target)) return;
      closeGalleryDrawer();
      openImageViewer(images, i, messageId);
    };
    
    item.appendChild(thumb);
    item.appendChild(info);
    item.appendChild(downloadBtn);
    
    galleryDrawerContent.appendChild(item);
  }
  
  galleryDrawer.classList.add('active');
  document.body.style.overflow = 'hidden';
}

// Close gallery drawer
function closeGalleryDrawer(){
  galleryDrawer.classList.remove('active');
  document.body.style.overflow = '';
  galleryDrawerContent.innerHTML = '';
}

/* ============================================================
   MEDIA PREVIEW MODAL (WhatsApp-style)
   ============================================================ */

let pendingMediaFiles = [];

// Show media preview modal with files
async function showMediaPreviewModal(files){
  console.log('[showMediaPreviewModal] Opening modal with', files.length, 'files');
  pendingMediaFiles = files;
  const previewModal = document.getElementById('mediaPreviewModal');
  const previewContent = document.getElementById('mediaPreviewContent');
  const previewCounter = document.getElementById('mediaPreviewCounter');
  
  // Clear previous content
  previewContent.innerHTML = '';
  
  // Update counter
  const imageCount = files.filter(f => f.type.startsWith('image/')).length;
  const videoCount = files.filter(f => f.type.startsWith('video/')).length;
  const fileCount = files.length - imageCount - videoCount;
  
  let counterText = [];
  if(imageCount > 0) counterText.push(`${imageCount} image${imageCount > 1 ? 's' : ''}`);
  if(videoCount > 0) counterText.push(`${videoCount} video${videoCount > 1 ? 's' : ''}`);
  if(fileCount > 0) counterText.push(`${fileCount} file${fileCount > 1 ? 's' : ''}`);
  
  previewCounter.textContent = counterText.join(', ');
  
  // Create preview items for each file
  for(let i = 0; i < files.length; i++){
    const file = files[i];
    const item = document.createElement('div');
    item.className = 'media-preview-item';
    item.dataset.index = i;
    
    const mimeType = file.type || '';
    
    if(mimeType.startsWith('image/')){
      // Image preview
      const container = document.createElement('div');
      container.className = 'media-preview-image-container';
      
      const img = document.createElement('img');
      img.alt = file.name;
      
      // Create blob URL for preview
      const blobUrl = URL.createObjectURL(file);
      img.src = blobUrl;
      img.onload = () => URL.revokeObjectURL(blobUrl);
      
      container.appendChild(img);
      item.appendChild(container);
      
    }else if(mimeType.startsWith('video/')){
      // Video preview
      const container = document.createElement('div');
      container.className = 'media-preview-video-container';
      
      const video = document.createElement('video');
      video.controls = true;
      video.preload = 'metadata';
      
      const blobUrl = URL.createObjectURL(file);
      video.src = blobUrl;
      video.onload = () => URL.revokeObjectURL(blobUrl);
      
      container.appendChild(video);
      item.appendChild(container);
      
    }else{
      // File preview
      const fileInfo = document.createElement('div');
      fileInfo.className = 'media-preview-file-info';
      
      const icon = document.createElement('div');
      icon.className = 'media-preview-file-icon';
      icon.textContent = '';
      
      const details = document.createElement('div');
      details.className = 'media-preview-file-details';
      
      const fileName = document.createElement('div');
      fileName.className = 'media-preview-file-name';
      fileName.textContent = file.name;
      
      const fileSize = document.createElement('div');
      fileSize.className = 'media-preview-file-size';
      fileSize.textContent = formatBytes(file.size);
      
      details.appendChild(fileName);
      details.appendChild(fileSize);
      
      fileInfo.appendChild(icon);
      fileInfo.appendChild(details);
      
      item.appendChild(fileInfo);
    }
    
    // Add caption input
    const captionDiv = document.createElement('div');
    captionDiv.className = 'media-preview-caption-input';
    
    const captionTextarea = document.createElement('textarea');
    captionTextarea.placeholder = 'Add a caption...';
    captionTextarea.dataset.fileIndex = i;
    
    captionDiv.appendChild(captionTextarea);
    item.appendChild(captionDiv);
    
    previewContent.appendChild(item);
  }
  
  // Show modal
  previewModal.classList.add('active');
  document.body.style.overflow = 'hidden';
  
  // Focus first caption input
  setTimeout(() => {
    const firstInput = previewContent.querySelector('textarea');
    if(firstInput) firstInput.focus();
  }, 100);
}

// Close media preview modal
function closeMediaPreviewModal(){
  const previewModal = document.getElementById('mediaPreviewModal');
  previewModal.classList.remove('active');
  document.body.style.overflow = '';
  pendingMediaFiles = [];
}

// Send media from preview modal
async function sendMediaFromPreview(){
  console.log('[sendMediaFromPreview] Send button clicked');
  
  const previewContent = document.getElementById('mediaPreviewContent');
  const captions = [];
  
  // Collect captions from all textareas
  const textareas = previewContent.querySelectorAll('textarea');
  console.log(`[sendMediaFromPreview] Found ${textareas.length} caption textareas`);
  
  textareas.forEach((textarea, idx) => {
    const caption = textarea.value.trim();
    captions.push(caption);
    console.log(`[sendMediaFromPreview] Caption ${idx}: "${caption}"`);
  });
  
  console.log(`[sendMediaFromPreview] Pending files count: ${pendingMediaFiles.length}`);
  
  // CRITICAL: Save files to local variable BEFORE closing modal
  // (closeMediaPreviewModal clears pendingMediaFiles)
  const filesToSend = [...pendingMediaFiles];
  console.log(`[sendMediaFromPreview] Saved ${filesToSend.length} files to local variable`);
  
  // Close modal
  closeMediaPreviewModal();
  
  // Send media with captions (using local copy of files)
  console.log('[sendMediaFromPreview] Calling sendMediaMessage...');
  await sendMediaMessage(filesToSend, captions);
  console.log('[sendMediaFromPreview] sendMediaMessage completed');
}

// Start recording
async function startAudioRecording(){
  try{
    // Request microphone permission
    audioStream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      } 
    });
    
    // Setup MediaRecorder
    const options = { mimeType: 'audio/webm;codecs=opus' };
    if(!MediaRecorder.isTypeSupported(options.mimeType)){
      options.mimeType = 'audio/webm';
      if(!MediaRecorder.isTypeSupported(options.mimeType)){
        options.mimeType = 'audio/mp4';
      }
    }
    
    mediaRecorder = new MediaRecorder(audioStream, options);
    audioChunks = [];
    
    mediaRecorder.ondataavailable = (e) => {
      if(e.data.size > 0){
        audioChunks.push(e.data);
      }
    };
    
    mediaRecorder.onstop = () => {
      recordedBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
      stopVisualizerAnimation();
      
      // If mobile gesture and not locked, send immediately
      if(isMobileGestureRecording && !isRecordingLocked){
        setTimeout(() => sendAudioMessage(), 300);
      }else{
        showAudioPreview();
      }
    };
    
    // Setup Web Audio API for real-time visualization
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const source = audioContext.createMediaStreamSource(audioStream);
    analyser = audioContext.createAnalyser();
    
    // Configure analyser
    analyser.fftSize = 256; // Higher = more detail, lower = better performance
    bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    
    // Connect source to analyser (don't connect to destination to avoid feedback)
    source.connect(analyser);
    
    // Start recording
    mediaRecorder.start(100); // Collect data every 100ms
    recordingStartTime = Date.now();
    pausedDuration = 0;
    audioPaused = false;
    
    // Show modal or overlay based on mode
    if(isMobileGestureRecording){
      recordingOverlay.classList.add('active');
    }else{
      audioModal.classList.add('active');
    }
    
    audioRecordBtn.classList.add('recording');
    
    // Initialize visualizer
    initVisualizer();
    
    // Start timer and real-time visualizer
    recordingInterval = setInterval(updateTimer, 100);
    updateVisualizer(); // Start animation loop
    
    // Show initial time
    audioTimer.textContent = '0:00';
    audioStopBtn.style.display = 'block';
    audioPauseBtn.style.display = 'block';
    audioSendBtn.style.display = 'none';
    
    log(' Audio recording started', 'INFO');
    
  }catch(error){
    console.error('Error starting audio recording:', error);
    showToast('Could not access microphone: ' + error.message, 'error');
    stopAudioRecording();
  }
}

// Pause/Resume recording
function togglePauseRecording(){
  if(!mediaRecorder || mediaRecorder.state === 'inactive') return;
  
  if(audioPaused){
    // Resume
    mediaRecorder.resume();
    pausedDuration += Date.now() - lastPauseTime;
    audioPaused = false;
    audioPauseBtn.textContent = ' Pause';
    audioPauseBtn.classList.remove('record');
    audioPauseBtn.classList.add('pause');
    log(' Recording resumed', 'INFO');
  }else{
    // Pause
    mediaRecorder.pause();
    lastPauseTime = Date.now();
    audioPaused = true;
    audioPauseBtn.textContent = ' Resume';
    audioPauseBtn.classList.remove('pause');
    audioPauseBtn.classList.add('record');
    log(' Recording paused', 'INFO');
  }
}

// Stop recording
function stopAudioRecording(){
  if(mediaRecorder && mediaRecorder.state !== 'inactive'){
    mediaRecorder.stop();
  }
  
  if(audioStream){
    audioStream.getTracks().forEach(track => track.stop());
    audioStream = null;
  }
  
  // Cleanup Web Audio API
  if(audioContext){
    audioContext.close().catch(e => console.warn('Error closing audio context:', e));
    audioContext = null;
  }
  analyser = null;
  dataArray = null;
  
  clearInterval(recordingInterval);
  stopVisualizerAnimation();
  
  audioRecordBtn.classList.remove('recording');
  recordingOverlay.classList.remove('active');
  gestureHint.classList.remove('active');
  isRecordingLocked = false;
  isMobileGestureRecording = false;
}

// Cancel recording
function cancelAudioRecording(){
  stopAudioRecording();
  recordedBlob = null;
  audioChunks = [];
  closeAudioModal();
  log(' Recording cancelled', 'INFO');
}

// Show preview with play button
function showAudioPreview(){
  audioModal.classList.add('active');
  recordingOverlay.classList.remove('active');
  gestureHint.classList.remove('active');
  
  audioStopBtn.style.display = 'none';
  audioPauseBtn.style.display = 'none';
  audioSendBtn.style.display = 'block';
  
  // Create preview audio element
  const previewContainer = document.createElement('div');
  previewContainer.style.cssText = 'display:flex; align-items:center; justify-content:center; gap:15px; width:100%;';
  
  const playBtn = document.createElement('button');
  playBtn.id = 'previewPlayBtn';
  playBtn.style.cssText = `
    background:linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
    border:none;
    color:#fff;
    width:60px;
    height:60px;
    border-radius:50%;
    font-size:24px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:all .2s ease;
  `;
  playBtn.textContent = '';
  
  const previewText = document.createElement('div');
  previewText.style.cssText = 'flex:1; text-align:center; color:var(--muted);';
  previewText.textContent = 'Click to preview audio';
  
  // Create hidden audio element
  const audioEl = document.createElement('audio');
  audioEl.id = 'previewAudio';
  if(recordedBlob){
    const audioUrl = URL.createObjectURL(recordedBlob);
    audioEl.src = audioUrl;
    audioEl.preload = 'auto';
    
    console.log('Preview audio created:', {
      blobSize: recordedBlob.size,
      blobType: recordedBlob.type,
      url: audioUrl
    });
  }
  
  playBtn.onclick = () => {
    if(!audioEl.src){
      showToast('No audio to preview', 'error');
      return;
    }
    
    if(audioEl.paused){
      audioEl.play().then(() => {
        playBtn.textContent = '';
        previewText.textContent = 'Playing...';
        log(' Playing preview', 'INFO');
      }).catch(e => {
        console.error('Error playing preview:', e);
        showToast('Could not play preview: ' + e.message, 'error');
      });
    }else{
      audioEl.pause();
      playBtn.textContent = '';
      previewText.textContent = 'Click to preview audio';
    }
  };
  
  audioEl.onended = () => {
    playBtn.textContent = '';
    previewText.textContent = 'Click to preview audio';
  };
  
  previewContainer.appendChild(playBtn);
  previewContainer.appendChild(previewText);
  
  audioVisualizer.innerHTML = '';
  audioVisualizer.appendChild(previewContainer);
  audioVisualizer.appendChild(audioEl);
  
  log(' Audio preview ready', 'INFO');
}

// Send audio message
async function sendAudioMessage(){
  if(!recordedBlob || !running || !currentRoom) return;
  
  try{
    const now = Date.now();
    const userId = session?.userId || localGuest.userId;
    const sender = (nameInput.value||"").trim() || session?.username || localGuest.name || "Anon";
    
    // Calculate audio duration
    const audioDuration = (Date.now() - recordingStartTime - pausedDuration) / 1000;
    
    const messageId = `m-${now}-${Math.random().toString(36).slice(2,8)}`;
    
    const ip = null;
    const device = `${navigator.platform || 'unknown'} - ${navigator.userAgent.slice(0,50)}`;
    const sessionType = session?.userId ? 'registered' : (String(localGuest.userId||'').startsWith('g-') ? 'guest' : 'anon');
    
    // Upload audio to GitHub first (isRecorded = true)
    log(' Uploading recorded audio to GitHub...', 'INFO');
    const uploadResult = await uploadAudioToGitHub(recordedBlob, messageId, currentRoom, true);
    
    if(!uploadResult.ok){
      throw new Error('Failed to upload audio: ' + uploadResult.error);
    }
    
    const msg = {
      id: messageId,
      room: currentRoom,
      sender,
      userId,
      ts: now,
      text: ' Voice message',
      type: 'audio',
      audioPath: uploadResult.path,
      audioFileName: uploadResult.fileName,
      audioFolderType: uploadResult.folderType,
      audioDuration: audioDuration,
      audioMimeType: recordedBlob.type,
      audioSize: recordedBlob.size,
      listenedBy: [], // AUDIO READ RECEIPT: Initialize empty array - will be populated when users play the audio
      edited: false,
      editedAt: null,
      deleted: false,
      createdAt: now,
      status: 'sending',
      replyTo: replyingTo ? {
        msgId: replyingTo.msgId,
        sender: replyingTo.sender,
        text: replyingTo.text,
        userId: replyingTo.userId
      } : null,
      meta: {
        sessionType,
        sessionUsername: session?.username || null,
        device,
        ip,
        ua: navigator.userAgent || null
      }
    };
    
    // Show in UI immediately
    addMessageToDom(msg);
    closeAudioModal();
    cancelReplyTo();
    markInteraction("send");
    
    // Send message metadata to GitHub
    try{
      log(` Sending audio message metadata to GitHub...`, "INFO");
      const result = await appendMessageV3(currentRoom, msg);
      
      if(result && result.cellSha){
        msg.status = 'sent';
        updateMessageStatus(msg.id, 'sent');
        log(` Audio message sent (cell ${result.cellNum})`, "INFO");
        
        // Enter burst mode
        burstModeUntil = Date.now() + POLL_BURST_DURATION;
        if(running && currentRoom){
          clearTimeout(pollTimer);
          scheduleNextPoll(POLL_MS_BURST);
        }
        
        await presenceSetOnline(true, "send");
        await maybeRefreshPresence();
        
        setTimeout(() => {
          msg.status = 'delivered';
          updateMessageStatus(msg.id, 'delivered');
        }, 200); //  200ms para feedback instantneo
      }else{
        throw new Error("GitHub write returned no SHA");
      }
    }catch(e){
      console.error('[sendAudioMessage ERROR]', e);
      msg.status = 'failed';
      updateMessageStatus(msg.id, 'failed');
      log(` Failed to send audio: ${e.message}`, "ERROR");
      showToast('Failed to send audio message', 'error');
    }
    
  }catch(error){
    console.error('Error sending audio:', error);
    showToast('Failed to send audio message: ' + error.message, 'error');
    closeAudioModal();
  }
}

// Close audio modal
function closeAudioModal(){
  audioModal.classList.remove('active');
  recordingOverlay.classList.remove('active');
  gestureHint.classList.remove('active');
  stopAudioRecording();
  recordedBlob = null;
  audioChunks = [];
  isRecordingLocked = false;
  isMobileGestureRecording = false;
}

// Event listeners
audioRecordBtn.onclick = () => {
  if(!running || !currentRoom){
    showToast('Join a room first', 'warning');
    return;
  }
  startAudioRecording();
};

audioCloseBtn.onclick = closeAudioModal;
audioStopBtn.onclick = stopAudioRecording;
audioPauseBtn.onclick = togglePauseRecording;
audioSendBtn.onclick = sendAudioMessage;

// Mobile: Touch gestures for recording
let touchStartY = 0;
let touchStartX = 0;
let touchStartTime = 0;

audioRecordBtn.addEventListener('touchstart', (e) => {
  if(!running || !currentRoom) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  touchStartY = touch.clientY;
  touchStartX = touch.clientX;
  touchStartTime = Date.now();
  
  const rect = audioRecordBtn.getBoundingClientRect();
  recordingStartPos = {
    x: rect.left + rect.width / 2,
    y: rect.top + rect.height / 2
  };
  
  // Position gesture hints
  gestureHint.style.left = recordingStartPos.x + 'px';
  gestureHint.style.top = recordingStartPos.y + 'px';
  gestureHint.classList.add('active');
  gestureText.textContent = ' Slide up to lock';
  
  // Start recording in gesture mode
  isMobileGestureRecording = true;
  isRecordingLocked = false;
  startAudioRecording();
});

audioRecordBtn.addEventListener('touchmove', (e) => {
  if(!isMobileGestureRecording) return;
  e.preventDefault();
  
  const touch = e.touches[0];
  const deltaY = touchStartY - touch.clientY; // Positive when sliding up
  const deltaX = touchStartX - touch.clientX; // Positive when sliding left
  
  // Check for slide up to lock (80px threshold)
  if(deltaY > 80 && !isRecordingLocked){
    isRecordingLocked = true;
    gestureLock.classList.add('highlight');
    gestureText.textContent = ' Recording locked';
    audioModal.classList.add('active');
    recordingOverlay.classList.remove('active');
    setTimeout(() => {
      gestureHint.classList.remove('active');
    }, 500);
    log(' Recording locked', 'INFO');
  }
  
  // Check for slide left to cancel (100px threshold)
  if(deltaX > 100 && !isRecordingLocked){
    gestureCancel.classList.add('highlight');
    gestureText.textContent = ' Cancelled';
    setTimeout(() => {
      cancelAudioRecording();
    }, 200);
  }
  
  // Visual feedback for gestures
  if(deltaY > 40 && !isRecordingLocked){
    gestureLock.classList.add('highlight');
  }else if(!isRecordingLocked){
    gestureLock.classList.remove('highlight');
  }
  
  if(deltaX > 60 && !isRecordingLocked){
    gestureCancel.classList.add('highlight');
  }else{
    gestureCancel.classList.remove('highlight');
  }
});

audioRecordBtn.addEventListener('touchend', (e) => {
  if(!isMobileGestureRecording) return;
  e.preventDefault();
  
  const touchDuration = Date.now() - touchStartTime;
  
  // If locked, keep recording (user can use modal controls)
  if(isRecordingLocked){
    gestureHint.classList.remove('active');
    return;
  }
  
  // If too short (< 500ms), cancel
  if(touchDuration < 500){
    gestureText.textContent = 'Too short!';
    setTimeout(() => {
      cancelAudioRecording();
    }, 300);
    return;
  }
  
  // Otherwise, stop and send
  stopAudioRecording();
  gestureHint.classList.remove('active');
});

// Prevent default click when using touch gestures
audioRecordBtn.addEventListener('touchstart', (e) => {
  e.stopPropagation();
}, { passive: false });

// Global paste handler for images (works when chat is active)
// Supports: PC (Ctrl+V), Mac (Cmd+V), iOS (long-press paste), Android (long-press paste)
document.addEventListener('paste', async (e) => {
  // Only handle paste when chat is active and in a room
  if(!running || !currentRoom) return;
  
  // Don't handle if pasting in a textarea/input (except msgInput which has its own handler)
  const target = e.target;
  if(target.tagName === 'TEXTAREA' || target.tagName === 'INPUT'){
    if(target.id !== 'msgInput') return; // Let msgInput handler deal with it
  }
  
  const items = e.clipboardData?.items;
  if(!items || items.length === 0){
    console.log('[Global Paste] No clipboard items found');
    return;
  }
  
  const imageFiles = [];
  
  // Check for image items in clipboard
  for(let i = 0; i < items.length; i++){
    const item = items[i];
    
    // Check if item is an image
    if(item.type.indexOf('image') !== -1){
      e.preventDefault(); // Prevent default paste behavior for images
      
      const file = item.getAsFile();
      if(file){
        console.log('[Global Paste] Image detected:', file.name, file.type, formatBytes(file.size));
        imageFiles.push(file);
      }
    }
  }
  
  // If images were pasted, show preview modal
  if(imageFiles.length > 0){
    console.log(`[Global Paste] ${imageFiles.length} image(s) pasted from clipboard`);
    showMediaPreviewModal(imageFiles);
    showToast(` ${imageFiles.length} image(s) pasted - Add caption and send`, 'success', 3000);
  }
});

sendBtn.onclick = ()=>sendMessage();

// Media attach button
mediaAttachBtn.onclick = () => {
  mediaFileInput.click();
};

// Paste from clipboard button (works on mobile too)
pasteClipboardBtn.onclick = async () => {
  try{
    // Check if Clipboard API is supported
    if(!navigator.clipboard || !navigator.clipboard.read){
      // Fallback: show instructions
      showToast(' Tap on the chat area and use your device\'s paste gesture', 'info', 4000);
      msgInput.focus();
      return;
    }
    
    console.log('[Paste Button] Reading clipboard...');
    const clipboardItems = await navigator.clipboard.read();
    const imageFiles = [];
    
    for(const item of clipboardItems){
      // Check if item has image types
      for(const type of item.types){
        if(type.startsWith('image/')){
          const blob = await item.getType(type);
          // Convert blob to File
          const file = new File([blob], `pasted-image-${Date.now()}.${type.split('/')[1]}`, { type });
          console.log('[Paste Button] Image found:', file.name, file.type, formatBytes(file.size));
          imageFiles.push(file);
          break; // Only take first image type per item
        }
      }
    }
    
    if(imageFiles.length > 0){
      console.log(`[Paste Button] ${imageFiles.length} image(s) found in clipboard`);
      showMediaPreviewModal(imageFiles);
      showToast(` ${imageFiles.length} image(s) pasted from clipboard`, 'success', 3000);
    }else{
      showToast(' No images found in clipboard', 'warning', 3000);
      console.log('[Paste Button] No images in clipboard');
    }
  }catch(error){
    console.error('[Paste Button] Error reading clipboard:', error);
    
    // Show helpful message based on error
    if(error.name === 'NotAllowedError'){
      showToast(' Clipboard access denied. Please grant permission.', 'warning', 4000);
    }else{
      showToast(' Use Ctrl+V (PC) or long-press paste (mobile) to paste images', 'info', 4000);
    }
    
    // Focus input so traditional paste works
    msgInput.focus();
  }
};

// File input change handler
mediaFileInput.addEventListener('change', async (e) => {
  const files = Array.from(e.target.files || []);
  if(files.length === 0) return;
  
  log(` Selected ${files.length} file(s) for upload`, 'INFO');
  
  // Show media preview modal instead of immediately sending
  showMediaPreviewModal(files);
  
  // Clear file input
  mediaFileInput.value = '';
});

// Image viewer controls
imageViewerClose.onclick = closeImageViewer;
imageViewerPrev.onclick = viewerPrev;
imageViewerNext.onclick = viewerNext;
imageViewerDownload.onclick = downloadCurrentImage;

// Gallery drawer controls
galleryDrawerClose.onclick = closeGalleryDrawer;

// Media preview modal controls
const mediaPreviewModal = document.getElementById('mediaPreviewModal');
const mediaPreviewClose = document.getElementById('mediaPreviewClose');
const mediaPreviewCancel = document.getElementById('mediaPreviewCancel');
const mediaPreviewSend = document.getElementById('mediaPreviewSend');

// Safety check: verify all elements exist
if(!mediaPreviewModal) console.error('[Init] mediaPreviewModal element not found!');
if(!mediaPreviewClose) console.error('[Init] mediaPreviewClose element not found!');
if(!mediaPreviewCancel) console.error('[Init] mediaPreviewCancel element not found!');
if(!mediaPreviewSend) console.error('[Init] mediaPreviewSend element not found!');

if(mediaPreviewClose) mediaPreviewClose.onclick = closeMediaPreviewModal;
if(mediaPreviewCancel) mediaPreviewCancel.onclick = closeMediaPreviewModal;
if(mediaPreviewSend){
  mediaPreviewSend.onclick = () => {
    console.log('[Event] Media preview send button clicked');
    sendMediaFromPreview().catch(err => {
      console.error('[Event] Error in sendMediaFromPreview:', err);
      showToast('Failed to send media: ' + err.message, 'error');
    });
  };
  console.log('[Init] Media preview send button handler attached successfully');
}else{
  console.error('[Init] Cannot attach send handler - button not found');
}

// Keyboard navigation in viewer
document.addEventListener('keydown', (e) => {
  if(!imageViewer.classList.contains('active')) return;
  
  if(e.key === 'Escape'){
    closeImageViewer();
  }else if(e.key === 'ArrowLeft'){
    viewerPrev();
  }else if(e.key === 'ArrowRight'){
    viewerNext();
  }
});

// Swipe gestures for image viewer (mobile)
let viewerTouchStartX = 0;
let viewerTouchEndX = 0;

imageViewerContent.addEventListener('touchstart', (e) => {
  viewerTouchStartX = e.changedTouches[0].screenX;
}, {passive: true});

imageViewerContent.addEventListener('touchend', (e) => {
  viewerTouchEndX = e.changedTouches[0].screenX;
  handleViewerSwipe();
}, {passive: true});

function handleViewerSwipe(){
  const swipeThreshold = 50;
  const diff = viewerTouchStartX - viewerTouchEndX;
  
  if(Math.abs(diff) > swipeThreshold){
    if(diff > 0){
      // Swiped left -> next
      viewerNext();
    }else{
      // Swiped right -> prev
      viewerPrev();
    }
  }
}

clearBtn.onclick = ()=>{
  clearView();
  // Also reset behavior tracking when clearing view
  resetBehaviorTracking();
  // Reset unread/mention counters
  markAllAsRead();
};

// Cancel reply button
cancelReply.onclick = ()=>{
  cancelReplyTo();
};

// Mark as read when scrolling to bottom
messagesEl.addEventListener('scroll', ()=>{
  const { scrollTop, scrollHeight, clientHeight } = messagesEl;
  const isAtBottom = Math.abs((scrollTop + clientHeight) - scrollHeight) < 50;
  
  if(isAtBottom){
    // User scrolled to bottom - mark all as read
    markAllAsRead();
  }
}, {passive: true});

// Debug command: type "/engagement" to see current score
const originalSendMessage = sendMessage;
window.sendMessage = async function(){
  const text = (msgInput.value||"").trim();
  
  // Check for engagement command
  if(text === '/engagement'){
    const engagement = getEngagementScore();
    const dwells = Array.from(userBehavior.dwellTimes.entries())
      .sort((a,b) => b[1].totalTime - a[1].totalTime)
      .slice(0, 3);
    
    let report = ` Engagement Report\n`;
    report += `Sentiment: ${engagement.sentiment}\n`;
    report += `Score: ${engagement.score.toFixed(1)}\n`;
    report += `\nSignals:\n`;
    report += `   Positive: ${engagement.breakdown.positive.toFixed(1)}\n`;
    report += `   Negative: ${engagement.breakdown.negative.toFixed(1)}\n`;
    report += `   Excitement: ${engagement.breakdown.excitement.toFixed(1)}\n`;
    report += `\nMetrics:\n`;
    report += `   Long dwells: ${userBehavior.engagement.longDwells}\n`;
    report += `   Slow scrolls: ${userBehavior.engagement.slowScrolls}\n`;
    report += `   Quick scrolls: ${userBehavior.engagement.quickScrolls}\n`;
    report += `   Rapid taps: ${userBehavior.engagement.rapidTaps}\n`;
    report += `   Swipe left: ${userBehavior.engagement.swipeLeft}\n`;
    report += `   Swipe right: ${userBehavior.engagement.swipeRight}\n`;
    
    if(dwells.length > 0){
      report += `\nTop dwelled messages:\n`;
      dwells.forEach(([msgId, data], i) => {
        report += `  ${i+1}. ${(data.totalTime/1000).toFixed(1)}s (${data.visits} visits)\n`;
      });
    }
    
    log(report, "INFO");
    showToast(`Engagement: ${engagement.sentiment}`, 'info', 5000);
    msgInput.value = '';
    return;
  }
  
  // Normal send
  return originalSendMessage.call(this);
};

// Fullscreen chat toggle
let isFullscreen = false;
fullscreenBtn.onclick = ()=>{
  isFullscreen = !isFullscreen;
  
  if(isFullscreen){
    document.body.classList.add('chat-fullscreen');
    fullscreenBtn.textContent = ''; // Close icon
    fullscreenBtn.title = 'Exit fullscreen';
    log(' Fullscreen mode enabled', 'INFO');
  }else{
    document.body.classList.remove('chat-fullscreen');
    fullscreenBtn.textContent = ''; // Expand icon
    fullscreenBtn.title = 'Fullscreen chat';
    log(' Fullscreen mode disabled', 'INFO');
  }
};

roomInput.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){
    e.preventDefault();
    joinBtn.click();
  }
});

msgInput.addEventListener("input", (e)=>{
  // Trigger typing mode for fast polling
  if(currentRoom && running){
    startTypingMode();
  }
});

msgInput.addEventListener("keydown", (e)=>{
  if(e.key === "Enter"){
    // Shift+Enter -> newline, Enter (alone) -> send. Ctrl/Cmd+Enter also sends.
    if(e.shiftKey) return;
    e.preventDefault();
    stopTypingMode(); // Stop fast polling when sending
    sendMessage();
  }
});

// Paste images with Ctrl+V (PC)
msgInput.addEventListener("paste", async (e)=>{
  const items = e.clipboardData?.items;
  if(!items) return;
  
  const imageFiles = [];
  
  // Check for image items in clipboard
  for(let i = 0; i < items.length; i++){
    const item = items[i];
    
    // Check if item is an image
    if(item.type.indexOf('image') !== -1){
      e.preventDefault(); // Prevent default paste behavior for images
      
      const file = item.getAsFile();
      if(file){
        console.log('[Paste] Image detected:', file.name, file.type, file.size);
        imageFiles.push(file);
      }
    }
  }
  
  // If images were pasted, show preview modal
  if(imageFiles.length > 0){
    console.log(`[Paste] ${imageFiles.length} image(s) pasted, opening preview modal...`);
    showMediaPreviewModal(imageFiles);
    showToast(` ${imageFiles.length} image(s) pasted`, 'success', 2000);
  }
});

/* ============================================================
   BOOT
   ============================================================ */
window.addEventListener("load", async ()=>{
  try{
    setNet("bad","booting");
    initGuestIdentity();
    loadSessionFromStorage();
    applySessionToUi();

    installInteractionListeners();
    
    // Initialize pull-to-refresh gesture (tap-hold-drag only)
    initPullToRefreshGesture();
    log(" Pull-to-refresh gesture initialized (hold 500ms + drag 80px slowly)", "INFO");
    
    // Tab visibility: check for messages when tab becomes visible
    document.addEventListener("visibilitychange", ()=>{
      if(!document.hidden && running && currentRoom && !pollInFlight){
        // Tab became visible - check for new messages
        clearTimeout(pollTimer);
        setTimeout(pollLoop, 100);
      }
    });

    log(" Loading token","INFO");
    await ensureGhToken();

    log(" Loading password dictionary (READ ONLY)","INFO");
    await loadPasswordDictionary();

    if(PWD_DICT_READY){
      log(" Dictionary ready.","INFO");
    }else{
      log(" Dictionary missing. Login/Register disabled.","ERROR");
    }

    //  Inicializar IndexedDB para persistencia de media
    log(" Initializing media database","INFO");
    try{
      await initMediaDB();
      log(" Media database ready - files will persist across reloads","INFO");
      // Limpiar archivos viejos (>7 das) en background
      cleanOldMediaFromDB().catch(e => console.warn('Media cleanup warning:', e));
    }catch(e){
      console.error(' Media database failed:', e);
      log(" Media persistence disabled (using RAM only)","WARN");
    }

    setNet("ok","ready");
    log("Ready. Join a room.","INFO");
  }catch(e){
    console.error("[BOOT ERROR]", e);
    setNet("bad","boot error");
    log("Boot error: check network/token.","ERROR");
  }
});
</script>
<!-- Compatibility wrappers for Cp2pv3 API (aliases / helpers) -->
<script>
// These wrappers restore several Cp2pv3 function names expected by older modules.
// They are safe no-ops or thin adapters to Cp2pv4 implementations.
(function(){
  if(typeof b64 === 'undefined' && typeof b64EncodeUtf8 === 'function'){
    window.b64 = function(s){ return b64EncodeUtf8(String(s)); };
  }

  if(typeof ghRawUrl === 'undefined' && typeof rawUrl === 'function'){
    window.ghRawUrl = function(p){ return rawUrl(p); };
  }

  if(typeof makeMsgId === 'undefined'){
    window.makeMsgId = function(){ return `m-${Date.now()}-${Math.random().toString(36).slice(2,10)}`; };
  }

  if(typeof enforceDomCap === 'undefined'){
    window.enforceDomCap = function(){
      try{
        if(!window.messagesEl) return;
        while(messagesEl.children.length > (window.DOM_MAX_MESSAGES || 200)){
          messagesEl.removeChild(messagesEl.firstChild);
        }
      }catch(e){/* ignore */}
    };
  }

  if(typeof scrollToBottomSoon === 'undefined'){
    window.scrollToBottomSoon = function(){ requestAnimationFrame(()=>{ if(window.messagesEl) messagesEl.scrollTop = messagesEl.scrollHeight; }); };
  }

  // ghGetCellWithSha / ghGetManifestWithSha adapters (V3 names -> V4 helpers)
  if(typeof ghGetCellWithSha === 'undefined'){
    window.ghGetCellWithSha = async function(roomName, cellNumber){
      const p = cellPath(roomName, cellNumber);
      const got = await ghGetJsonWithSha(p);
      const arr = Array.isArray(got.obj) ? got.obj : [];
      return { path: p, sha: got.sha || null, arr };
    };
  }

  if(typeof ghGetManifestWithSha === 'undefined'){
    window.ghGetManifestWithSha = async function(roomName){
      const p = manifestPath(roomName);
      const got = await ghGetJsonWithSha(p);
      const obj = (got.obj && typeof got.obj === 'object') ? got.obj : null;
      return { path: p, sha: got.sha || null, obj };
    };
  }

  // appendMessageToCells compatibility -> appendMessageV3
  if(typeof appendMessageToCells === 'undefined' && typeof appendMessageV3 === 'function'){
    window.appendMessageToCells = async function(roomName, msg){
      return await appendMessageV3(roomName, msg);
    };
  }

  // bumpMaster / readMasterStampRaw aliases
  if(typeof bumpMaster === 'undefined' && typeof saveMasterValue === 'function'){
    window.bumpMaster = async function(roomName){
      await saveMasterValue(roomName, Date.now());
    };
  }

  if(typeof readMasterStampRaw === 'undefined' && typeof readMasterValue === 'function'){
    window.readMasterStampRaw = async function(roomName){
      const r = await readMasterValue(roomName);
      return { unchanged: false, stamp: r.ok ? (r.value ? Date.now() : 0) : 0 };
    };
  }

  // ghPutJson older signature compatibility: already implemented in file, keep alias
  if(typeof ghPutJsonCompat === 'undefined'){
    window.ghPutJsonCompat = function(path,obj,sha,commitMsg){ return ghPutJson(path,obj,sha,commitMsg); };
  }

})();
</script>
</body>
</html>
